<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0d1117">
    <title>The Final Third</title>

    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="target_PNG26.png">
    <link rel="apple-touch-icon" sizes="180x180" href="target_PNG26.png">
    <link rel="icon" type="image/png" sizes="32x32" href="target_PNG26.png">
    <link rel="icon" type="image/png" sizes="16x16" href="target_PNG26.png">
    
    <!-- iOS support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Final Third">

    <style>
        :root { --bg: #0d1117; --card: #161b22; --green: #2ea043; --gold: #d29922; --red: #da3633; --purple: #a371f7; --blue: #1f6feb; --text: #c9d1d9; --cyan: #3fb950; }
        body { background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 16px; padding-bottom: 120px; }
        
        /* HEADER */
        header { display: flex; flex-direction: column; gap: 10px; border-bottom: 1px solid #30363d; padding-bottom: 15px; margin-bottom: 15px; }
        .top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        h1 { margin: 0; font-size: 1.4rem; color: var(--blue); display: flex; align-items: center; gap: 10px; }
        .header-right { display: flex; gap: 10px; align-items: center; }
        .api-badge { background: #21262d; border: 1px solid #30363d; color: #8b949e; padding: 4px 8px; border-radius: 6px; font-size: 0.75rem; font-family: monospace; font-weight: bold; }
        .help-btn { background: #21262d; border: 1px solid #30363d; color: var(--gold); width: 28px; height: 28px; border-radius: 50%; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; }

        /* PULSE ANIMATIONS */
        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(46, 160, 67, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(46, 160, 67, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 160, 67, 0); } }
        @keyframes pulse-purple { 0% { box-shadow: 0 0 0 0 rgba(163, 113, 247, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(163, 113, 247, 0); } 100% { box-shadow: 0 0 0 0 rgba(163, 113, 247, 0); } }

        /* AUTO-PILOT */
        .notif-btn { background: #21262d; border: 1px solid #30363d; color: #888; padding: 6px 12px; border-radius: 20px; font-size: 1rem; cursor: pointer; transition: all 0.3s; line-height: 1; }
        .notif-btn.notif-on { background: rgba(56,139,253,0.15); border-color: var(--blue); }
        .pilot-btn { background: #21262d; border: 1px solid #30363d; color: #888; padding: 6px 12px; border-radius: 20px; font-size: 0.8rem; font-weight: bold; display: flex; align-items: center; gap: 6px; cursor: pointer; transition: all 0.3s; }
        .pilot-btn.active { background: rgba(46, 160, 67, 0.2); border-color: var(--green); color: var(--green); }
        .pilot-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
        .pilot-btn.active .pilot-dot { background: var(--green); box-shadow: 0 0 8px var(--green); }
        .pilot-btn.paused { border-color: var(--gold); color: var(--gold); animation: none; }

        /* TABS */
        .nav-tabs { display: flex; gap: 10px; margin-top: 15px; overflow-x: auto; padding-bottom: 5px; }
        .nav-tab { flex: 1; text-align: center; padding: 10px; background: #21262d; border-radius: 8px; border: 1px solid #30363d; color: #888; font-weight: bold; cursor: pointer; font-size: 0.9rem; white-space: nowrap; }
        .nav-tab.active { background: var(--blue); color: white; border-color: var(--blue); }

        select { width: 100%; padding: 12px; background: #21262d; color: white; border: 1px solid #30363d; border-radius: 8px; font-size: 1rem; font-weight: bold; outline: none; appearance: none; background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E"); background-repeat: no-repeat; background-position: right 15px top 50%; background-size: 12px auto; }

        /* STRATEGY CHIPS */
        .chip-container { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 5px; margin-bottom: 15px; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
        .chip-container::-webkit-scrollbar { display: none; }
        .chip { position: relative; white-space: nowrap; padding: 6px 12px; border-radius: 20px; background: #21262d; border: 1px solid #30363d; color: #888; font-size: 0.8rem; font-weight: bold; cursor: pointer; transition: all 0.2s; }
        .chip.active { background: #d29922; color: #0d1117; border-color: #d29922; }
        .chip-badge { position: absolute; top: -6px; right: -4px; background: var(--blue); color: white; font-size: 0.65rem; padding: 2px 6px; border-radius: 10px; border: 2px solid var(--bg); display: none; z-index: 5; }
        .chip-badge.active { display: block !important; }
        .chip-badge.urgent { background: var(--red); animation: pulse-red 2s infinite; }
        @keyframes pulse-red { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* CARDS */
        .match-card { background: var(--card); border: 1px solid #30363d; border-radius: 12px; padding: 15px; margin-bottom: 15px; position: relative; overflow: hidden; transition: all 0.3s; }
        .match-card:hover { border-color: #444; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .match-card.placed { border: 1px solid var(--green); background: rgba(46, 160, 67, 0.05); }
        .match-card.ghost { opacity: 0.5; border-color: #30363d; filter: grayscale(0.8); }
        .match-card.ghost:hover { opacity: 1; filter: grayscale(0); }
        .match-card.pulse-home { animation: pulse-green 2s infinite; border-color: var(--green); }
        .match-card.pulse-away { animation: pulse-purple 2s infinite; border-color: var(--purple); }

        .placed-badge { position: absolute; top: 0; right: 0; background: var(--green); color: white; font-size: 0.7rem; font-weight: bold; padding: 4px 8px; border-bottom-left-radius: 8px; }
        .league-name { font-size: 0.75rem; color: #8b949e; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.5px; }
        .score-row { display: flex; justify-content: space-between; align-items: flex-start; margin: 10px 0; }
        .team-col { width: 40%; display: flex; flex-direction: column; }
        .team-name { font-size: 1rem; font-weight: bold; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; display: flex; align-items: center; gap: 5px; }
        .goal-times { font-size: 0.75rem; color: var(--gold); margin-top: 4px; min-height: 14px; font-family: monospace; }
        .score-box { background: #21262d; padding: 8px 14px; border-radius: 8px; border: 1px solid #30363d; font-family: monospace; font-size: 1.2rem; font-weight: bold; }
        
        /* RANK BADGE ON CARD */
        .rank-on-card { color: var(--gold); font-size: 0.8rem; font-weight: bold; font-family: monospace; }

        /* SCHED ITEM */
        .sched-card { background: #161b22; border-bottom: 1px solid #30363d; padding: 12px; display: flex; justify-content: space-between; align-items: center; }
        .sched-time { font-family: monospace; color: var(--gold); font-weight: bold; width: 50px; font-size: 1rem; }
        .sched-teams { flex: 1; font-size: 0.9rem; }
        .sched-league { font-size: 0.75rem; color: #a371f7; text-transform: uppercase; margin-bottom: 4px; font-weight: bold; letter-spacing: 0.5px; }

        /* HISTORY ITEM */
        .hist-day { margin-bottom: 20px; }
        .hist-date-row { display: flex; justify-content: space-between; padding: 10px; background: #21262d; border-radius: 8px; font-weight: bold; margin-bottom: 10px; }
        .hist-unit-plus { color: var(--green); } .hist-unit-minus { color: var(--red); } .hist-unit-even { color: #888; }
        .hist-card { background: #161b22; border-bottom: 1px solid #30363d; padding: 12px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; }
        .hist-res-win { color: var(--green); font-weight: bold; border: 1px solid var(--green); padding: 2px 6px; border-radius: 4px; }
        .hist-res-loss { color: var(--red); font-weight: bold; border: 1px solid var(--red); padding: 2px 6px; border-radius: 4px; }
        .hist-res-open { color: var(--gold); font-weight: bold; border: 1px solid var(--gold); padding: 2px 6px; border-radius: 4px; }

        /* CARD WATCH TABLE */
        .card-table-row { display: flex; justify-content: space-between; align-items: center; background: #161b22; padding: 12px; border-bottom: 1px solid #30363d; transition: all 0.3s; }
        .card-table-row.marked { background: rgba(46, 160, 160, 0.1); border-left: 3px solid var(--green); }
        .card-table-row.subbed-off { opacity: 0.4; filter: grayscale(1); background: #0d1117; pointer-events: none; }
        .card-player-info { display: flex; flex-direction: column; flex: 1; }
        .card-player-name { font-weight: bold; color: white; display: flex; align-items: center; gap: 6px; }
        .card-match-info { font-size: 0.75rem; color: #888; }
        .card-foul-badge { background: rgba(100, 100, 100, 0.2); color: #888; border: 1px solid #555; padding: 4px 8px; border-radius: 6px; font-weight: bold; font-family: monospace; white-space: nowrap; }
        .card-foul-badge.warning { background: rgba(210, 153, 34, 0.2); color: var(--gold); border: 1px solid var(--gold); }
        .card-foul-badge.critical { background: rgba(255, 140, 0, 0.25); color: #ff8c00; border: 1px solid #ff8c00; animation: pulse-orange 2s infinite; }
        .card-foul-badge.danger { background: rgba(218, 54, 51, 0.3); color: var(--red); border: 2px solid var(--red); animation: pulse-red 1.5s infinite; }
        @keyframes pulse-orange { 0% { box-shadow: 0 0 0 0 rgba(255, 140, 0, 0.4); } 70% { box-shadow: 0 0 0 6px rgba(255, 140, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 140, 0, 0); } }
        .card-scan-btn { width: 100%; background: #da3633; color: white; border: none; padding: 14px; border-radius: 8px; font-weight: bold; font-size: 1rem; margin-bottom: 20px; cursor: pointer; box-shadow: 0 4px 15px rgba(218, 54, 51, 0.3); }
        .ref-badge { font-size: 0.7rem; background: #333; padding: 2px 6px; border-radius: 4px; margin-top: 4px; display: inline-block; color: #bbb; }
        .ref-strict { color: #da3633; border: 1px solid #da3633; background: rgba(218, 54, 51, 0.1); }
        .ref-lenient { color: #2ea043; border: 1px solid #2ea043; background: rgba(46, 160, 67, 0.1); }
        .card-check-btn { background: #21262d; border: 1px solid #30363d; color: #888; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-right: 10px; font-size: 1rem; }
        .card-check-btn.active { background: var(--green); color: white; border-color: var(--green); }

        /* BUTTONS */
        .btn-row { display: flex; gap: 10px; margin-top: 10px; }
        .player-btn { flex: 1; background: #21262d; border: 1px solid #30363d; color: #ccc; padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer;}
        .analyze-btn { flex: 1; background: rgba(163, 113, 247, 0.15); border: 1px solid var(--purple); color: var(--purple); padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer; }
        .bet365-btn { flex: 1; background: #00703c; border: 1px solid #005c31; color: white; padding: 10px; border-radius: 8px; font-weight: bold; cursor: pointer; text-decoration: none; text-align: center; display: block;}
        .copy-btn { width:100%; background: #333; border: 1px solid #444; color: #fff; padding: 8px; border-radius: 6px; font-size: 0.8rem; margin-top: 8px; cursor: pointer; }
        .mark-btn { flex: 0.4; background: #21262d; border: 1px solid #30363d; color: #888; border-radius: 8px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; }
        .mark-btn.active { background: var(--green); color: white; border-color: var(--green); }
        .export-btn { width:100%; background: #21262d; border: 1px solid var(--gold); color: var(--gold); padding: 10px; border-radius: 8px; font-weight: bold; cursor: pointer; margin-bottom: 20px; }
        
        /* SCAN BUTTON - BLUE */
        .scan-btn { position: fixed; bottom: 30px; left: 5%; width: 90%; background: var(--blue); color: white; border: none; padding: 16px; border-radius: 16px; font-size: 1.1rem; font-weight: bold; box-shadow: 0 5px 20px rgba(0,0,0,0.5); z-index: 999999; }

        /* ANALYSIS & PLAYER BOX */
        .analysis-box.is-synthetic { border: 2px solid var(--gold) !important; box-shadow: 0 0 10px rgba(210, 153, 34, 0.3); }
        .player-box { background: #1c1c1c; border: 1px solid #30363d; padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.9rem; display: none; }
        
        .stat-bar { display: flex; justify-content: space-between; margin-bottom: 4px; color: #bbb; font-size: 0.8rem; }
        .stat-val { font-weight: bold; color: white; }
        .gauge-container { height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin: 5px 0 15px 0; display: flex; }
        .gauge-home { background: var(--green); height: 100%; transition: width 0.5s; }
        .gauge-away { background: var(--purple); height: 100%; transition: width 0.5s; }
        .gauge-labels { display: flex; justify-content: space-between; font-size: 0.75rem; color: #888; margin-top:-2px; margin-bottom: 10px; }
        
        .tip-box { background: rgba(255, 255, 255, 0.05); border-radius: 6px; padding: 8px; margin: 10px 0; border-left: 3px solid var(--gold); }
        .tip-header { font-size: 0.75rem; color: #888; text-transform: uppercase; margin-bottom: 4px; font-weight: bold; }
        .tip-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .tip-name { color: #fff; font-weight: bold; font-size: 0.9rem; }
        
        .val-good { color: var(--green); text-shadow: 0 0 5px rgba(46, 160, 67, 0.5); }
        .rank-badge { font-size: 0.75rem; color: var(--gold); margin-left: 4px; font-weight: normal; }
        .est-badge { font-size: 0.7rem; background: #333; padding: 2px 4px; border-radius: 3px; color: #888; margin-left: 5px; }
        .synth-badge { font-size: 0.7rem; background: rgba(63, 185, 80, 0.2); color: var(--cyan); padding: 2px 4px; border-radius: 3px; margin-left: 5px; border: 1px solid var(--cyan); }
        .stat-box.is-synthetic {
            border: 1px solid #d29922;
            box-shadow: 0 0 8px rgba(210, 153, 34, 0.4);
        }
        .ignore-msg { color: var(--red); font-weight: bold; text-align: center; border: 1px solid var(--red); padding: 8px; border-radius: 6px; background: rgba(218, 54, 51, 0.1); margin-bottom: 10px; }
        .ref-name { font-size: 0.75rem; color: #888; display: block; text-align: center; margin-top: 4px; font-style: italic; }

        /* BANKROLL MILESTONES */
        .milestone-track { position: relative; height: 24px; margin-top: 8px; }
        .milestone-dot { position: absolute; top: 0; width: 8px; height: 8px; border-radius: 50%; background: #555; border: 2px solid #333; transform: translateX(-50%); z-index: 2; }
        .milestone-dot.reached { background: var(--gold); border-color: var(--gold); box-shadow: 0 0 6px var(--gold); }
        .milestone-label { position: absolute; top: 12px; font-size: 0.6rem; color: #666; transform: translateX(-50%); white-space: nowrap; }

        /* STATS DASHBOARD */
        .stats-card { background: var(--card); border: 1px solid #30363d; border-radius: 12px; padding: 15px; margin-bottom: 15px; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .stat-tile { background: #21262d; border-radius: 8px; padding: 12px; text-align: center; }
        .stat-tile-value { font-size: 1.4rem; font-weight: bold; }
        .stat-tile-label { font-size: 0.7rem; color: #888; text-transform: uppercase; margin-top: 4px; }
        .stats-bar { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .stats-bar-label { width: 90px; font-size: 0.75rem; color: #aaa; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .stats-bar-track { flex: 1; height: 14px; background: #21262d; border-radius: 4px; overflow: hidden; }
        .stats-bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s; min-width: 2px; }
        .stats-bar-val { width: 40px; font-size: 0.75rem; color: #ccc; font-weight: bold; }

        /* MATCH TIMELINE */
        .match-timeline { display: flex; align-items: center; height: 20px; background: #21262d; border-radius: 4px; margin: 8px 0; position: relative; overflow: hidden; }
        .timeline-marker { position: absolute; width: 3px; height: 100%; border-radius: 1px; }
        .timeline-half { position: absolute; left: 50%; width: 1px; height: 100%; background: #444; }
        .timeline-tooltip { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #333; color: white; font-size: 0.65rem; padding: 2px 5px; border-radius: 3px; white-space: nowrap; display: none; z-index: 10; }
        .timeline-marker:hover .timeline-tooltip { display: block; }

        /* CONFIDENCE SLIDER */
        .conf-slider-container { padding: 10px 12px; margin-bottom: 10px; }
        .conf-slider { -webkit-appearance: none; width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(90deg, #da3633, #d29922, #2ea043); outline: none; }
        .conf-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: white; border: 2px solid var(--blue); cursor: pointer; }
        .conf-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: white; border: 2px solid var(--blue); cursor: pointer; }

        /* FAVOURITE LEAGUE STAR */
        .fav-star { cursor: pointer; font-size: 0.9rem; margin-right: 4px; opacity: 0.4; transition: opacity 0.2s; }
        .fav-star.active { opacity: 1; }

        /* BET NOTE */
        .bet-note-input { width: calc(100% - 16px); background: #0d1117; border: 1px solid #30363d; color: #ccc; padding: 6px 8px; border-radius: 6px; font-size: 0.75rem; margin-top: 6px; resize: none; font-family: inherit; }
        
        .form-badge { font-family: monospace; font-size: 0.7rem; letter-spacing: 1px; margin-left: 5px; }
        .form-w { color: var(--green); } .form-l { color: var(--red); } .form-d { color: #888; }

        .pos-badge { font-size: 0.75rem; color: #58a6ff; background: transparent; padding: 1px 4px; border-radius: 4px; margin-left: 4px; font-weight: 800; vertical-align: middle; font-family: monospace; }
        .pos-badge:empty { display: none; }
        
        /* PLAYER RATINGS */
        .player-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #333; }
        .player-name { font-weight: bold; color: white; font-size: 0.9rem; }
        .player-rating { font-family: monospace; font-weight: bold; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; }
        .rate-high { color: var(--green); border: 1px solid var(--green); background: rgba(46, 160, 67, 0.1); }
        .rate-med { color: var(--gold); border: 1px solid var(--gold); background: rgba(210, 153, 34, 0.1); }
        .player-detail { font-size: 0.75rem; color: #888; margin-top: 2px; }

        /* MODALS */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; overflow-y: auto; }
        .modal-content { background: #161b22; margin: 10% auto; padding: 20px; width: 85%; border-radius: 12px; border: 1px solid #30363d; max-width: 500px; padding-bottom: 100px; }
        .modal h2 { color: var(--blue); border-bottom: 1px solid #30363d; padding-bottom: 10px; margin-top: 0; }
        .modal h3 { color: var(--gold); margin-top: 20px; margin-bottom: 5px; }
        .modal p { color: #ccc; font-size: 0.9rem; line-height: 1.5; margin-top: 0; }
        .close-modal { background: #333; color: white; border: none; width: 100%; padding: 12px; border-radius: 8px; font-weight: bold; margin-top: 20px; font-size: 1rem; cursor: pointer; }
        
        /* EXPANDABLE DETAILS */
        details { margin-bottom: 10px; background: rgba(255,255,255,0.03); border-radius: 8px; padding: 10px; border: 1px solid #30363d; }
        summary { cursor: pointer; font-weight: bold; color: var(--blue); outline: none; list-style: none; display: flex; justify-content: space-between; align-items: center; }
        summary::-webkit-details-marker { display: none; }
        summary:after { content: "+"; color: #888; font-weight: bold; }
        details[open] summary:after { content: "-"; }
        details p { margin-top: 10px; margin-bottom: 0; color: #ccc; font-size: 0.9rem; line-height: 1.5; }
        details ul { margin: 5px 0 0 20px; padding: 0; color: #ccc; font-size: 0.85rem; }
        details li { margin-bottom: 4px; }

        /* COMMON */
        .pred-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 8px; margin-top: 10px; }
        .pred-text { color: var(--green); font-weight: bold; font-size: 0.9rem; }
        .conf-badge { padding: 4px 8px; border-radius: 6px; font-size: 0.8rem; font-weight: bold; color: #000; }
        .conf-high { background-color: var(--green); } .conf-med { background-color: var(--gold); } .conf-low { background-color: #8b949e; }
        .upset-badge { background: rgba(218, 54, 51, 0.15); border: 1px solid var(--red); color: var(--red); font-size: 0.75rem; font-weight: bold; text-align: center; padding: 6px; border-radius: 6px; margin-top: 8px; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .red-card-badge { background: rgba(218, 54, 51, 0.2); border: 1px solid var(--red); color: white; font-weight: bold; font-size: 0.75rem; padding: 2px 6px; border-radius: 4px; margin-top: 4px; display: inline-block; }
    </style>
</head>
<body>

    <header>
        <div class="top-row">
            <h1><img src="target_PNG26.png" style="width:28px;"> The Final Third</h1>
            <div class="header-right">
                <div id="apiCounter" class="api-badge">API: 0</div>
                <button class="help-btn" onclick="openHelp()">?</button>
            </div>
        </div>
        
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <button id="pilotBtn" class="pilot-btn" onclick="togglePilot()">
                <div class="pilot-dot"></div> Auto-Pilot
            </button>
            <button id="notifBtn" class="notif-btn" onclick="toggleNotifications()" title="Notifications Off">üîï</button>
        </div>
        
        <div class="nav-tabs">
            <div id="tabLive" class="nav-tab active" onclick="switchTab('live')">üî¥ Live Hunt</div>
            <div id="tabCards" class="nav-tab" onclick="switchTab('cards')">üü® Card Watch</div>
            <div id="tabChallenge" class="nav-tab" onclick="switchTab('challenge')">üí∑ Challenge</div>
            <div id="tabSched" class="nav-tab" onclick="switchTab('sched')">üìÖ Elite Schedule</div>
            <div id="tabAcc" class="nav-tab" onclick="switchTab('acc')">üí∞ Acca Tips</div>
            <div id="tab2hg" class="nav-tab" onclick="switchTab('2hg')">‚öΩ 2nd Half Goal</div>
            <div id="tabBotd" class="nav-tab" onclick="switchTab('botd')">üèÜ Bet of the Day</div>
            <div id="tabStats" class="nav-tab" onclick="switchTab('stats')">üìà Stats</div>
            <div id="tabHist" class="nav-tab" onclick="switchTab('hist')">üìú History</div>
        </div>

        <select id="filterSelect" onchange="applyFilter()">
            <option value="full">üìä Full Analysis</option>
            <option value="limited">‚ö†Ô∏è Limited Data</option>
        </select>
    </header>

        <div id="liveView">
        <div class="chip-container">
            <div class="chip" onclick="setStrategy('challenge', this)" style="background:linear-gradient(135deg, rgba(210,153,34,0.15), rgba(46,160,67,0.1)); border-color:var(--gold);">üéØ Challenge Picks <span id="badge-challenge" class="chip-badge" style="display:none;">0</span></div>
            <div class="chip active" onclick="setStrategy('all', this)">üåç All Games <span id="badge-all" class="chip-badge">0</span></div>
            <div class="chip" onclick="setStrategy('drought', this)">‚è≥ Goal Drought <span id="badge-drought" class="chip-badge">0</span></div>
            <div class="chip" onclick="setStrategy('alert', this)">üî• Goal Alert! <span id="badge-alert" class="chip-badge">0</span></div>
            <div class="chip" onclick="setStrategy('red', this)">üü• Red Card <span id="badge-red" class="chip-badge">0</span></div>
        </div>

        <div class="conf-slider-container" style="background:var(--card); border:1px solid #30363d; border-radius:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:0.75rem; color:#888;">Min Confidence</span>
                <span id="confThresholdLabel" style="font-size:0.85rem; font-weight:bold; color:var(--green);">75%</span>
            </div>
            <input type="range" class="conf-slider" id="confThreshold" min="50" max="95" value="75" step="5" oninput="updateConfThreshold(this.value)">
            <div style="display:flex; justify-content:space-between; font-size:0.6rem; color:#555;"><span>50%</span><span>Riskier</span><span>Safer</span><span>95%</span></div>
        </div>

        <div id="content" style="padding-bottom:80px;">
            <div style="text-align:center; padding-top:50px; color:#888;">
                <p style="font-size:2rem; margin-bottom:10px;">üî≠</p>
                <p>Ready to Hunt (60'-85').</p>
                <p style="font-size:0.8rem; color:#555">Active: xG ‚Ä¢ Bet365 ‚Ä¢ Standings ‚Ä¢ Pulse</p>
            </div>
        </div>
        <button class="scan-btn" onclick="runScan()" id="mainBtn">üéØ SCAN MARKETS</button>
    </div>

    <div id="schedView" style="display:none;">
        <div id="schedContent" style="padding-bottom:100px;"></div>
    </div>

    <div id="cardView" style="display:none;">
        <div style="display:flex; gap:10px; margin-bottom:15px;">
            <button class="card-scan-btn" style="margin-bottom:0; flex:1;" onclick="scanGlobalCards(this)">‚ö†Ô∏è SCAN GLOBAL CARD RISKS</button>
            <button id="cardPilotBtn" class="pilot-btn" style="padding:10px 15px; border-radius:8px;" onclick="toggleCardPilot()">
                <div class="pilot-dot"></div> Auto-Pilot (30s)
            </button>
        </div>
        <div id="cardContent" style="padding-bottom:100px; text-align:center; color:#888;">Click above to find high-risk players across Elite live games.</div>
    </div>

    <div id="histView" style="display:none;">
        <div id="histContent" style="padding-bottom:100px;"></div>
    </div>

    <div id="statsView" style="display:none;">
        <div id="statsContent" style="padding-bottom:100px;"></div>
    </div>

    <div id="secondHalfGoalView" style="display:none;">
        <div style="text-align:center; margin-bottom:15px;">
            <h2 style="color:var(--green); margin:0 0 4px 0;">‚öΩ 2nd Half Goal Predictor</h2>
            <p style="color:#888; font-size:0.78rem; margin:0;">Live matches in the 2nd half ‚Äî AI confidence ratings for another goal</p>
        </div>
        <button class="card-scan-btn" style="background:var(--green); color:#000; margin-bottom:15px;" onclick="scan2ndHalfGoals(this)">‚öΩ SCAN 2ND HALF MATCHES</button>
        <div id="secondHalfGoalContent" style="padding-bottom:100px; text-align:center; color:#888;">Click above to scan all live 2nd half matches for goal probability.</div>
    </div>

    <div id="botdView" style="display:none;">
        <div style="text-align:center; margin-bottom:15px;">
            <h2 style="color:var(--gold); margin:0 0 4px 0;">üèÜ Bet of the Day</h2>
            <p style="color:#888; font-size:0.78rem; margin:0;">One standout pick from each major league ‚Äî the best bet today</p>
        </div>
        <button class="card-scan-btn" style="background:var(--gold); color:#000; margin-bottom:15px;" onclick="scanBetOfTheDay(this)">üèÜ FIND TODAY'S BEST BETS</button>
        <div id="botdContent" style="padding-bottom:100px; text-align:center; color:#888;">Click above to analyze today's fixtures across Europe's top leagues.</div>
    </div>

    <div id="accView" style="display:none;">
        <div style="background:var(--card); border:1px solid #30363d; border-radius:10px; padding:12px; margin:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <span style="font-size:0.85rem; font-weight:bold; color:var(--gold);">‚öôÔ∏è Acca Filters</span>
                <button onclick="toggleAccaFilters()" id="accaFilterToggle" style="background:none; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:6px; font-size:0.7rem; cursor:pointer;">Show ‚ñº</button>
            </div>
            <div id="accaFilterPanel" style="display:none;">
                <div style="margin-bottom:10px;">
                    <div style="font-size:0.75rem; color:#aaa; margin-bottom:5px;">Leagues</div>
                    <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:4px;">
                        <button onclick="accaSetLeaguePreset('all')" class="acca-league-preset active" data-preset="all" style="background:rgba(56,139,253,0.15); border:1px solid var(--blue); color:var(--blue); padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer; font-weight:bold;">All Leagues</button>
                        <button onclick="accaSetLeaguePreset('elite')" class="acca-league-preset" data-preset="elite" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">Elite Only</button>
                        <button onclick="accaSetLeaguePreset('custom')" class="acca-league-preset" data-preset="custom" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">Custom</button>
                    </div>
                    <div id="accaLeagueCustom" style="display:none; margin-top:6px;">
                        <div id="accaLeagueList" style="max-height:150px; overflow-y:auto; background:rgba(0,0,0,0.2); border-radius:6px; padding:6px;"></div>
                        <div style="font-size:0.6rem; color:#555; margin-top:3px;">Leagues populate after first scan</div>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <div style="font-size:0.75rem; color:#aaa; margin-bottom:5px;">Kick-off Window</div>
                    <div style="display:flex; gap:6px; align-items:center;">
                        <input type="time" id="accaTimeFrom" value="00:00" style="background:#21262d; border:1px solid #30363d; color:#ccc; padding:4px 8px; border-radius:6px; font-size:0.75rem;">
                        <span style="color:#888; font-size:0.75rem;">to</span>
                        <input type="time" id="accaTimeTo" value="23:59" style="background:#21262d; border:1px solid #30363d; color:#ccc; padding:4px 8px; border-radius:6px; font-size:0.75rem;">
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <div style="font-size:0.75rem; color:#aaa; margin-bottom:5px;">Markets</div>
                    <div style="display:flex; gap:4px; flex-wrap:wrap;">
                        <label style="display:flex; align-items:center; gap:3px; background:#21262d; border:1px solid #30363d; padding:4px 8px; border-radius:6px; font-size:0.7rem; color:#ccc; cursor:pointer;"><input type="checkbox" class="acca-market-cb" value="Over 1.5 Goals" checked> Over 1.5</label>
                        <label style="display:flex; align-items:center; gap:3px; background:#21262d; border:1px solid #30363d; padding:4px 8px; border-radius:6px; font-size:0.7rem; color:#ccc; cursor:pointer;"><input type="checkbox" class="acca-market-cb" value="Over 2.5 Goals" checked> Over 2.5</label>
                        <label style="display:flex; align-items:center; gap:3px; background:#21262d; border:1px solid #30363d; padding:4px 8px; border-radius:6px; font-size:0.7rem; color:#ccc; cursor:pointer;"><input type="checkbox" class="acca-market-cb" value="BTTS" checked> BTTS</label>
                        <label style="display:flex; align-items:center; gap:3px; background:#21262d; border:1px solid #30363d; padding:4px 8px; border-radius:6px; font-size:0.7rem; color:#ccc; cursor:pointer;"><input type="checkbox" class="acca-market-cb" value="Home Win" checked> Home Win</label>
                        <label style="display:flex; align-items:center; gap:3px; background:#21262d; border:1px solid #30363d; padding:4px 8px; border-radius:6px; font-size:0.7rem; color:#ccc; cursor:pointer;"><input type="checkbox" class="acca-market-cb" value="Away Win" checked> Away Win</label>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:0.75rem; color:#aaa;">Acca Size</span>
                        <span style="font-size:0.75rem; color:var(--gold); font-weight:bold;" id="accaSizeLabel">Auto</span>
                    </div>
                    <div style="display:flex; gap:4px; margin-top:5px; flex-wrap:wrap;">
                        <button onclick="setAccaSize('auto')" class="acca-size-btn active" data-size="auto" style="background:rgba(56,139,253,0.15); border:1px solid var(--blue); color:var(--blue); padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer; font-weight:bold;">Auto</button>
                        <button onclick="setAccaSize(2)" class="acca-size-btn" data-size="2" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">2-fold</button>
                        <button onclick="setAccaSize(3)" class="acca-size-btn" data-size="3" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">3-fold</button>
                        <button onclick="setAccaSize(4)" class="acca-size-btn" data-size="4" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">4-fold</button>
                        <button onclick="setAccaSize(5)" class="acca-size-btn" data-size="5" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">5-fold</button>
                        <button onclick="setAccaSize(6)" class="acca-size-btn" data-size="6" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">6-fold</button>
                    </div>
                </div>
                <div style="margin-bottom:6px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:0.75rem; color:#aaa;">Target Odds</span>
                        <span style="font-size:0.75rem; color:var(--gold); font-weight:bold;" id="accaTargetLabel">Any</span>
                    </div>
                    <div style="display:flex; gap:4px; margin-top:5px; flex-wrap:wrap;">
                        <button onclick="setAccaTarget(0)" class="acca-target-btn active" data-target="0" style="background:rgba(56,139,253,0.15); border:1px solid var(--blue); color:var(--blue); padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer; font-weight:bold;">Any</button>
                        <button onclick="setAccaTarget(3)" class="acca-target-btn" data-target="3" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">3+</button>
                        <button onclick="setAccaTarget(5)" class="acca-target-btn" data-target="5" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">5+</button>
                        <button onclick="setAccaTarget(10)" class="acca-target-btn" data-target="10" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">10+</button>
                        <button onclick="setAccaTarget(20)" class="acca-target-btn" data-target="20" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">20+</button>
                        <button onclick="setAccaTarget(50)" class="acca-target-btn" data-target="50" style="background:#21262d; border:1px solid #30363d; color:#888; padding:3px 10px; border-radius:12px; font-size:0.68rem; cursor:pointer;">50+</button>
                    </div>
                </div>
            </div>
        </div>
        <button class="card-scan-btn" style="background:var(--gold); color:#000;" onclick="generateAccas(this)">üíé GENERATE ACCUMULATORS</button>
        <div id="accContent" style="padding-bottom:100px;">
            <div style="text-align:center; color:#888; padding:20px;">
                <p>Configure your filters and generate data-driven accumulators.</p>
            </div>
        </div>
    </div>

    <div id="challengeView" style="display:none;">
        <div id="challengeHeader" style="text-align:center; margin-bottom:20px;">
            <div style="font-size:2rem; margin-bottom:10px;">üí∑</div>
            <h2 style="color:var(--gold); margin:0;">¬£5 ‚Üí ¬£500 Challenge</h2>
            <p style="color:#888; font-size:0.85rem; margin-top:5px;">Compound your way to ¬£500 with AI-powered in-play picks</p>
        </div>
        
        <div id="challengeStatus" style="background:var(--card); border:1px solid #30363d; border-radius:12px; padding:20px; margin-bottom:20px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <div>
                    <div style="font-size:0.75rem; color:#888; text-transform:uppercase;">Current Stake</div>
                    <div id="currentStake" style="font-size:2rem; font-weight:bold; color:var(--green);">¬£5.00</div>
                </div>
                <div style="text-align:right;">
                    <div style="font-size:0.75rem; color:#888; text-transform:uppercase;">Target</div>
                    <div style="font-size:1.5rem; font-weight:bold; color:var(--gold);">¬£500.00</div>
                </div>
            </div>
            <div style="background:#333; border-radius:8px; height:12px; overflow:hidden;">
                <div id="challengeProgress" style="background:linear-gradient(90deg, var(--green), var(--gold)); height:100%; width:1%; transition:width 0.5s;"></div>
            </div>
            <div style="display:flex; justify-content:space-between; font-size:0.75rem; color:#888; margin-top:5px;">
                <span>¬£5</span>
                <span id="progressPercent">1%</span>
                <span>¬£500</span>
            </div>
            <div class="milestone-track" id="milestoneTrack"></div>
        </div>
        
        <div id="challengeContent" style="padding-bottom:100px;">
            <div id="challengeStartScreen" style="text-align:center; padding:30px 20px;">
                <div style="font-size:3rem; margin-bottom:15px;">üéØ</div>
                <h3 style="color:white; margin-bottom:10px;">Ready to Start?</h3>
                <p style="color:#888; font-size:0.9rem; margin-bottom:20px;">The AI will find the safest in-play bet from Elite matches. Win and compound until you hit ¬£500!</p>
                <button onclick="startChallenge()" style="background:var(--green); color:white; border:none; padding:16px 40px; border-radius:12px; font-size:1.1rem; font-weight:bold; cursor:pointer; box-shadow:0 4px 15px rgba(46, 160, 67, 0.4);">üöÄ START CHALLENGE</button>
            </div>
            
            <div id="challengeActiveScreen" style="display:none;">
                <button onclick="findNextBet(this)" class="card-scan-btn" style="background:var(--blue);">üîç FIND NEXT BET</button>
                
                <div id="suggestedBet" style="display:none; background:var(--card); border:2px solid var(--green); border-radius:12px; padding:20px; margin-bottom:20px;">
                    <div style="font-size:0.75rem; color:#888; text-transform:uppercase; margin-bottom:10px;">AI Suggested Bet</div>
                    <div id="betMatch" style="font-weight:bold; font-size:1.1rem; color:white; margin-bottom:5px;"></div>
                    <div id="betLeague" style="font-size:0.8rem; color:var(--purple); margin-bottom:10px;"></div>
                    <div id="betSelection" style="background:rgba(46, 160, 67, 0.15); border:1px solid var(--green); border-radius:8px; padding:12px; margin-bottom:15px;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span id="betType" style="font-weight:bold; color:var(--green); font-size:1rem;"></span>
                            <span id="betOdds" style="font-family:monospace; font-weight:bold; color:var(--gold); font-size:1.2rem;"></span>
                        </div>
                    </div>
                    <div id="betReasoning" style="font-size:0.85rem; color:#aaa; border-left:3px solid var(--blue); padding-left:10px; margin-bottom:15px;"></div>
                    <div style="display:flex; justify-content:space-between; font-size:0.85rem; margin-bottom:15px;">
                        <span style="color:#888;">Stake: <span id="betStake" style="color:white; font-weight:bold;"></span></span>
                        <span style="color:#888;">Potential Return: <span id="betReturn" style="color:var(--green); font-weight:bold;"></span></span>
                    </div>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <button onclick="markBetResult('won')" style="flex:1; background:var(--green); color:white; border:none; padding:14px; border-radius:8px; font-weight:bold; font-size:1rem; cursor:pointer;">‚úÖ WON</button>
                        <button onclick="markBetResult('lost')" style="flex:1; background:var(--red); color:white; border:none; padding:14px; border-radius:8px; font-weight:bold; font-size:1rem; cursor:pointer;">‚ùå LOST</button>
                    </div>
                    <button onclick="rejectAndFindNew(this)" style="width:100%; background:#333; color:#888; border:1px solid #444; padding:12px; border-radius:8px; font-size:0.9rem; cursor:pointer;">üîÑ Find Different Match</button>
                </div>
            </div>
            
            <div id="challengeLostScreen" style="display:none; text-align:center; padding:30px 20px;">
                <div style="font-size:3rem; margin-bottom:15px;">üòî</div>
                <h3 style="color:var(--red); margin-bottom:10px;">Challenge Failed</h3>
                <p style="color:#888; font-size:0.9rem; margin-bottom:10px;">You reached <span id="lostAmount" style="color:var(--gold); font-weight:bold;">¬£0.00</span> before the loss.</p>
                <p id="nextChallengeTime" style="color:#888; font-size:0.85rem; margin-bottom:20px;"></p>
                <button id="restartBtn" onclick="resetChallenge()" style="background:#333; color:#888; border:1px solid #444; padding:14px 30px; border-radius:8px; font-weight:bold; cursor:not-allowed;" disabled>üîí NEW CHALLENGE TOMORROW</button>
            </div>
            
            <div id="challengeWonScreen" style="display:none; text-align:center; padding:30px 20px;">
                <div style="font-size:3rem; margin-bottom:15px;">üéâ</div>
                <h3 style="color:var(--green); margin-bottom:10px;">CHALLENGE COMPLETE!</h3>
                <p style="color:#888; font-size:0.9rem; margin-bottom:10px;">You turned ¬£5 into <span id="finalAmount" style="color:var(--gold); font-weight:bold; font-size:1.2rem;">¬£500+</span></p>
                <p style="color:var(--green); font-size:0.85rem; margin-bottom:20px;">üèÜ Incredible run!</p>
                <button onclick="resetChallenge(true)" style="background:var(--gold); color:#000; border:none; padding:14px 30px; border-radius:8px; font-weight:bold; cursor:pointer;">üîÑ START NEW CHALLENGE</button>
            </div>
        </div>
        
        <div style="margin-top:20px;">
            <div style="font-size:0.85rem; color:#888; text-transform:uppercase; margin-bottom:10px;">üìú Bet History</div>
            <div id="challengeHistory" style="background:var(--card); border:1px solid #30363d; border-radius:8px; max-height:300px; overflow-y:auto;"></div>
        </div>
    </div>

    <div id="helpModal" class="modal" onclick="closeHelp(event)">
        <div class="modal-content">
            <h2>üîé User Manual</h2>
            
            <details open>
                <summary>üî¥ Live Hunt & Auto-Pilot</summary>
                <p>The core dashboard for <b>Live Betting</b>. It monitors matches in the <b>"Goldilocks Zone" (60-85 mins)</b> where statistics are mature and trends are most reliable for late-game outcomes.</p>
                <p><b>Auto-Pilot:</b> When active, the system scans every <b>2.5 minutes</b>. It automatically analyzes all games and plays an alert sound when a high-value "Siege" situation is detected.</p>
            </details>

            <details>
                <summary>üéØ Sniper Strategy Filters</summary>
                <p>Use the chips to isolate specific betting opportunities:</p>
                <ul>
                    <li><b>üåç All Games:</b> Complete list of active fixtures in the 60-85 min window.</li>
                    <li><b>‚è≥ Goal Drought:</b> Matches that haven't seen a goal in over 50 minutes (requires at least one goal to have been scored earlier).</li>
                    <li><b>üî• Goal Alert!:</b> High-pressure games showing "SIEGE" indicators, momentum pulses, or "6-Pointer" table tension.</li>
                    <li><b>üü• Red Card:</b> Isolates matches where at least one team is playing with 10 men, creating space for late drama.</li>
                </ul>
            </details>

            <details>
                <summary>üìä Match Cards & AI Analysis</summary>
                <p><b>Pressure Pulse:</b> A glowing <b>Green</b> (Home) or <b>Purple</b> (Away) border indicates extreme momentum (>70% pressure).</p>
                <p><b>6-POINTER:</b> High-stakes alert when teams are within 3 positions of each other in the league table.</p>
                <p><b>H2H (Last 5):</b> Shows the win/draw/loss distribution of the last 5 encounters between the two teams.</p>
                <p><b>[SYNTH]:</b> A <b>Yellow</b> border indicates synthetic data. When official match stats are delayed, the app aggregates individual player actions to rebuild the pressure gauge.</p>
            </details>

            <details>
                <summary>üïµÔ∏è Player Discipline & Card Watch</summary>
                <p>The <b>Card Watch</b> tab scans all <b>Elite</b> matches for specific player behaviors:</p>
                <ul>
                    <li><b>Target Search:</b> Finds players with <b>2+ Fouls</b> who have <b>0 Cards</b>.</li>
                    <li><b>Position Badges:</b> Displays player positions (DEF, MID, ATT) to identify those in high-traffic zones.</li>
                    <li><b>üëÆ Strict Ref:</b> Live calculation of the referee's "Card per Foul" ratio. <b>Strict</b> refs (>0.25) are highlighted in red.</li>
                </ul>
            </details>

            <details>
                <summary>üìÖ Elite Schedule & History</summary>
                <p><b>Elite Schedule:</b> A curated list of upcoming matches from the world's top leagues (PL, La Liga, UCL, etc.) for the next 24 hours.</p>
                <p><b>History:</b> Tracks your "Marked" bets. It automatically detects outcomes (Win/Loss) once matches finish to help track your daily ROI.</p>
            </details>

            <details>
                <summary>üí° Icon & Status Glossary</summary>
                <ul>
                    <li>üî• <b>SIEGE:</b> Sustained attacking pressure in the final third.</li>
                    <li>üìà/üìâ <b>Momentum:</b> Real-time trend showing if pressure is rising or falling.</li>
                    <li>üîÑ <b>Refresh:</b> Tap the league header to force-update a specific match's data.</li>
                    <li>‚úÖ <b>Mark:</b> Use the checkmark to track a game in your History.</li>
                </ul>
            </details>

            <button class="close-modal" onclick="document.getElementById('helpModal').style.display='none'">Close Manual</button>
        </div>
    </div>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(reg => {
                    console.log('SW Registered');
                }).catch(err => {
                    console.log('SW Registration Failed', err);
                });
                const nb = document.getElementById('notifBtn');
                if (nb && localStorage.getItem('tft_notifications') === 'true' && 'Notification' in window && Notification.permission === 'granted') {
                    nb.classList.add('notif-on');
                    nb.innerHTML = 'üîî';
                    nb.title = 'Notifications On';
                }
            });
        }

        const API_KEY = "0f29a2f96e9dd4231cee515cc5ec52b0"; 
        
        // ELITE IDS
        const ELITE_IDS = [39, 40, 45, 48, 179, 180, 140, 78, 135, 61, 88, 94, 144, 2, 3, 529, 556, 81, 143, 307, 253, 137, 188];
        const EU_COUNTRIES = ["Albania", "Andorra", "Armenia", "Austria", "Azerbaijan", "Belarus", "Belgium", "Bosnia", "Bulgaria", "Croatia", "Cyprus", "Czech Republic", "Czech-Republic", "Denmark", "England", "Estonia", "Faroe Islands", "Finland", "France", "Georgia", "Germany", "Gibraltar", "Greece", "Hungary", "Iceland", "Ireland", "Israel", "Italy", "Kazakhstan", "Kosovo", "Latvia", "Liechtenstein", "Lithuania", "Luxembourg", "Malta", "Moldova", "Montenegro", "Netherlands", "Northern Ireland", "North Macedonia", "Norway", "Poland", "Portugal", "Romania", "Russia", "San Marino", "Scotland", "Serbia", "Slovakia", "Slovenia", "Spain", "Sweden", "Switzerland", "Ukraine", "Wales"];

        let allMatches = [];
        let matchStatsMap = {};
        let pilotMode = false;
        let pilotInterval;
        let cardPilotInterval;
        let alertedGames = new Set();
        let currentStrategy = 'all';
        let momentumHistory = {};
        let accaTipPool = [];
        let accaDiscarded = [];
        let accaCurrentPicks = [];
        let accaBigOddsPicks = [];
        let accaBigOddsDiscarded = [];
        let accaAnalyzedCount = 0;
        let accaLeagueCount = 0;
        let accaFilterLeague = 'all';
        let accaFilterCustomLeagues = [];
        let accaFilterSize = 'auto';
        let accaFilterTarget = 0;
        let accaAvailableLeagues = []; 
        let teamFoulTracker = {};
        let challengeAutoRefreshInterval = null;
        let challengeScanLock = false;
        let liveOddsCache = {};
        let standingsCache = {};
        let teamFormCache = {};
        
        // UNLOCKED
        let isPremium = true; 
        
        const content = document.getElementById('content');
        const mainBtn = document.getElementById('mainBtn');
        const pilotBtn = document.getElementById('pilotBtn');
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // =============================================
        // ANALYTICS ENGINE v2 - SMART PREDICTION SYSTEM
        // =============================================

        const LEAGUE_PROFILES = {
            39: { name: "Premier League", lateGoalRate: 0.34, avgGoals: 2.85, tempo: "high" },
            40: { name: "Championship", lateGoalRate: 0.30, avgGoals: 2.65, tempo: "high" },
            45: { name: "FA Cup", lateGoalRate: 0.32, avgGoals: 2.70, tempo: "high" },
            48: { name: "League Cup", lateGoalRate: 0.31, avgGoals: 2.75, tempo: "high" },
            61: { name: "Ligue 1", lateGoalRate: 0.28, avgGoals: 2.60, tempo: "medium" },
            78: { name: "Bundesliga", lateGoalRate: 0.33, avgGoals: 3.10, tempo: "high" },
            88: { name: "Eredivisie", lateGoalRate: 0.35, avgGoals: 3.20, tempo: "high" },
            94: { name: "Primeira Liga", lateGoalRate: 0.29, avgGoals: 2.50, tempo: "medium" },
            135: { name: "Serie A", lateGoalRate: 0.26, avgGoals: 2.55, tempo: "low" },
            137: { name: "Coppa Italia", lateGoalRate: 0.28, avgGoals: 2.45, tempo: "low" },
            140: { name: "La Liga", lateGoalRate: 0.29, avgGoals: 2.65, tempo: "medium" },
            143: { name: "Copa del Rey", lateGoalRate: 0.30, avgGoals: 2.70, tempo: "medium" },
            144: { name: "Jupiler Pro", lateGoalRate: 0.31, avgGoals: 2.80, tempo: "medium" },
            179: { name: "SPL", lateGoalRate: 0.32, avgGoals: 2.75, tempo: "high" },
            180: { name: "Scottish Cup", lateGoalRate: 0.33, avgGoals: 2.80, tempo: "high" },
            188: { name: "A-League", lateGoalRate: 0.33, avgGoals: 2.90, tempo: "high" },
            253: { name: "MLS", lateGoalRate: 0.34, avgGoals: 3.00, tempo: "high" },
            307: { name: "Saudi Pro", lateGoalRate: 0.30, avgGoals: 2.70, tempo: "medium" },
            529: { name: "DFB Pokal", lateGoalRate: 0.34, avgGoals: 3.05, tempo: "high" },
            556: { name: "Super Lig", lateGoalRate: 0.29, avgGoals: 2.65, tempo: "medium" },
            2: { name: "Champions League", lateGoalRate: 0.31, avgGoals: 2.95, tempo: "high" },
            3: { name: "Europa League", lateGoalRate: 0.30, avgGoals: 2.80, tempo: "medium" },
            81: { name: "DFB Pokal", lateGoalRate: 0.33, avgGoals: 3.00, tempo: "high" }
        };
        const DEFAULT_LEAGUE = { name: "Unknown", lateGoalRate: 0.28, avgGoals: 2.50, tempo: "medium" };

        const SCORE_STATE_MAP = {
            "0-0": { goalProb: 0.72, overProb: 0.68, bttsProb: 0.45, desc: "Deadlock - pressure mounts late" },
            "1-0": { goalProb: 0.65, overProb: 0.80, bttsProb: 0.52, desc: "Trailing team pushes forward" },
            "0-1": { goalProb: 0.67, overProb: 0.82, bttsProb: 0.55, desc: "Home crowd drives comeback" },
            "1-1": { goalProb: 0.58, overProb: 0.75, bttsProb: 0.90, desc: "Both teams chasing winner" },
            "2-0": { goalProb: 0.48, overProb: 0.92, bttsProb: 0.38, desc: "Comfortable lead, may ease off" },
            "0-2": { goalProb: 0.52, overProb: 0.94, bttsProb: 0.42, desc: "Home desperation attacks" },
            "2-1": { goalProb: 0.62, overProb: 0.95, bttsProb: 0.92, desc: "Open game, more goals likely" },
            "1-2": { goalProb: 0.64, overProb: 0.96, bttsProb: 0.93, desc: "Home pushing for equalizer" },
            "2-2": { goalProb: 0.55, overProb: 0.98, bttsProb: 0.98, desc: "Wide open, anyone's game" },
            "3-0": { goalProb: 0.35, overProb: 0.98, bttsProb: 0.30, desc: "Game over, low intensity" },
            "0-3": { goalProb: 0.38, overProb: 0.99, bttsProb: 0.32, desc: "Capitulation, low intensity" },
            "3-1": { goalProb: 0.45, overProb: 0.99, bttsProb: 0.85, desc: "Still lively but decided" },
            "1-3": { goalProb: 0.47, overProb: 0.99, bttsProb: 0.87, desc: "Home pride, away comfort" }
        };
        const DEFAULT_SCORE_STATE = { goalProb: 0.50, overProb: 0.70, bttsProb: 0.50, desc: "Unpredictable match state" };

        const REFEREE_PROFILES = {
            "M. Oliver": { avgCards: 4.2, strictness: "strict", avgFouls: 22, cardRate: 0.28 },
            "A. Taylor": { avgCards: 4.5, strictness: "strict", avgFouls: 24, cardRate: 0.30 },
            "S. Hooper": { avgCards: 3.8, strictness: "strict", avgFouls: 22, cardRate: 0.26 },
            "P. Tierney": { avgCards: 4.1, strictness: "strict", avgFouls: 23, cardRate: 0.27 },
            "C. Pawson": { avgCards: 3.5, strictness: "moderate", avgFouls: 21, cardRate: 0.22 },
            "R. Jones": { avgCards: 3.3, strictness: "moderate", avgFouls: 20, cardRate: 0.21 },
            "D. Coote": { avgCards: 3.9, strictness: "strict", avgFouls: 22, cardRate: 0.25 },
            "J. Brooks": { avgCards: 3.1, strictness: "lenient", avgFouls: 19, cardRate: 0.18 },
            "S. Attwell": { avgCards: 3.6, strictness: "moderate", avgFouls: 21, cardRate: 0.23 },
            "T. Bramall": { avgCards: 3.4, strictness: "moderate", avgFouls: 20, cardRate: 0.22 },
            "A. Madley": { avgCards: 3.2, strictness: "moderate", avgFouls: 20, cardRate: 0.20 },
            "J. Smith": { avgCards: 3.0, strictness: "lenient", avgFouls: 18, cardRate: 0.17 },
            "D. England": { avgCards: 3.7, strictness: "moderate", avgFouls: 21, cardRate: 0.24 },
            "M. Salisbury": { avgCards: 3.4, strictness: "moderate", avgFouls: 20, cardRate: 0.22 },
            "C. Kavanagh": { avgCards: 3.9, strictness: "strict", avgFouls: 22, cardRate: 0.26 },
            "G. Scott": { avgCards: 3.3, strictness: "moderate", avgFouls: 20, cardRate: 0.21 },
            "J. Gillett": { avgCards: 3.6, strictness: "moderate", avgFouls: 21, cardRate: 0.23 },
            "C. del Cerro Grande": { avgCards: 5.2, strictness: "strict", avgFouls: 26, cardRate: 0.32 },
            "J. Gil Manzano": { avgCards: 5.0, strictness: "strict", avgFouls: 25, cardRate: 0.30 },
            "M. Lahoz": { avgCards: 5.5, strictness: "strict", avgFouls: 28, cardRate: 0.34 },
            "A. Hernandez": { avgCards: 4.8, strictness: "strict", avgFouls: 24, cardRate: 0.28 },
            "J. Sanchez Martinez": { avgCards: 4.6, strictness: "strict", avgFouls: 24, cardRate: 0.27 },
            "D. Orsato": { avgCards: 4.0, strictness: "strict", avgFouls: 22, cardRate: 0.26 },
            "M. Guida": { avgCards: 4.3, strictness: "strict", avgFouls: 23, cardRate: 0.28 },
            "G. Doveri": { avgCards: 4.1, strictness: "strict", avgFouls: 22, cardRate: 0.27 },
            "D. Massa": { avgCards: 3.8, strictness: "moderate", avgFouls: 21, cardRate: 0.24 },
            "L. Pairetto": { avgCards: 4.2, strictness: "strict", avgFouls: 23, cardRate: 0.27 },
            "F. Brych": { avgCards: 3.4, strictness: "moderate", avgFouls: 20, cardRate: 0.21 },
            "D. Aytekin": { avgCards: 3.6, strictness: "moderate", avgFouls: 21, cardRate: 0.23 },
            "D. Siebert": { avgCards: 3.8, strictness: "moderate", avgFouls: 22, cardRate: 0.24 },
            "S. Stegemann": { avgCards: 3.5, strictness: "moderate", avgFouls: 20, cardRate: 0.22 },
            "C. Turpin": { avgCards: 4.0, strictness: "strict", avgFouls: 23, cardRate: 0.26 },
            "F. Letexier": { avgCards: 3.7, strictness: "moderate", avgFouls: 21, cardRate: 0.24 },
            "B. Bastien": { avgCards: 4.1, strictness: "strict", avgFouls: 23, cardRate: 0.27 },
            "S. Marciniak": { avgCards: 3.9, strictness: "strict", avgFouls: 22, cardRate: 0.26 },
            "S. Vincic": { avgCards: 3.5, strictness: "moderate", avgFouls: 20, cardRate: 0.22 },
            "I. Kovacs": { avgCards: 4.0, strictness: "strict", avgFouls: 23, cardRate: 0.26 },
            "A. Dias": { avgCards: 4.3, strictness: "strict", avgFouls: 24, cardRate: 0.28 },
            "D. Makkelie": { avgCards: 3.3, strictness: "moderate", avgFouls: 19, cardRate: 0.20 },
            "S. Jablonski": { avgCards: 3.7, strictness: "moderate", avgFouls: 21, cardRate: 0.24 },
            "T. Stieler": { avgCards: 3.9, strictness: "strict", avgFouls: 22, cardRate: 0.25 },
            "B. Kuipers": { avgCards: 3.2, strictness: "lenient", avgFouls: 19, cardRate: 0.19 }
        };

        function getRefProfile(refString) {
            if (!refString) return null;
            const refName = refString.split(',')[0].trim();
            const lastName = refName.split(' ').pop();
            for (const [key, profile] of Object.entries(REFEREE_PROFILES)) {
                if (key.includes(lastName) || refName.includes(key.split(' ').pop())) {
                    return { ...profile, name: key, matched: true };
                }
            }
            const learned = getLearnedRefProfile(refName);
            if (learned) return learned;
            return null;
        }

        function getLearnedRefProfile(refName) {
            try {
                const db = JSON.parse(localStorage.getItem('refProfileDB') || '{}');
                if (db[refName] && db[refName].matches >= 2) {
                    const avg = db[refName].totalCards / db[refName].matches;
                    return {
                        name: refName,
                        avgCards: avg,
                        strictness: avg >= 4.5 ? "strict" : (avg <= 2.5 ? "lenient" : "moderate"),
                        avgFouls: db[refName].totalFouls / db[refName].matches,
                        cardRate: db[refName].totalCards / Math.max(1, db[refName].totalFouls),
                        learned: true,
                        matches: db[refName].matches
                    };
                }
            } catch(e) {}
            return null;
        }

        function learnRefProfile(refName, cards, fouls) {
            if (!refName) return;
            try {
                const db = JSON.parse(localStorage.getItem('refProfileDB') || '{}');
                if (!db[refName]) db[refName] = { totalCards: 0, totalFouls: 0, matches: 0, lastSeen: 0 };
                const now = Date.now();
                if (now - db[refName].lastSeen < 3600000) return;
                db[refName].totalCards += cards;
                db[refName].totalFouls += fouls;
                db[refName].matches++;
                db[refName].lastSeen = now;
                const keys = Object.keys(db);
                if (keys.length > 200) {
                    keys.sort((a, b) => db[a].lastSeen - db[b].lastSeen);
                    keys.slice(0, keys.length - 200).forEach(k => delete db[k]);
                }
                localStorage.setItem('refProfileDB', JSON.stringify(db));
            } catch(e) {}
        }

        // =============================================
        // ANALYTICS v3 - FORM, DEFENSE, xG, PATTERNS
        // =============================================

        function getTeamFormData(teamId, leagueId) {
            const key = `form_${teamId}`;
            try {
                const cached = JSON.parse(localStorage.getItem(key));
                if (cached && (Date.now() - cached.ts) < 86400000) return cached.data;
            } catch(e) {}
            return null;
        }

        function saveTeamFormData(teamId, data) {
            try {
                localStorage.setItem(`form_${teamId}`, JSON.stringify({ ts: Date.now(), data }));
            } catch(e) {}
        }

        async function fetchTeamForm(teamId) {
            const cached = getTeamFormData(teamId);
            if (cached) return cached;
            try {
                trackAPI(1);
                const res = await fetch(`https://v3.football.api-sports.io/fixtures?team=${teamId}&last=6`, {
                    headers: { "x-rapidapi-key": API_KEY }
                });
                const data = await res.json();
                if (!data.response || data.response.length === 0) return null;
                let scored = 0, conceded = 0, wins = 0, draws = 0, losses = 0, cleanSheets = 0;
                let homeScored = 0, homeConceded = 0, homeGames = 0;
                let awayScored = 0, awayConceded = 0, awayGames = 0;
                let bttsCount = 0, overCount = 0;
                const matches = data.response.length;
                data.response.forEach(f => {
                    const isHome = f.teams.home.id === teamId;
                    const gf = isHome ? (f.goals.home || 0) : (f.goals.away || 0);
                    const ga = isHome ? (f.goals.away || 0) : (f.goals.home || 0);
                    scored += gf;
                    conceded += ga;
                    if (gf > ga) wins++;
                    else if (gf === ga) draws++;
                    else losses++;
                    if (ga === 0) cleanSheets++;
                    if (gf > 0 && ga > 0) bttsCount++;
                    if (gf + ga > 2) overCount++;
                    if (isHome) { homeScored += gf; homeConceded += ga; homeGames++; }
                    else { awayScored += gf; awayConceded += ga; awayGames++; }
                });
                const formData = {
                    matches, wins, draws, losses,
                    scored, conceded, cleanSheets,
                    avgScored: scored / matches,
                    avgConceded: conceded / matches,
                    homeAvgScored: homeGames > 0 ? homeScored / homeGames : 0,
                    awayAvgScored: awayGames > 0 ? awayScored / awayGames : 0,
                    homeAvgConceded: homeGames > 0 ? homeConceded / homeGames : 0,
                    awayAvgConceded: awayGames > 0 ? awayConceded / awayGames : 0,
                    bttsRate: bttsCount / matches,
                    overRate: overCount / matches,
                    cleanSheetRate: cleanSheets / matches,
                    winRate: wins / matches
                };
                saveTeamFormData(teamId, formData);
                return formData;
            } catch(e) { return null; }
        }

        function analyzeDefensiveStrength(standings, teamId) {
            if (!standings) return null;
            try {
                const team = standings.find(t => t.team.id === teamId);
                if (!team) return null;
                const played = team.all.played || 1;
                const goalsAgainst = team.all.goals.against || 0;
                const goalsFor = team.all.goals.for || 0;
                const concededPerGame = goalsAgainst / played;
                const scoredPerGame = goalsFor / played;
                const totalTeams = standings.length;
                const defRank = standings.slice().sort((a, b) => (a.all.goals.against / Math.max(1, a.all.played)) - (b.all.goals.against / Math.max(1, b.all.played))).findIndex(t => t.team.id === teamId) + 1;
                const attRank = standings.slice().sort((a, b) => (b.all.goals.for / Math.max(1, b.all.played)) - (a.all.goals.for / Math.max(1, a.all.played))).findIndex(t => t.team.id === teamId) + 1;
                return {
                    concededPerGame: Math.round(concededPerGame * 100) / 100,
                    scoredPerGame: Math.round(scoredPerGame * 100) / 100,
                    defRank, attRank, totalTeams,
                    isStrongDefense: defRank <= Math.ceil(totalTeams * 0.25),
                    isWeakDefense: defRank > Math.ceil(totalTeams * 0.75),
                    isStrongAttack: attRank <= Math.ceil(totalTeams * 0.25),
                    isWeakAttack: attRank > Math.ceil(totalTeams * 0.75),
                    strength: concededPerGame <= 0.8 ? "fortress" : (concededPerGame <= 1.2 ? "solid" : (concededPerGame <= 1.6 ? "average" : "leaky"))
                };
            } catch(e) { return null; }
        }

        function calculateEnhancedXG(stats) {
            const hSoT = stats.homeSoT || 0;
            const aSoT = stats.awaySoT || 0;
            const hTotal = stats.homeTotal || 0;
            const aTotal = stats.awayTotal || 0;
            const hCorners = stats.homeCorners || 0;
            const aCorners = stats.awayCorners || 0;
            const hInsideBox = stats.homeShotsInBox || 0;
            const aInsideBox = stats.awayShotsInBox || 0;
            const hOutsideBox = stats.homeShotsOutBox || 0;
            const aOutsideBox = stats.awayShotsOutBox || 0;
            const hBigChances = stats.homeBigChances || 0;
            const aBigChances = stats.awayBigChances || 0;

            let hxG, axG;
            if (hInsideBox > 0 || hBigChances > 0) {
                hxG = hBigChances * 0.45 + (hInsideBox > 0 ? hInsideBox * 0.12 : hSoT * 0.32) + hOutsideBox * 0.03 + Math.max(0, hTotal - hSoT - hOutsideBox) * 0.02 + hCorners * 0.025;
                axG = aBigChances * 0.45 + (aInsideBox > 0 ? aInsideBox * 0.12 : aSoT * 0.32) + aOutsideBox * 0.03 + Math.max(0, aTotal - aSoT - aOutsideBox) * 0.02 + aCorners * 0.025;
            } else {
                hxG = hSoT * 0.32 + Math.max(0, hTotal - hSoT) * 0.05 + hCorners * 0.03;
                axG = aSoT * 0.32 + Math.max(0, aTotal - aSoT) * 0.05 + aCorners * 0.03;
            }
            return { hxG: Math.round(hxG * 100) / 100, axG: Math.round(axG * 100) / 100, enhanced: (hInsideBox > 0 || hBigChances > 0) };
        }

        function getMarketHistory() {
            try { return JSON.parse(localStorage.getItem('marketHistory') || '{}'); }
            catch(e) { return {}; }
        }

        function recordMarketOutcome(leagueId, market, won) {
            try {
                const db = getMarketHistory();
                const key = `${leagueId}_${market}`;
                if (!db[key]) db[key] = { wins: 0, losses: 0, total: 0 };
                db[key].total++;
                if (won) db[key].wins++;
                else db[key].losses++;
                if (db[key].total > 100) {
                    db[key].wins = Math.round(db[key].wins * 0.7);
                    db[key].losses = Math.round(db[key].losses * 0.7);
                    db[key].total = db[key].wins + db[key].losses;
                }
                localStorage.setItem('marketHistory', JSON.stringify(db));
            } catch(e) {}
        }

        function getMarketWinRate(leagueId, market) {
            const db = getMarketHistory();
            const key = `${leagueId}_${market}`;
            if (!db[key] || db[key].total < 5) return null;
            return {
                winRate: db[key].wins / db[key].total,
                total: db[key].total,
                wins: db[key].wins,
                losses: db[key].losses
            };
        }

        function getMarketKey(selection) {
            if (selection === 'Over 0.5 Goals') return 'o05';
            if (selection === 'Over 1.5 Goals') return 'o15';
            if (selection === 'Over 2.5 Goals') return 'o25';
            if (selection === 'Both Teams to Score') return 'btts';
            if (selection.startsWith('Next Goal:')) return 'next';
            return 'other';
        }

        function applyFormBoost(confidence, homeForm, awayForm, selection, isHome) {
            let boost = 0;
            let note = '';
            if (!homeForm && !awayForm) return { boost: 0, note: '' };

            if (selection.startsWith('Over') || selection === 'Both Teams to Score') {
                const hAvg = homeForm ? homeForm.avgScored : 0;
                const aAvg = awayForm ? awayForm.avgScored : 0;
                const combinedAvg = hAvg + aAvg;
                if (combinedAvg >= 3.5) { boost = 6; note = `üìä Both teams avg ${combinedAvg.toFixed(1)} goals combined.`; }
                else if (combinedAvg >= 2.8) { boost = 3; note = `üìä Combined avg ${combinedAvg.toFixed(1)} goals.`; }
                else if (combinedAvg < 1.8) { boost = -4; note = `‚ö†Ô∏è Low-scoring teams (avg ${combinedAvg.toFixed(1)}).`; }

                if (selection === 'Both Teams to Score') {
                    const hBtts = homeForm ? homeForm.bttsRate : 0;
                    const aBtts = awayForm ? awayForm.bttsRate : 0;
                    if (hBtts >= 0.65 && aBtts >= 0.65) { boost += 5; note += ` BTTS hits ${Math.round(hBtts*100)}%/${Math.round(aBtts*100)}% in recent form.`; }
                    else if (hBtts <= 0.3 || aBtts <= 0.3) { boost -= 4; note += ` Low BTTS rate in recent form.`; }
                }
            }

            if (selection.startsWith('Next Goal:')) {
                const scoringForm = isHome ? homeForm : awayForm;
                if (scoringForm) {
                    if (scoringForm.avgScored >= 2.0) { boost = 4; note = `üìä Scoring avg ${scoringForm.avgScored.toFixed(1)}/game in last ${scoringForm.matches}.`; }
                    else if (scoringForm.avgScored < 0.8) { boost = -5; note = `‚ö†Ô∏è Poor scoring form (${scoringForm.avgScored.toFixed(1)}/game).`; }
                }
            }

            return { boost, note };
        }

        function applyDefenseAdjustment(confidence, homeDef, awayDef, selection) {
            let boost = 0;
            let note = '';
            if (!homeDef && !awayDef) return { boost: 0, note: '' };

            if (selection.startsWith('Over') || selection === 'Both Teams to Score') {
                const bothStrong = (homeDef && homeDef.isStrongDefense) && (awayDef && awayDef.isStrongDefense);
                const bothLeaky = (homeDef && homeDef.isWeakDefense) && (awayDef && awayDef.isWeakDefense);
                if (bothStrong) { boost = -6; note = `üõ°Ô∏è Both defenses top-quarter (concede ${homeDef.concededPerGame}/${awayDef.concededPerGame} per game).`; }
                else if (bothLeaky) { boost = 5; note = `üí• Leaky defenses (concede ${homeDef.concededPerGame}/${awayDef.concededPerGame} per game).`; }
                else if ((homeDef && homeDef.strength === 'fortress') || (awayDef && awayDef.strength === 'fortress')) {
                    boost = -3;
                    const fort = (homeDef && homeDef.strength === 'fortress') ? 'Home' : 'Away';
                    note = `üõ°Ô∏è ${fort} defense is a fortress.`;
                }
            }

            if (selection === 'Both Teams to Score') {
                if (homeDef && homeDef.strength === 'fortress' && awayDef && awayDef.isWeakAttack) { boost -= 5; note += ` Home fortress vs weak attack.`; }
                if (awayDef && awayDef.strength === 'fortress' && homeDef && homeDef.isWeakAttack) { boost -= 5; note += ` Away fortress vs weak attack.`; }
            }

            return { boost, note };
        }

        function applyRefCardBoost(refProfile, elapsed) {
            if (!refProfile) return { boost: 0, note: '' };
            let boost = 0;
            let note = '';
            if (refProfile.strictness === 'strict') {
                boost = 4;
                note = `üëÆ ${refProfile.name || 'Ref'} is STRICT (avg ${refProfile.avgCards.toFixed(1)} cards/game).`;
                if (elapsed >= 70) { boost += 2; note += ` Late-game cards likely.`; }
            } else if (refProfile.strictness === 'lenient') {
                boost = -3;
                note = `üí§ ${refProfile.name || 'Ref'} is LENIENT (avg ${refProfile.avgCards.toFixed(1)} cards/game).`;
            }
            return { boost, note };
        }

        function applyHistoricalPatternBoost(leagueId, selection) {
            const marketKey = getMarketKey(selection);
            const history = getMarketWinRate(leagueId, marketKey);
            if (!history) return { boost: 0, note: '' };
            let boost = 0;
            let note = '';
            if (history.winRate >= 0.75 && history.total >= 8) {
                boost = 5;
                note = `üìà ${selection} hits ${Math.round(history.winRate * 100)}% in this league (${history.wins}/${history.total}).`;
            } else if (history.winRate >= 0.60 && history.total >= 8) {
                boost = 2;
                note = `üìä ${selection} wins ${Math.round(history.winRate * 100)}% here (${history.wins}/${history.total}).`;
            } else if (history.winRate < 0.35 && history.total >= 8) {
                boost = -5;
                note = `‚ö†Ô∏è ${selection} only ${Math.round(history.winRate * 100)}% hit rate here (${history.wins}/${history.total}).`;
            }
            return { boost, note };
        }

        function estimateWeatherImpact(venue, elapsed) {
            if (!venue) return { boost: 0, note: '' };
            const city = (venue.city || '').toLowerCase();
            const name = (venue.name || '').toLowerCase();
            const month = new Date().getMonth();
            const isWinter = month >= 10 || month <= 2;
            const coldCities = ['moscow', 'st. petersburg', 'oslo', 'helsinki', 'stockholm', 'copenhagen', 'reykjavik', 'warsaw', 'minsk', 'kiev', 'kyiv'];
            const rainyCities = ['manchester', 'liverpool', 'glasgow', 'london', 'dublin', 'cardiff', 'amsterdam', 'hamburg', 'bruges', 'porto', 'bilbao'];
            const hotCities = ['seville', 'malaga', 'naples', 'catania', 'jeddah', 'riyadh', 'doha', 'abu dhabi', 'dubai', 'cairo', 'casablanca'];
            let boost = 0;
            let note = '';
            if (isWinter && coldCities.some(c => city.includes(c))) {
                boost = 2;
                note = `‚ùÑÔ∏è Cold conditions ‚Äî more fouls, physical play likely.`;
            }
            if (rainyCities.some(c => city.includes(c)) && isWinter) {
                boost = 1;
                note = `üåßÔ∏è Likely wet pitch ‚Äî slippery fouls more common.`;
            }
            if (hotCities.some(c => city.includes(c)) && !isWinter) {
                if (elapsed >= 70) { boost = 2; note = `üå°Ô∏è Hot conditions + fatigue ‚Äî defensive errors more likely late.`; }
            }
            return { boost, note };
        }

        // =============================================
        // ANALYTICS v4 - xG GAP, SUBS, CALIBRATION,
        // CONGESTION, SCORE FLOW, MARKET CHAIN, POSS TREND
        // =============================================

        function analyzeXGGap(enhancedXG, homeGoals, awayGoals) {
            const totalXG = enhancedXG.hxG + enhancedXG.axG;
            const totalGoals = homeGoals + awayGoals;
            const gap = totalXG - totalGoals;
            const hGap = enhancedXG.hxG - homeGoals;
            const aGap = enhancedXG.axG - awayGoals;
            let boost = 0;
            let note = '';
            if (gap >= 1.5) {
                boost = 5;
                note = `üéØ xG gap: ${totalXG.toFixed(1)} xG vs ${totalGoals} goals ‚Äî goals overdue!`;
            } else if (gap >= 0.8) {
                boost = 3;
                note = `üéØ xG ${totalXG.toFixed(1)} vs ${totalGoals} actual ‚Äî chances being created.`;
            } else if (gap <= -1.0 && totalGoals >= 2) {
                boost = -3;
                note = `üìâ Overperforming: ${totalGoals} goals from only ${totalXG.toFixed(1)} xG.`;
            }
            return { boost, note, gap, hGap, aGap, totalXG };
        }

        function analyzeSubstitutionImpact(events, elapsed) {
            if (!events || events.length === 0) return { boost: 0, note: '' };
            let lateSubs = 0;
            let recentSub = false;
            events.forEach(e => {
                if (e.type === 'subst' && e.time && e.time.elapsed) {
                    const subMin = e.time.elapsed;
                    if (subMin >= 55) {
                        lateSubs++;
                        if (elapsed - subMin <= 10) recentSub = true;
                    }
                }
            });
            let boost = 0;
            let note = '';
            if (lateSubs >= 4 && recentSub) {
                boost = 4;
                note = `üîÑ ${lateSubs} late subs (55'+) ‚Äî fresh legs changing the game.`;
            } else if (lateSubs >= 3) {
                boost = 3;
                note = `üîÑ ${lateSubs} subs since 55' ‚Äî managers making tactical pushes.`;
            } else if (lateSubs >= 2 && recentSub) {
                boost = 2;
                note = `üîÑ Recent subs bringing fresh energy.`;
            }
            return { boost, note, lateSubs };
        }

        function getConfidenceCalibration() {
            try { return JSON.parse(localStorage.getItem('confCalibration') || '{}'); }
            catch(e) { return {}; }
        }

        function recordConfidenceResult(confidence, won) {
            try {
                const db = getConfidenceCalibration();
                const bucket = Math.floor(confidence / 5) * 5;
                const key = `b${bucket}`;
                if (!db[key]) db[key] = { predicted: bucket, wins: 0, total: 0 };
                db[key].total++;
                if (won) db[key].wins++;
                if (db[key].total > 100) {
                    db[key].wins = Math.round(db[key].wins * 0.7);
                    db[key].total = Math.round(db[key].total * 0.7);
                }
                localStorage.setItem('confCalibration', JSON.stringify(db));
            } catch(e) {}
        }

        function getCalibrationAdjustment(confidence) {
            const db = getConfidenceCalibration();
            const bucket = Math.floor(confidence / 5) * 5;
            const key = `b${bucket}`;
            if (!db[key] || db[key].total < 8) return { boost: 0, note: '' };
            const actualRate = db[key].wins / db[key].total;
            const predictedRate = bucket / 100;
            const diff = actualRate - predictedRate;
            let boost = 0;
            let note = '';
            if (diff <= -0.15 && db[key].total >= 10) {
                boost = Math.max(-5, Math.round(diff * 20));
                note = `üìè Calibration: ${bucket}% picks actually hit ${Math.round(actualRate * 100)}% (${db[key].wins}/${db[key].total}).`;
            } else if (diff >= 0.10 && db[key].total >= 10) {
                boost = Math.min(4, Math.round(diff * 15));
                note = `üìè Calibrated up: ${bucket}% picks hit ${Math.round(actualRate * 100)}% historically.`;
            }
            return { boost, note };
        }

        function analyzeFixtureCongestion(teamForm) {
            if (!teamForm || !teamForm.matches) return { boost: 0, note: '' };
            if (teamForm.matches >= 5 && teamForm.avgConceded >= 1.5 && teamForm.cleanSheetRate <= 0.15) {
                return { boost: 3, note: `üèÉ Busy schedule + leaky defense (${teamForm.avgConceded.toFixed(1)} conceded/game, ${Math.round(teamForm.cleanSheetRate*100)}% clean sheets).` };
            }
            if (teamForm.matches >= 6 && teamForm.losses >= 3) {
                return { boost: 2, note: `üìâ Poor run of form (${teamForm.losses} losses in last ${teamForm.matches}).` };
            }
            return { boost: 0, note: '' };
        }

        function analyzeScoreFlow(events, elapsed, homeGoals, awayGoals) {
            if (!events) return { boost: 0, note: '', lastGoalElapsed: null, goalBurst: false };
            const goalEvents = events.filter(e => e.type === 'Goal' && e.time && e.time.elapsed).sort((a, b) => (a.time.elapsed + (a.time.extra || 0)) - (b.time.elapsed + (b.time.extra || 0)));
            if (goalEvents.length === 0) return { boost: 0, note: '', lastGoalElapsed: null, goalBurst: false };
            const lastGoal = goalEvents[goalEvents.length - 1];
            const lastGoalMin = lastGoal.time.elapsed + (lastGoal.time.extra || 0);
            const minutesSinceLast = elapsed - lastGoalMin;
            let boost = 0;
            let note = '';
            let goalBurst = false;
            const recentGoals = goalEvents.filter(ge => (elapsed - (ge.time.elapsed + (ge.time.extra || 0))) <= 15);
            if (recentGoals.length >= 2) {
                goalBurst = true;
                boost = 5;
                note = `üî• Goal burst! ${recentGoals.length} goals in last 15 min ‚Äî game wide open.`;
            } else if (minutesSinceLast <= 5 && elapsed >= 60) {
                boost = 4;
                note = `‚ö° Goal just ${minutesSinceLast} min ago ‚Äî both teams unsettled.`;
            } else if (minutesSinceLast <= 10 && elapsed >= 65) {
                boost = 2;
                note = `‚ö° Recent goal at ${lastGoalMin}' ‚Äî tempo still high.`;
            }
            const concededRecently = recentGoals.length > 0;
            if (concededRecently && homeGoals === awayGoals) {
                boost += 2;
                note += ` Equalizer effect ‚Äî trailing team was desperate, now both push.`;
            }
            return { boost, note, lastGoalElapsed: lastGoalMin, goalBurst };
        }

        function suggestMarketChain(totalGoals, elapsed, confidence, stats) {
            let chainCandidate = null;
            const totalSoT = (stats.homeSoT || 0) + (stats.awaySoT || 0);
            const totalShots = (stats.homeTotal || 0) + (stats.awayTotal || 0);
            if (totalGoals === 2 && elapsed >= 50 && elapsed <= 78 && totalSoT >= 5 && totalShots >= 12) {
                const chainConf = Math.min(88, Math.round(confidence * 0.85));
                if (chainConf >= 75) {
                    chainCandidate = {
                        selection: "Over 2.5 Goals",
                        marketKey: 'o25',
                        confidence: chainConf,
                        reasoning: `üìà Market chain: Over 1.5 landed (${totalGoals} goals). ${totalSoT} SoT, ${totalShots} shots ‚Äî pattern suggests more.`
                    };
                }
            }
            if (totalGoals === 3 && elapsed >= 55 && elapsed <= 80 && totalSoT >= 6) {
                const chainConf = Math.min(85, Math.round(confidence * 0.80));
                if (chainConf >= 75) {
                    chainCandidate = {
                        selection: "Over 3.5 Goals",
                        marketKey: 'o25',
                        confidence: chainConf,
                        reasoning: `üìà Market chain: Over 2.5 landed (${totalGoals} goals)! ${totalSoT} SoT, wide open game.`
                    };
                }
            }
            return chainCandidate;
        }

        function analyzePossessionTrend(stats, momentum) {
            let boost = 0;
            let note = '';
            const hPoss = stats.homePoss || 50;
            const aPoss = stats.awayPoss || 50;
            if (momentum && momentum.surgeTeam !== 'none') {
                const surgeTeamPoss = momentum.surgeTeam === 'home' ? hPoss : aPoss;
                if (surgeTeamPoss >= 60) {
                    boost = 3;
                    note = `üìä ${momentum.surgeTeam === 'home' ? 'Home' : 'Away'} controlling ${Math.round(surgeTeamPoss)}% possession + momentum surge ‚Äî sustained dominance.`;
                } else if (surgeTeamPoss >= 55) {
                    boost = 2;
                    note = `üìä ${momentum.surgeTeam === 'home' ? 'Home' : 'Away'} gaining control (${Math.round(surgeTeamPoss)}% poss) with momentum.`;
                }
            }
            if (Math.abs(hPoss - aPoss) >= 25) {
                boost += 2;
                const domTeam = hPoss > aPoss ? 'Home' : 'Away';
                note += ` ${domTeam} dominating possession (${Math.round(Math.max(hPoss, aPoss))}%).`;
            }
            return { boost, note };
        }

        function analyzeShotAccuracy(stats) {
            const homeAcc = stats.homeTotal > 0 ? (stats.homeSoT / stats.homeTotal) : 0;
            const awayAcc = stats.awayTotal > 0 ? (stats.awaySoT / stats.awayTotal) : 0;
            const combinedAcc = (stats.homeTotal + stats.awayTotal) > 0 ? ((stats.homeSoT + stats.awaySoT) / (stats.homeTotal + stats.awayTotal)) : 0;
            let boost = 0;
            let note = '';
            if (combinedAcc >= 0.45 && (stats.homeSoT + stats.awaySoT) >= 6) {
                boost = 3;
                note = `üéØ High shot accuracy (${Math.round(combinedAcc*100)}% on target) ‚Äî clinical finishing.`;
            } else if (combinedAcc >= 0.38 && (stats.homeSoT + stats.awaySoT) >= 5) {
                boost = 2;
                note = `üéØ Good accuracy (${Math.round(combinedAcc*100)}% on target).`;
            } else if (combinedAcc <= 0.20 && (stats.homeTotal + stats.awayTotal) >= 12) {
                boost = -2;
                note = `‚ùå Poor accuracy (${Math.round(combinedAcc*100)}% on target) ‚Äî wasteful.`;
            }
            return { boost, note, homeAcc, awayAcc, combinedAcc };
        }

        function analyzeSecondHalfMomentum(stats, elapsed, totalGoals, events) {
            if (elapsed < 50) return { boost: 0, note: '' };
            let boost = 0;
            let note = '';
            if (events && events.length > 0) {
                const firstHalfGoals = events.filter(e => e.type === 'Goal' && e.time && e.time.elapsed <= 45).length;
                const secondHalfGoals = totalGoals - firstHalfGoals;
                if (secondHalfGoals > firstHalfGoals && secondHalfGoals >= 2) {
                    boost = 3;
                    note = `‚ö° 2nd half explosion: ${secondHalfGoals} goals vs ${firstHalfGoals} in 1st half!`;
                } else if (secondHalfGoals > firstHalfGoals && secondHalfGoals >= 1) {
                    boost = 1;
                    note = `üìà More goals in 2nd half (${secondHalfGoals} vs ${firstHalfGoals}).`;
                } else if (firstHalfGoals >= 2 && secondHalfGoals === 0 && elapsed >= 60) {
                    boost = -2;
                    note = `üìâ All ${firstHalfGoals} goals in 1st half ‚Äî game may have settled.`;
                }
            }
            return { boost, note };
        }

        async function fetchStandingsForLeague(leagueId, season) {
            const cacheKey = `${leagueId}_${season}`;
            if (standingsCache[cacheKey]) return standingsCache[cacheKey];
            try {
                trackAPI(1);
                const res = await fetch(`https://v3.football.api-sports.io/standings?league=${leagueId}&season=${season}`, {
                    headers: { "x-rapidapi-key": API_KEY }
                });
                const data = await res.json();
                if (data.response && data.response.length > 0 && data.response[0].league && data.response[0].league.standings && data.response[0].league.standings[0]) {
                    standingsCache[cacheKey] = data.response[0].league.standings[0];
                    return standingsCache[cacheKey];
                }
            } catch(e) {}
            return null;
        }

        function getLeagueProfile(leagueId) {
            return LEAGUE_PROFILES[leagueId] || DEFAULT_LEAGUE;
        }

        function getScoreState(homeGoals, awayGoals) {
            const key = `${homeGoals}-${awayGoals}`;
            return SCORE_STATE_MAP[key] || DEFAULT_SCORE_STATE;
        }

        function calculateMomentum(match, stats) {
            const elapsed = match.fixture.status.elapsed || 0;
            const fid = match.fixture.id;
            const totalSoT = (stats.homeSoT || 0) + (stats.awaySoT || 0);
            const totalCorners = (stats.homeCorners || 0) + (stats.awayCorners || 0);
            const totalShots = (stats.homeTotal || 0) + (stats.awayTotal || 0);

            const currentPressure = totalSoT * 3 + totalShots * 1.5 + totalCorners * 2;

            if (!momentumHistory[fid]) {
                momentumHistory[fid] = { lastPressure: currentPressure, lastTime: elapsed, surgeCount: 0 };
            }

            const prev = momentumHistory[fid];
            const timeDiff = elapsed - prev.lastTime;
            const pressureDiff = currentPressure - prev.lastPressure;

            let surgeDetected = false;
            let surgeTeam = "none";
            let momentumScore = 50;

            if (timeDiff > 0 && timeDiff <= 15) {
                const rateOfChange = pressureDiff / timeDiff;
                if (rateOfChange > 1.5) {
                    surgeDetected = true;
                    prev.surgeCount++;
                }
            }

            const homePressure = (stats.homeSoT || 0) * 3 + (stats.homeTotal || 0) * 1.5 + (stats.homeCorners || 0) * 2;
            const awayPressure = (stats.awaySoT || 0) * 3 + (stats.awayTotal || 0) * 1.5 + (stats.awayCorners || 0) * 2;
            const total = homePressure + awayPressure || 1;

            momentumScore = Math.round((homePressure / total) * 100);

            if ((stats.homeSoT || 0) >= (stats.awaySoT || 0) + 3) surgeTeam = "home";
            else if ((stats.awaySoT || 0) >= (stats.homeSoT || 0) + 3) surgeTeam = "away";
            else if ((stats.homeCorners || 0) >= (stats.awayCorners || 0) + 4) surgeTeam = "home";
            else if ((stats.awayCorners || 0) >= (stats.homeCorners || 0) + 4) surgeTeam = "away";

            prev.lastPressure = currentPressure;
            prev.lastTime = elapsed;

            return {
                surgeDetected,
                surgeTeam,
                surgeCount: prev.surgeCount,
                momentumScore,
                homePressure,
                awayPressure,
                rateOfChange: timeDiff > 0 ? (pressureDiff / timeDiff) : 0
            };
        }

        function calculateSmartPressure(stats) {
            const hSoT = stats.homeSoT || 0;
            const aSoT = stats.awaySoT || 0;
            const hTotal = stats.homeTotal || 0;
            const aTotal = stats.awayTotal || 0;
            const hCorners = stats.homeCorners || 0;
            const aCorners = stats.awayCorners || 0;
            const hPoss = stats.homePoss || 50;
            const aPoss = stats.awayPoss || 50;

            const hScore = (hSoT * 4) + (hTotal * 1.5) + (hCorners * 2.5) + ((hPoss - 50) * 0.3);
            const aScore = (aSoT * 4) + (aTotal * 1.5) + (aCorners * 2.5) + ((aPoss - 50) * 0.3);
            const total = hScore + aScore || 1;
            
            const hPercent = Math.round((hScore / total) * 100);
            const aPercent = 100 - hPercent;

            const hxG = hSoT * 0.32 + (hTotal - hSoT) * 0.05 + hCorners * 0.03;
            const axG = aSoT * 0.32 + (aTotal - aSoT) * 0.05 + aCorners * 0.03;

            let dominance = "balanced";
            if (hPercent >= 68) dominance = "home_siege";
            else if (hPercent >= 58) dominance = "home_edge";
            else if (aPercent >= 68) dominance = "away_siege";
            else if (aPercent >= 58) dominance = "away_edge";

            return { hPercent, aPercent, hxG, axG, hScore, aScore, dominance };
        }

        function analyzeH2H(h2hData, homeId) {
            if (!h2hData || !h2hData.response || h2hData.response.length === 0) {
                return { available: false, hWins: 0, aWins: 0, draws: 0, avgGoals: 2.5, bttsRate: 0.5, homeWinRate: 0.4 };
            }
            let hWins = 0, aWins = 0, draws = 0, totalGoals = 0, bttsCount = 0;
            h2hData.response.forEach(fix => {
                const hg = fix.score.fulltime.home || 0;
                const ag = fix.score.fulltime.away || 0;
                totalGoals += hg + ag;
                if (hg > 0 && ag > 0) bttsCount++;
                if (fix.teams.home.winner === true || fix.teams.away.winner === true) {
                    const winnerId = fix.teams.home.winner ? fix.teams.home.id : fix.teams.away.id;
                    if (winnerId === homeId) hWins++;
                    else aWins++;
                } else draws++;
            });
            const total = h2hData.response.length;
            return {
                available: true,
                hWins, aWins, draws,
                avgGoals: totalGoals / total,
                bttsRate: bttsCount / total,
                homeWinRate: hWins / total,
                totalMatches: total
            };
        }

        function generateSmartVerdict(match, pressure, momentum, scoreState, leagueProfile, h2h) {
            const elapsed = match.fixture.status.elapsed || 0;
            const hGoals = match.goals.home;
            const aGoals = match.goals.away;
            const totalGoals = hGoals + aGoals;
            const goalDiff = Math.abs(hGoals - aGoals);

            let verdict = "";
            let confidence = 50;
            let betTip = "";
            let tipConfidence = 0;
            const tips = [];

            const timeMultiplier = elapsed >= 75 ? 1.15 : (elapsed >= 70 ? 1.08 : 1.0);
            const leagueBoost = leagueProfile.tempo === "high" ? 1.10 : (leagueProfile.tempo === "low" ? 0.90 : 1.0);
            const lateGoalBoost = leagueProfile.lateGoalRate > 0.30 ? 1.12 : 1.0;

            if (totalGoals === 0) {
                if (pressure.hPercent >= 68 || pressure.aPercent >= 68) {
                    const dominant = pressure.hPercent >= 68 ? match.teams.home.name : match.teams.away.name;
                    verdict = `üî• ${dominant} Siege (0-0)`;
                    confidence = Math.min(95, Math.round(72 * timeMultiplier * leagueBoost));
                    const goalConf = Math.min(95, Math.round(scoreState.goalProb * 100 * timeMultiplier * lateGoalBoost));
                    tips.push({ tip: "Over 0.5 Goals", conf: goalConf, reason: `${dominant} dominating with ${Math.max(pressure.hPercent, pressure.aPercent)}% pressure but can't break through. Breakthrough imminent in ${leagueProfile.name}.` });
                    if (momentum.surgeDetected) {
                        tips.push({ tip: `Next Goal: ${dominant}`, conf: Math.min(92, goalConf + 5), reason: `Momentum surge detected! ${dominant} creating chances at increasing rate.` });
                    }
                } else {
                    verdict = "üõ°Ô∏è 0-0 Stalemate";
                    confidence = Math.round(65 * timeMultiplier);
                    if (elapsed >= 75) {
                        tips.push({ tip: "Over 0.5 Goals", conf: Math.min(90, Math.round(68 * timeMultiplier * lateGoalBoost)), reason: `0-0 at ${elapsed}' - both teams will gamble late. ${leagueProfile.name} has ${Math.round(leagueProfile.lateGoalRate * 100)}% late goal rate.` });
                    }
                }
            } else if (goalDiff === 0) {
                verdict = totalGoals >= 4 ? "‚öîÔ∏è Goal Fest Draw" : "‚ö†Ô∏è Tight Match";
                confidence = Math.round(70 * timeMultiplier);
                if (totalGoals >= 2) {
                    tips.push({ tip: `Over ${totalGoals + 0.5} Goals`, conf: Math.min(88, Math.round(scoreState.goalProb * 100 * leagueBoost)), reason: `Already ${hGoals}-${aGoals}. Open game, both teams chasing the winner.` });
                }
                tips.push({ tip: "Both Teams to Score", conf: Math.min(92, Math.round(scoreState.bttsProb * 100)), reason: `Level at ${hGoals}-${aGoals}. ${scoreState.desc}` });
            } else if (goalDiff === 1) {
                const chasingTeam = hGoals < aGoals ? match.teams.home.name : match.teams.away.name;
                const leadTeam = hGoals > aGoals ? match.teams.home.name : match.teams.away.name;
                verdict = `‚öΩ ${chasingTeam} Chasing`;
                confidence = Math.min(93, Math.round(82 * timeMultiplier * leagueBoost));
                const nextGoalConf = Math.min(93, Math.round(scoreState.goalProb * 100 * timeMultiplier * lateGoalBoost));
                tips.push({ tip: `Over ${totalGoals + 0.5} Goals`, conf: nextGoalConf, reason: `${chasingTeam} trailing ${hGoals}-${aGoals} at ${elapsed}'. Will push hard for equalizer. ${leagueProfile.name} late goal rate: ${Math.round(leagueProfile.lateGoalRate * 100)}%.` });
                if (momentum.surgeTeam !== "none") {
                    const surgeTeamName = momentum.surgeTeam === "home" ? match.teams.home.name : match.teams.away.name;
                    tips.push({ tip: `Next Goal: ${surgeTeamName}`, conf: Math.min(90, nextGoalConf + 3), reason: `${surgeTeamName} building momentum with sustained pressure surge.` });
                }
            } else {
                verdict = `üîí ${goalDiff >= 3 ? 'Game Over' : 'Result Likely Safe'}`;
                confidence = Math.min(96, 85 + goalDiff * 3);
                if (totalGoals >= 3 && elapsed <= 75) {
                    tips.push({ tip: `Over ${totalGoals + 0.5} Goals`, conf: Math.min(80, Math.round(45 * leagueBoost)), reason: `${hGoals}-${aGoals} with time remaining. High-scoring game may produce more.` });
                }
            }

            if (h2h.available && h2h.avgGoals > 3.0) {
                tips.forEach(t => {
                    if (t.tip.startsWith("Over")) {
                        t.conf = Math.min(96, t.conf + 5);
                        t.reason += ` H2H avg: ${h2h.avgGoals.toFixed(1)} goals/game.`;
                    }
                });
            }
            if (h2h.available && h2h.bttsRate > 0.6) {
                tips.forEach(t => {
                    if (t.tip === "Both Teams to Score") {
                        t.conf = Math.min(96, t.conf + 6);
                        t.reason += ` H2H BTTS rate: ${Math.round(h2h.bttsRate * 100)}%.`;
                    }
                });
            }

            if (momentum.surgeDetected) {
                confidence = Math.min(96, confidence + 5);
                verdict += " ‚ö°";
            }

            tips.sort((a, b) => b.conf - a.conf);
            const bestTip = tips.length > 0 ? tips[0] : null;
            const threshold = (typeof userConfThreshold !== 'undefined') ? userConfThreshold : 75;
            const filteredTips = tips.filter(t => t.conf >= threshold);

            return { verdict, confidence, bestTip, allTips: filteredTips, scoreState, momentum };
        }

        // --- HELP MODAL ---
        function openHelp() { document.getElementById('helpModal').style.display = 'block'; }
        function closeHelp(e) { if(e.target.id === 'helpModal') document.getElementById('helpModal').style.display = 'none'; }

        // --- TRACKER LOGIC ---
        function getHistory() { return JSON.parse(localStorage.getItem('betHistory') || "[]"); }
        function saveHistory(bets) { localStorage.setItem('betHistory', JSON.stringify(bets)); }
        function getPlacedBets() { return getHistory().map(b => b.id); }

        function toggleBet(id, homeGoals, awayGoals, teams) {
            let bets = getHistory();
            const existingIndex = bets.findIndex(b => b.id === id);
            if(existingIndex >= 0) { bets.splice(existingIndex, 1); } 
            else {
                const today = new Date().toLocaleDateString('en-CA');
                bets.push({ id: id, date: today, teams: teams, goalsAtBet: homeGoals + awayGoals, status: 'OPEN' });
            }
            saveHistory(bets);
            applyFilter(); 
        }

        // --- CARD WATCH TICKER ---
        function getMarkedPlayers() { return JSON.parse(localStorage.getItem('cardBets') || "[]"); }
        function togglePlayerBet(uid, el) {
            let pBets = getMarkedPlayers();
            if(pBets.includes(uid)) {
                pBets = pBets.filter(b => b !== uid);
                el.classList.remove('active');
                el.innerText = "";
                el.parentElement.classList.remove('marked');
            } else {
                pBets.push(uid);
                el.classList.add('active');
                el.innerText = "‚úì";
                el.parentElement.classList.add('marked');
            }
            localStorage.setItem('cardBets', JSON.stringify(pBets));
        }

        function exportCSV() {
            const huntBets = getHistory();
            const challengeBets = getPlacedChallenges();
            const allExport = [];
            huntBets.forEach(b => {
                allExport.push({ date: b.date, match: b.teams, selection: b.selection || 'Next Goal', source: 'Hunt', status: b.status, score: b.finalScore || '' });
            });
            challengeBets.forEach(b => {
                const d = b.placedAt ? new Date(b.placedAt).toLocaleDateString('en-CA') : '';
                let src = 'Challenge';
                if (b.selection === '2nd Half Goal') src = '2nd Half';
                else if (b.selection && (b.selection.startsWith('Anytime Goalscorer') || b.selection.startsWith('Anytime Booking'))) src = 'Player';
                const st = b.status === 'resolved' ? (b.result ? 'WIN' : 'LOSS') : 'OPEN';
                allExport.push({ date: d, match: b.match || '', selection: b.selection || '', source: src, status: st, score: b.finalScore || '' });
            });
            if (allExport.length === 0) { alert("No history to export."); return; }
            let csv = "Date,Source,Match,Selection,Result,Final Score\n";
            allExport.forEach(b => {
                csv += `"${b.date}","${b.source}","${(b.match || '').replace(/"/g, '""')}","${(b.selection || '').replace(/"/g, '""')}","${b.status}","${b.score}"\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('hidden', '');
            a.setAttribute('href', url);
            a.setAttribute('download', 'final_third_history.csv');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        async function checkBetOutcomes(liveMatches) {
            let bets = getHistory();
            let changed = false;
            let openBets = bets.filter(b => b.status === 'OPEN');
            if(openBets.length === 0) return;

            openBets.forEach(bet => {
                const liveMatch = liveMatches.find(m => m.fixture.id === bet.id);
                if(liveMatch) {
                    const currentTotal = liveMatch.goals.home + liveMatch.goals.away;
                    if(currentTotal > bet.goalsAtBet) { bet.status = 'WIN'; changed = true; }
                }
            });

            const missingBets = openBets.filter(b => b.status === 'OPEN' && !liveMatches.find(m => m.fixture.id === b.id));
            if(missingBets.length > 0) {
                const ids = missingBets.map(b => b.id).join('-');
                trackAPI(1);
                try {
                    const res = await fetch(`https://v3.football.api-sports.io/fixtures?ids=${ids}`, { headers: { "x-rapidapi-key": API_KEY } });
                    const data = await res.json();
                    data.response.forEach(m => {
                        const bet = bets.find(b => b.id === m.fixture.id);
                        if(bet) {
                            const finalTotal = m.goals.home + m.goals.away;
                            const status = m.fixture.status.short;
                            if (finalTotal > bet.goalsAtBet) { bet.status = 'WIN'; changed = true; } 
                            else if (['FT', 'AET', 'PEN'].includes(status)) { bet.status = 'LOSS'; changed = true; }
                        }
                    });
                } catch(e) {}
            }
            if(changed) { saveHistory(bets); if(document.getElementById('tabHist').classList.contains('active')) renderHistory(); }
        }

        function renderHistory() {
            const huntBets = getHistory();
            const challengeBets = getPlacedChallenges();
            const histDiv = document.getElementById('histContent');

            const allBets = [];

            huntBets.forEach(b => {
                allBets.push({
                    date: b.date,
                    teams: b.teams,
                    selection: b.selection || 'Next Goal',
                    source: 'Hunt',
                    status: b.status === 'WIN' ? 'won' : (b.status === 'LOSS' ? 'lost' : 'open'),
                    finalScore: b.finalScore || null
                });
            });

            challengeBets.forEach(b => {
                const d = b.placedAt ? new Date(b.placedAt).toLocaleDateString('en-CA') : new Date().toLocaleDateString('en-CA');
                let sourceLabel = 'Challenge';
                if (b.selection === '2nd Half Goal') sourceLabel = '2nd Half';
                else if (b.selection && b.selection.startsWith('Anytime Goalscorer')) sourceLabel = 'Player';
                else if (b.selection && b.selection.startsWith('Anytime Booking')) sourceLabel = 'Player';
                allBets.push({
                    date: d,
                    teams: b.match || 'Unknown',
                    selection: b.selection || 'Unknown',
                    source: sourceLabel,
                    status: b.status === 'resolved' ? (b.result ? 'won' : 'lost') : 'open',
                    finalScore: b.finalScore || null
                });
            });

            if (allBets.length === 0) { histDiv.innerHTML = "<p style='text-align:center; color:#888; margin-top:50px;'>No bets tracked yet.</p>"; return; }

            allBets.sort((a, b) => b.date.localeCompare(a.date));
            const grouped = allBets.reduce((acc, bet) => {
                if (!acc[bet.date]) acc[bet.date] = [];
                acc[bet.date].push(bet);
                return acc;
            }, {});

            const sourceColors = { 'Hunt': 'var(--cyan)', 'Challenge': 'var(--gold)', '2nd Half': 'var(--green)', 'Player': 'var(--purple)' };

            let html = `<button class="export-btn" onclick="exportCSV()">üì• Export to Excel (CSV)</button>`;
            for (const [date, dayBets] of Object.entries(grouped)) {
                let dailyWins = 0, dailyLosses = 0, dailyOpen = 0;
                let cardsHtml = "";
                dayBets.forEach(b => {
                    let resClass = "hist-res-open"; let resText = "OPEN";
                    if (b.status === 'won') { resClass = "hist-res-win"; resText = "WIN"; dailyWins++; }
                    if (b.status === 'lost') { resClass = "hist-res-loss"; resText = "LOSS"; dailyLosses++; }
                    if (b.status === 'open') { dailyOpen++; }
                    const srcColor = sourceColors[b.source] || '#888';
                    cardsHtml += `<div class="hist-card" style="display:flex; align-items:center; gap:8px; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.04);">
                        <span style="font-size:0.55rem; padding:2px 6px; border-radius:4px; background:rgba(255,255,255,0.06); color:${srcColor}; font-weight:bold; min-width:52px; text-align:center;">${b.source}</span>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:0.78rem; color:#ddd; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${b.teams}</div>
                            <div style="font-size:0.65rem; color:#666;">${b.selection}${b.finalScore ? ' ¬∑ FT: ' + b.finalScore : ''}</div>
                        </div>
                        <div class="${resClass}" style="font-size:0.7rem; font-weight:bold; min-width:35px; text-align:right;">${resText}</div>
                    </div>`;
                });
                const dailyUnits = dailyWins - dailyLosses;
                const unitClass = dailyUnits > 0 ? "hist-unit-plus" : (dailyUnits < 0 ? "hist-unit-minus" : "hist-unit-even");
                const unitSign = dailyUnits > 0 ? "+" : "";
                const summaryParts = [];
                if (dailyWins > 0) summaryParts.push(`<span style="color:var(--green);">${dailyWins}W</span>`);
                if (dailyLosses > 0) summaryParts.push(`<span style="color:var(--red);">${dailyLosses}L</span>`);
                if (dailyOpen > 0) summaryParts.push(`<span style="color:var(--gold);">${dailyOpen} open</span>`);

                html += `
                    <div class="hist-day" style="margin-bottom:12px; background:var(--card); border-radius:10px; padding:10px 12px;">
                        <div class="hist-date-row" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <span style="font-size:0.8rem; font-weight:bold; color:#ddd;">üìÖ ${date}</span>
                            <div style="display:flex; gap:8px; align-items:center;">
                                <span style="font-size:0.7rem;">${summaryParts.join(' ¬∑ ')}</span>
                                <span class="${unitClass}" style="font-size:0.75rem; font-weight:bold;">${unitSign}${dailyUnits}u</span>
                            </div>
                        </div>
                        ${cardsHtml}
                    </div>
                `;
            }
            histDiv.innerHTML = html;
        }

        function trackAPI(count) {
            const today = new Date().toISOString().split('T')[0];
            let storeDate = localStorage.getItem('apiDate');
            let current = parseInt(localStorage.getItem('apiCount') || "0");
            if (storeDate !== today) { current = 0; localStorage.setItem('apiDate', today); }
            current += count;
            localStorage.setItem('apiCount', current);
            document.getElementById('apiCounter').innerText = `API: ${current}`;
        }
        trackAPI(0);

        function switchTab(tab) {
            stopChallengeAutoRefresh();
            const views = ['liveView','schedView','histView','cardView','accView','challengeView','statsView','secondHalfGoalView','botdView'];
            const tabs = ['tabLive','tabSched','tabHist','tabCards','tabAcc','tabChallenge','tabStats','tab2hg','tabBotd'];
            views.forEach(v => document.getElementById(v).style.display = 'none');
            tabs.forEach(t => document.getElementById(t).classList.remove('active'));
            document.getElementById('filterSelect').style.display = 'none';

            if(tab === 'live') {
                document.getElementById('liveView').style.display = 'block';
                document.getElementById('tabLive').classList.add('active');
                document.getElementById('filterSelect').style.display = 'block';
            } else if(tab === 'challenge') {
                document.getElementById('challengeView').style.display = 'block';
                document.getElementById('tabChallenge').classList.add('active');
                loadChallengeState();
            } else if(tab === 'sched') {
                document.getElementById('schedView').style.display = 'block';
                document.getElementById('tabSched').classList.add('active');
                loadSchedule();
            } else if(tab === 'cards') {
                document.getElementById('cardView').style.display = 'block';
                document.getElementById('tabCards').classList.add('active');
            } else if(tab === 'acc') {
                document.getElementById('accView').style.display = 'block';
                document.getElementById('tabAcc').classList.add('active');
            } else if(tab === '2hg') {
                document.getElementById('secondHalfGoalView').style.display = 'block';
                document.getElementById('tab2hg').classList.add('active');
            } else if(tab === 'botd') {
                document.getElementById('botdView').style.display = 'block';
                document.getElementById('tabBotd').classList.add('active');
            } else if(tab === 'stats') {
                document.getElementById('statsView').style.display = 'block';
                document.getElementById('tabStats').classList.add('active');
                renderStatsDashboard();
            } else {
                document.getElementById('histView').style.display = 'block';
                document.getElementById('tabHist').classList.add('active');
                checkBetOutcomes(allMatches); 
                renderHistory();
            }
        }

        function accaScoreMarkets(homeForm, awayForm, homeDef, awayDef, h2h, homePos, awayPos, totalTeams, leagueProfile) {
            const tips = [];
            const hAvgS = homeForm ? homeForm.avgScored : 1.2;
            const aAvgS = awayForm ? awayForm.avgScored : 1.0;
            const hAvgC = homeForm ? homeForm.avgConceded : 1.2;
            const aAvgC = awayForm ? awayForm.avgConceded : 1.2;
            const expectedGoals = ((hAvgS + aAvgC) / 2) + ((aAvgS + hAvgC) / 2);
            const hBtts = homeForm ? homeForm.bttsRate : 0.5;
            const aBtts = awayForm ? awayForm.bttsRate : 0.5;
            const hOver = homeForm ? homeForm.overRate : 0.5;
            const aOver = awayForm ? awayForm.overRate : 0.5;
            const hWinRate = homeForm ? homeForm.winRate : 0.4;
            const aWinRate = awayForm ? awayForm.winRate : 0.4;
            const hClean = homeForm ? homeForm.cleanSheetRate : 0.2;
            const aClean = awayForm ? awayForm.cleanSheetRate : 0.2;
            const lgAvg = leagueProfile ? leagueProfile.avgGoals : 2.5;

            let o15Prob = Math.min(0.95, 0.5 + (expectedGoals - 1.5) * 0.2);
            if (h2h && h2h.available && h2h.avgGoals > 2.0) o15Prob += 0.05;
            if (expectedGoals > 2.8) o15Prob += 0.05;
            o15Prob = Math.min(0.96, Math.max(0.3, o15Prob));
            tips.push({ market: 'Over 1.5 Goals', prob: o15Prob, odds: Math.max(1.08, (1 / o15Prob * (1 + Math.random() * 0.06))).toFixed(2), reasoning: `Avg ${expectedGoals.toFixed(1)} goals expected` });

            let o25Prob = Math.min(0.90, 0.3 + (expectedGoals - 2.5) * 0.18 + (hOver + aOver) / 2 * 0.15);
            if (h2h && h2h.available && h2h.avgGoals > 2.8) o25Prob += 0.06;
            if (lgAvg > 2.8) o25Prob += 0.04;
            o25Prob = Math.min(0.90, Math.max(0.2, o25Prob));
            tips.push({ market: 'Over 2.5 Goals', prob: o25Prob, odds: Math.max(1.30, (1 / o25Prob * (1 + Math.random() * 0.08))).toFixed(2), reasoning: `Combined Over rate: ${Math.round((hOver + aOver) / 2 * 100)}%` });

            let bttsProb = Math.min(0.85, (hBtts + aBtts) / 2 * 0.6 + (1 - hClean) * 0.1 + (1 - aClean) * 0.1 + (expectedGoals > 2.5 ? 0.08 : 0));
            if (h2h && h2h.available && h2h.bttsRate > 0.6) bttsProb += 0.06;
            if (homeDef && homeDef.isWeakDefense) bttsProb += 0.05;
            if (awayDef && awayDef.isWeakDefense) bttsProb += 0.05;
            if (homeDef && homeDef.isStrongDefense) bttsProb -= 0.08;
            if (awayDef && awayDef.isStrongDefense) bttsProb -= 0.08;
            bttsProb = Math.min(0.88, Math.max(0.2, bttsProb));
            tips.push({ market: 'BTTS', prob: bttsProb, odds: Math.max(1.40, (1 / bttsProb * (1 + Math.random() * 0.08))).toFixed(2), reasoning: `Form BTTS: ${Math.round(hBtts * 100)}% / ${Math.round(aBtts * 100)}%` });

            let homeWinProb = 0.35;
            if (homeForm && awayForm) {
                homeWinProb = 0.3 + (hWinRate - aWinRate) * 0.25;
                if (homeForm.homeAvgScored > 1.5) homeWinProb += 0.08;
                if (awayForm.awayAvgScored < 0.8) homeWinProb += 0.05;
            }
            if (homePos && awayPos && totalTeams > 0) {
                const posDiff = (awayPos - homePos) / totalTeams;
                homeWinProb += posDiff * 0.15;
            }
            if (h2h && h2h.available && h2h.homeWinRate > 0.5) homeWinProb += 0.05;
            if (homeDef && homeDef.isStrongDefense && homeDef.isStrongAttack) homeWinProb += 0.06;
            homeWinProb = Math.min(0.88, Math.max(0.15, homeWinProb));
            tips.push({ market: 'Home Win', prob: homeWinProb, odds: Math.max(1.15, (1 / homeWinProb * (1 + Math.random() * 0.08))).toFixed(2), reasoning: `Win rates: H ${Math.round(hWinRate * 100)}% / A ${Math.round(aWinRate * 100)}%` });

            let awayWinProb = 0.28;
            if (homeForm && awayForm) {
                awayWinProb = 0.25 + (aWinRate - hWinRate) * 0.25;
                if (awayForm.awayAvgScored > 1.3) awayWinProb += 0.08;
                if (homeForm.homeAvgScored < 0.8) awayWinProb += 0.05;
            }
            if (homePos && awayPos && totalTeams > 0) {
                const posDiff = (homePos - awayPos) / totalTeams;
                awayWinProb += posDiff * 0.15;
            }
            if (h2h && h2h.available && h2h.homeWinRate < 0.3) awayWinProb += 0.05;
            awayWinProb = Math.min(0.80, Math.max(0.1, awayWinProb));
            tips.push({ market: 'Away Win', prob: awayWinProb, odds: Math.max(1.30, (1 / awayWinProb * (1 + Math.random() * 0.08))).toFixed(2), reasoning: `Win rates: A ${Math.round(aWinRate * 100)}% / H ${Math.round(hWinRate * 100)}%` });

            return tips;
        }

        async function generateAccas(btn) {
            btn.innerText = "üîç ANALYZING FIXTURES...";
            btn.disabled = true;
            const area = document.getElementById('accContent');
            const allowedMarkets = getAccaMarketFilters();
            if (allowedMarkets.length === 0) {
                area.innerHTML = "<div style='text-align:center; padding:40px; color:#da3633;'>Please select at least one market in the filters.</div>";
                btn.innerText = "üíé GENERATE ACCUMULATORS";
                btn.disabled = false;
                return;
            }
            area.innerHTML = "<div style='text-align:center; padding:40px;'><div class='pilot-dot' style='width:20px; height:20px; margin:0 auto; background:var(--gold); animation:pulse-gold 1s infinite;'></div><p style='margin-top:20px; color:var(--gold);'>Scanning fixtures with your filters...</p></div>";
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const timeFrom = document.getElementById('accaTimeFrom').value || '00:00';
                const timeTo = document.getElementById('accaTimeTo').value || '23:59';
                
                const res = await fetch(`https://v3.football.api-sports.io/fixtures?date=${today}`, { headers: { "x-rapidapi-key": API_KEY } });
                const data = await res.json();
                trackAPI(1);
                
                let allFixtures = [];
                if (data.response) {
                    allFixtures = data.response.filter(f => {
                        const status = f.fixture.status.short;
                        if (!['NS', 'TBD'].includes(status)) return false;
                        if (accaFilterLeague === 'elite' && !ELITE_IDS.includes(f.league.id)) return false;
                        if (accaFilterLeague === 'custom' && accaFilterCustomLeagues.length > 0 && !accaFilterCustomLeagues.includes(f.league.id)) return false;
                        const koTime = new Date(f.fixture.date);
                        const koStr = koTime.toTimeString().slice(0, 5);
                        if (koStr < timeFrom || koStr > timeTo) return false;
                        return true;
                    });
                }

                const uniqueLeagues = {};
                (data.response || []).filter(f => ['NS', 'TBD'].includes(f.fixture.status.short)).forEach(f => {
                    if (!uniqueLeagues[f.league.id]) uniqueLeagues[f.league.id] = { id: f.league.id, name: f.league.name, country: f.league.country };
                });
                accaAvailableLeagues = Object.values(uniqueLeagues).sort((a, b) => (a.country + a.name).localeCompare(b.country + b.name));
                if (accaFilterLeague === 'custom') populateAccaLeagueList();

                if (allFixtures.length < 2) {
                    area.innerHTML = "<div style='text-align:center; padding:40px; color:#888;'>Not enough matches matching your filters. Try widening your league or time filters.</div>";
                    btn.innerText = "üíé GENERATE ACCUMULATORS";
                    btn.disabled = false;
                    return;
                }

                area.innerHTML = "<div style='text-align:center; padding:40px;'><div class='pilot-dot' style='width:20px; height:20px; margin:0 auto; background:var(--gold); animation:pulse-gold 1s infinite;'></div><p style='margin-top:20px; color:var(--gold);'>Fetching standings & form data for ${allFixtures.length} matches...</p></div>";

                const leagueIds = [...new Set(allFixtures.map(f => f.league.id))];
                const standingsMap = {};
                const batchLeagues = leagueIds.slice(0, 15);
                for (const lid of batchLeagues) {
                    const season = allFixtures.find(f => f.league.id === lid).league.season;
                    const s = await fetchStandingsForLeague(lid, season);
                    if (s) standingsMap[lid] = s;
                    await new Promise(r => setTimeout(r, 150));
                }

                const candidateFixtures = allFixtures.filter(f => standingsMap[f.league.id]);
                if (candidateFixtures.length < 3) {
                    const fallback = allFixtures.slice(0, 20);
                    fallback.forEach(f => { if (!candidateFixtures.includes(f)) candidateFixtures.push(f); });
                }
                const toAnalyze = candidateFixtures.slice(0, 20);

                area.innerHTML = `<div style='text-align:center; padding:40px;'><div class='pilot-dot' style='width:20px; height:20px; margin:0 auto; background:var(--gold); animation:pulse-gold 1s infinite;'></div><p style='margin-top:20px; color:var(--gold);'>Analyzing form & head-to-head for ${toAnalyze.length} matches...</p></div>`;

                const allScoredTips = [];
                for (const fix of toAnalyze) {
                    const hId = fix.teams.home.id;
                    const aId = fix.teams.away.id;
                    const lid = fix.league.id;
                    const standings = standingsMap[lid] || null;

                    const [homeForm, awayForm] = await Promise.all([
                        fetchTeamForm(hId),
                        fetchTeamForm(aId)
                    ]);

                    let h2hData = null;
                    try {
                        trackAPI(1);
                        const h2hRes = await fetch(`https://v3.football.api-sports.io/fixtures/headtohead?h2h=${hId}-${aId}&last=5`, { headers: { "x-rapidapi-key": API_KEY } });
                        h2hData = await h2hRes.json();
                    } catch(e) {}
                    const h2h = analyzeH2H(h2hData, hId);

                    const homeDef = analyzeDefensiveStrength(standings, hId);
                    const awayDef = analyzeDefensiveStrength(standings, aId);

                    let homePos = null, awayPos = null, totalTeams = 0;
                    if (standings) {
                        const hTeam = standings.find(t => t.team.id === hId);
                        const aTeam = standings.find(t => t.team.id === aId);
                        if (hTeam) homePos = hTeam.rank;
                        if (aTeam) awayPos = aTeam.rank;
                        totalTeams = standings.length;
                    }

                    const leagueProfile = getLeagueProfile(lid);
                    const tips = accaScoreMarkets(homeForm, awayForm, homeDef, awayDef, h2h, homePos, awayPos, totalTeams, leagueProfile);

                    const dataQuality = (homeForm ? 1 : 0) + (awayForm ? 1 : 0) + (standings ? 1 : 0) + (h2h && h2h.available ? 1 : 0);

                    tips.forEach(tip => {
                        if (tip.prob >= 0.60 && dataQuality >= 2 && allowedMarkets.includes(tip.market)) {
                            allScoredTips.push({
                                fixture: fix,
                                market: tip.market,
                                prob: tip.prob,
                                odds: tip.odds,
                                reasoning: tip.reasoning,
                                dataQuality,
                                homePos, awayPos, totalTeams,
                                h2hAvail: h2h && h2h.available,
                                homeFormAvail: !!homeForm,
                                awayFormAvail: !!awayForm,
                                standingsAvail: !!standings
                            });
                        }
                    });

                    await new Promise(r => setTimeout(r, 120));
                }

                accaTipPool = allScoredTips.sort((a, b) => b.prob - a.prob);
                accaDiscarded = [];
                accaBigOddsDiscarded = [];

                const minPicks = accaFilterSize === 'auto' ? 2 : accaFilterSize;
                const initial = accaBuildFromPool();
                if (initial.length < minPicks) {
                    area.innerHTML = `<div style='text-align:center; padding:40px; color:#888;'><div style='font-size:2rem; margin-bottom:10px;'>üìä</div><p>Not enough high-confidence picks found.</p><p style='font-size:0.8rem; margin-top:8px;'>Analyzed ${toAnalyze.length} matches but couldn't find ${minPicks}+ selections above 60% probability with sufficient data. Try widening your filters.</p></div>`;
                    btn.innerText = "üíé GENERATE ACCUMULATORS";
                    btn.disabled = false;
                    return;
                }

                accaCurrentPicks = initial;
                accaBigOddsPicks = accaFilterTarget === 0 ? accaBuildBigOdds() : [];
                accaAnalyzedCount = toAnalyze.length;
                accaLeagueCount = leagueIds.length;
                renderAccaCards();

            } catch(e) {
                console.error("Acca Generation Error:", e);
                area.innerHTML = "<div style='color:#da3633; text-align:center;'>Error generating tips. Please try again.</div>";
            }
            btn.innerText = "üíé GENERATE ACCUMULATORS";
            btn.disabled = false;
        }

        function getOrdinal(n) {
            const s = ["th","st","nd","rd"];
            const v = n % 100;
            return s[(v - 20) % 10] || s[v] || s[0];
        }

        function toggleAccaFilters() {
            const panel = document.getElementById('accaFilterPanel');
            const btn = document.getElementById('accaFilterToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                btn.textContent = 'Hide ‚ñ≤';
            } else {
                panel.style.display = 'none';
                btn.textContent = 'Show ‚ñº';
            }
        }

        function accaSetLeaguePreset(preset) {
            accaFilterLeague = preset;
            document.querySelectorAll('.acca-league-preset').forEach(b => {
                const isActive = b.dataset.preset === preset;
                b.style.background = isActive ? 'rgba(56,139,253,0.15)' : '#21262d';
                b.style.borderColor = isActive ? 'var(--blue)' : '#30363d';
                b.style.color = isActive ? 'var(--blue)' : '#888';
                b.style.fontWeight = isActive ? 'bold' : 'normal';
            });
            document.getElementById('accaLeagueCustom').style.display = preset === 'custom' ? 'block' : 'none';
            if (preset === 'custom' && accaAvailableLeagues.length > 0) populateAccaLeagueList();
        }

        function populateAccaLeagueList() {
            const container = document.getElementById('accaLeagueList');
            let html = `<div style="display:flex; gap:6px; margin-bottom:6px; padding-bottom:6px; border-bottom:1px solid #30363d;">
                <button onclick="toggleAllAccaLeagues(true)" style="flex:1; background:rgba(56,139,253,0.15); border:1px solid var(--blue); color:var(--blue); padding:4px 8px; border-radius:6px; font-size:0.68rem; cursor:pointer; font-weight:bold;">Select All</button>
                <button onclick="toggleAllAccaLeagues(false)" style="flex:1; background:rgba(218,54,51,0.15); border:1px solid rgba(218,54,51,0.3); color:var(--red); padding:4px 8px; border-radius:6px; font-size:0.68rem; cursor:pointer; font-weight:bold;">Unselect All</button>
            </div>`;
            accaAvailableLeagues.forEach(lg => {
                const checked = accaFilterCustomLeagues.length === 0 || accaFilterCustomLeagues.includes(lg.id) ? 'checked' : '';
                html += `<label style="display:flex; align-items:center; gap:5px; padding:3px 4px; font-size:0.7rem; color:#ccc; cursor:pointer;"><input type="checkbox" class="acca-league-cb" value="${lg.id}" ${checked} onchange="updateAccaCustomLeagues()"> ${lg.country ? lg.country + ' - ' : ''}${lg.name}</label>`;
            });
            container.innerHTML = html;
        }

        function toggleAllAccaLeagues(selectAll) {
            document.querySelectorAll('.acca-league-cb').forEach(cb => cb.checked = selectAll);
            updateAccaCustomLeagues();
        }

        function updateAccaCustomLeagues() {
            accaFilterCustomLeagues = [...document.querySelectorAll('.acca-league-cb:checked')].map(cb => parseInt(cb.value));
        }

        function setAccaSize(size) {
            accaFilterSize = size;
            document.getElementById('accaSizeLabel').textContent = size === 'auto' ? 'Auto' : size + '-fold';
            document.querySelectorAll('.acca-size-btn').forEach(b => {
                const isActive = b.dataset.size === String(size);
                b.style.background = isActive ? 'rgba(56,139,253,0.15)' : '#21262d';
                b.style.borderColor = isActive ? 'var(--blue)' : '#30363d';
                b.style.color = isActive ? 'var(--blue)' : '#888';
                b.style.fontWeight = isActive ? 'bold' : 'normal';
            });
        }

        function setAccaTarget(target) {
            accaFilterTarget = target;
            document.getElementById('accaTargetLabel').textContent = target === 0 ? 'Any' : target + '+';
            document.querySelectorAll('.acca-target-btn').forEach(b => {
                const isActive = b.dataset.target === String(target);
                b.style.background = isActive ? 'rgba(56,139,253,0.15)' : '#21262d';
                b.style.borderColor = isActive ? 'var(--blue)' : '#30363d';
                b.style.color = isActive ? 'var(--blue)' : '#888';
                b.style.fontWeight = isActive ? 'bold' : 'normal';
            });
        }

        function getAccaMarketFilters() {
            return [...document.querySelectorAll('.acca-market-cb:checked')].map(cb => cb.value);
        }

        function accaBuildFromPool() {
            const usedFixtures = new Set(accaDiscarded.map(d => d.fixtureId));
            const picks = [];
            let maxPicks = 10;
            if (accaFilterSize !== 'auto') {
                maxPicks = accaFilterSize * 2;
            }
            if (accaFilterTarget > 0) {
                maxPicks = 10;
            }
            for (const tip of accaTipPool) {
                const fid = tip.fixture.fixture.id;
                if (!usedFixtures.has(fid)) {
                    picks.push(tip);
                    usedFixtures.add(fid);
                }
                if (picks.length >= maxPicks) break;
            }
            return picks;
        }

        function accaBuildBigOdds() {
            const usedByMain = new Set(accaCurrentPicks.map(p => p.fixture.fixture.id));
            const available = accaTipPool.filter(t => {
                const fid = t.fixture.fixture.id;
                return !accaBigOddsDiscarded.some(d => d.fixtureId === fid);
            });
            const uniqueByFixture = [];
            const seenFids = new Set();
            for (const tip of available) {
                const fid = tip.fixture.fixture.id;
                if (!seenFids.has(fid)) {
                    uniqueByFixture.push(tip);
                    seenFids.add(fid);
                }
            }
            if (uniqueByFixture.length < 2) return [];
            let bestCombo = null;
            let bestDiff = Infinity;
            for (let size = 2; size <= Math.min(8, uniqueByFixture.length); size++) {
                let combo = uniqueByFixture.slice(0, size);
                let odds = combo.reduce((acc, t) => acc * parseFloat(t.odds), 1);
                if (odds >= 10) {
                    let diff = odds - 10;
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestCombo = [...combo];
                    }
                    break;
                }
            }
            if (!bestCombo) {
                let combo = uniqueByFixture.slice(0, Math.min(8, uniqueByFixture.length));
                let odds = combo.reduce((acc, t) => acc * parseFloat(t.odds), 1);
                if (odds >= 8) {
                    bestCombo = combo;
                }
            }
            if (!bestCombo && uniqueByFixture.length >= 3) {
                const higherOdds = [...uniqueByFixture].sort((a, b) => parseFloat(b.odds) - parseFloat(a.odds));
                for (let size = 3; size <= Math.min(8, higherOdds.length); size++) {
                    let combo = higherOdds.slice(0, size);
                    let odds = combo.reduce((acc, t) => acc * parseFloat(t.odds), 1);
                    if (odds >= 10) {
                        bestCombo = combo;
                        break;
                    }
                }
                if (!bestCombo) {
                    bestCombo = higherOdds.slice(0, Math.min(6, higherOdds.length));
                }
            }
            return bestCombo || [];
        }

        function accaDiscardBigOdds(slotIdx) {
            const discarded = accaBigOddsPicks[slotIdx];
            if (!discarded) return;
            const discardedFid = discarded.fixture.fixture.id;
            accaBigOddsDiscarded.push({ fixtureId: discardedFid });

            const usedFids = new Set(accaBigOddsPicks.map(p => p.fixture.fixture.id));
            usedFids.delete(discardedFid);
            accaBigOddsDiscarded.forEach(d => usedFids.add(d.fixtureId));

            let replacement = null;
            const available = [...accaTipPool].sort((a, b) => parseFloat(b.odds) - parseFloat(a.odds));
            for (const tip of available) {
                const fid = tip.fixture.fixture.id;
                if (!usedFids.has(fid)) {
                    replacement = tip;
                    break;
                }
            }

            if (replacement) {
                accaBigOddsPicks[slotIdx] = replacement;
            } else {
                accaBigOddsPicks.splice(slotIdx, 1);
            }
            renderAccaCards();
        }

        function accaDiscardSelection(accaIdx, slotIdx) {
            const folds = accaCurrentPicks.length >= 7 ? [4, 3] : (accaCurrentPicks.length >= 6 ? [3, 3] : [3]);
            let offset = 0;
            for (let i = 0; i < accaIdx; i++) offset += folds[i];
            const globalIdx = offset + slotIdx;
            const discarded = accaCurrentPicks[globalIdx];
            if (!discarded) return;

            const discardedFid = discarded.fixture.fixture.id;
            accaDiscarded.push({ fixtureId: discardedFid });

            const usedFids = new Set(accaCurrentPicks.map(p => p.fixture.fixture.id));
            usedFids.delete(discardedFid);
            accaDiscarded.forEach(d => usedFids.add(d.fixtureId));

            let replacement = null;
            for (const tip of accaTipPool) {
                const fid = tip.fixture.fixture.id;
                if (!usedFids.has(fid)) {
                    replacement = tip;
                    break;
                }
            }

            if (replacement) {
                accaCurrentPicks[globalIdx] = replacement;
            } else {
                accaCurrentPicks.splice(globalIdx, 1);
            }

            renderAccaCards();
        }

        async function scan2ndHalfGoals(btn) {
            btn.innerText = "‚öΩ SCANNING 2ND HALF MATCHES...";
            btn.disabled = true;
            const area = document.getElementById('secondHalfGoalContent');
            area.innerHTML = "<div style='text-align:center; padding:40px;'><div class='pilot-dot' style='width:20px; height:20px; margin:0 auto; background:var(--green); animation:pulse-gold 1s infinite;'></div><p style='margin-top:20px; color:var(--green);'>Fetching live 2nd half matches...</p></div>";

            try {
                const liveRes = await fetch("https://v3.football.api-sports.io/fixtures?live=all", { headers: { "x-rapidapi-key": API_KEY } });
                const liveData = await liveRes.json();
                trackAPI(1);

                const BLACKLIST = ['friendly','club friendly','u19','u20','u21','u23','youth','reserve','women','amateur','esports'];
                let secondHalfMatches = (liveData.response || []).filter(m => {
                    const elapsed = m.fixture.status.elapsed || 0;
                    const status = m.fixture.status.short;
                    if (!['2H','ET','BT'].includes(status) && elapsed < 46) return false;
                    if (elapsed < 46) return false;
                    const ln = (m.league.name || '').toLowerCase();
                    if (BLACKLIST.some(b => ln.includes(b))) return false;
                    return true;
                });

                if (secondHalfMatches.length === 0) {
                    area.innerHTML = "<div style='text-align:center; padding:40px; color:#888;'><div style='font-size:2rem; margin-bottom:10px;'>‚öΩ</div><p>No 2nd half matches currently live.</p><p style='font-size:0.8rem; margin-top:8px;'>Check back when matches are in the second half (46th minute onwards).</p></div>";
                    btn.innerText = "‚öΩ SCAN 2ND HALF MATCHES";
                    btn.disabled = false;
                    return;
                }

                area.innerHTML = `<div style='text-align:center; padding:20px; color:var(--green);'>Analyzing ${secondHalfMatches.length} matches ‚Äî fetching stats, standings, events & form...</div>`;

                const results = [];
                const standingsCache2hg = {};
                const placedBets2hg = getPlacedChallenges().filter(b => b.selection === '2nd Half Goal').map(b => b.fixtureId);

                for (const match of secondHalfMatches) {
                    const fid = match.fixture.id;
                    const lid = match.league.id;
                    const hId = match.teams.home.id;
                    const aId = match.teams.away.id;
                    const elapsed = match.fixture.status.elapsed || 60;
                    const homeGoals = match.goals.home || 0;
                    const awayGoals = match.goals.away || 0;
                    const totalGoals = homeGoals + awayGoals;

                    let hStats = null, aStats = null;
                    try {
                        const statRes = await fetch(`https://v3.football.api-sports.io/fixtures/statistics?fixture=${fid}`, { headers: { "x-rapidapi-key": API_KEY } });
                        const statData = await statRes.json();
                        trackAPI(1);
                        if (statData.response && statData.response.length >= 2) {
                            hStats = statData.response[0].statistics;
                            aStats = statData.response[1].statistics;
                        }
                    } catch(e) {}

                    if (!hStats || !aStats) continue;

                    let events = [];
                    try {
                        const evRes = await fetch(`https://v3.football.api-sports.io/fixtures/events?fixture=${fid}`, { headers: { "x-rapidapi-key": API_KEY } });
                        const evData = await evRes.json();
                        trackAPI(1);
                        if (evData.response) events = evData.response;
                    } catch(e) {}

                    const gs = (arr, type) => {
                        const item = arr.find(s => s.type === type);
                        if (item && item.value !== null && item.value !== undefined) {
                            const v = typeof item.value === 'string' ? parseFloat(item.value) : item.value;
                            return isNaN(v) ? 0 : v;
                        }
                        return 0;
                    };

                    const homeSoT = gs(hStats, "Shots on Goal");
                    const awaySoT = gs(aStats, "Shots on Goal");
                    const homeOffT = gs(hStats, "Shots off Goal");
                    const awayOffT = gs(aStats, "Shots off Goal");
                    const homeTotal = gs(hStats, "Total Shots");
                    const awayTotal = gs(aStats, "Total Shots");
                    const homePoss = gs(hStats, "Ball Possession") || 50;
                    const awayPoss = gs(aStats, "Ball Possession") || 50;
                    const homeDangerous = gs(hStats, "Dangerous Attacks");
                    const awayDangerous = gs(aStats, "Dangerous Attacks");
                    const homeExpG = gs(hStats, "expected_goals");
                    const awayExpG = gs(aStats, "expected_goals");
                    const homeCorners = gs(hStats, "Corner Kicks");
                    const awayCorners = gs(aStats, "Corner Kicks");
                    const homePassAcc = gs(hStats, "Passes %");
                    const awayPassAcc = gs(aStats, "Passes %");
                    const homeBlocked = gs(hStats, "Blocked Shots");
                    const awayBlocked = gs(aStats, "Blocked Shots");
                    const homeGKSaves = gs(hStats, "Goalkeeper Saves");
                    const awayGKSaves = gs(aStats, "Goalkeeper Saves");
                    const homeAttacks = gs(hStats, "Attacks");
                    const awayAttacks = gs(aStats, "Attacks");

                    const totalSoT = homeSoT + awaySoT;
                    const totalShots = homeTotal + awayTotal;
                    const totalDangerous = homeDangerous + awayDangerous;
                    const totalxG = homeExpG + awayExpG;
                    const totalCorners = homeCorners + awayCorners;

                    if (totalShots < 3 && totalSoT < 1) continue;

                    let confidence = 35;
                    const factors = [];

                    const shotPressure = totalSoT * 3.5 + (totalShots - totalSoT) * 1.2 + totalCorners * 1.5;
                    if (shotPressure >= 40) { confidence += 8; factors.push(`High shot pressure (${totalSoT} SoT, ${totalShots} shots)`); }
                    else if (shotPressure >= 25) { confidence += 5; factors.push(`Good shot volume (${totalSoT} SoT, ${totalShots} shots)`); }
                    else if (shotPressure >= 15) { confidence += 2; factors.push(`Moderate activity (${totalSoT} SoT)`); }
                    else { confidence -= 4; factors.push(`Low shot activity (${totalSoT} SoT)`); }

                    if (totalCorners >= 10) { confidence += 4; factors.push(`${totalCorners} corners ‚Äî frequent set pieces`); }
                    else if (totalCorners >= 7) { confidence += 2; factors.push(`${totalCorners} corners`); }

                    if (totalDangerous >= 80) { confidence += 6; factors.push(`Very dangerous (${totalDangerous} attacks)`); }
                    else if (totalDangerous >= 50) { confidence += 3; factors.push(`${totalDangerous} dangerous attacks`); }

                    const possImbalance = Math.abs(homePoss - awayPoss);
                    if (possImbalance >= 20) { confidence += 3; factors.push(`Possession imbalance (${homePoss}%-${awayPoss}%)`); }
                    else if (possImbalance <= 8) { confidence += 1; factors.push(`Even contest (${homePoss}%-${awayPoss}%)`); }

                    if (totalxG > 0) {
                        const xgGap = totalxG - totalGoals;
                        if (xgGap >= 1.5) { confidence += 8; factors.push(`Goals overdue! xG ${totalxG.toFixed(1)} vs ${totalGoals} actual`); }
                        else if (xgGap >= 0.8) { confidence += 5; factors.push(`xG suggests more goals (${totalxG.toFixed(1)} vs ${totalGoals})`); }
                        else if (xgGap >= 0.3) { confidence += 2; factors.push(`xG: ${totalxG.toFixed(1)}`); }
                        else if (xgGap < -0.5) { confidence -= 3; factors.push(`Overperforming xG (${totalxG.toFixed(1)} vs ${totalGoals})`); }
                    }

                    if (totalGoals >= 3) { confidence += 5; factors.push(`High-scoring game already (${totalGoals} goals)`); }
                    else if (totalGoals === 2) { confidence += 3; factors.push(`2 goals scored ‚Äî game is open`); }
                    else if (totalGoals === 1) { confidence += 1; factors.push(`1 goal scored`); }
                    else { confidence -= 2; factors.push(`Still 0-0`); }

                    if (homeGoals === awayGoals && totalGoals > 0) { confidence += 3; factors.push(`Level game ‚Äî both teams pushing`); }
                    const goalDiff = Math.abs(homeGoals - awayGoals);
                    if (goalDiff === 1) { confidence += 2; factors.push(`1-goal margin ‚Äî trailing team chasing`); }
                    if (goalDiff >= 3) { confidence -= 4; factors.push(`Comfortable lead ‚Äî game may settle`); }

                    const timeRemaining = 90 - elapsed;
                    if (timeRemaining >= 35) { confidence += 10; factors.push(`${timeRemaining} mins remaining ‚Äî plenty of time for goals (+10%)`); }
                    else if (timeRemaining >= 25) { confidence += 7; factors.push(`${timeRemaining} mins left ‚Äî good window for goals (+7%)`); }
                    else if (timeRemaining >= 15) { confidence += 4; factors.push(`${timeRemaining} mins remaining (+4%)`); }
                    else if (timeRemaining >= 5) { confidence -= 3; factors.push(`Only ${timeRemaining} mins left ‚Äî running out of time (-3%)`); }
                    else { confidence -= 8; factors.push(`Only ${timeRemaining} mins left ‚Äî very little time (-8%)`); }

                    let lateSubs = 0;
                    let attackingSubs = 0;
                    const subEvents = events.filter(e => e.type === 'subst' && (e.time.elapsed || 0) >= 46);
                    lateSubs = subEvents.length;
                    subEvents.forEach(sub => {
                        if (sub.time.elapsed >= 55) attackingSubs++;
                    });
                    if (attackingSubs >= 3) { confidence += 4; factors.push(`${attackingSubs} fresh subs since 55' ‚Äî managers chasing`); }
                    else if (attackingSubs >= 2) { confidence += 3; factors.push(`${attackingSubs} subs after 55' ‚Äî tactical changes`); }
                    else if (lateSubs >= 2) { confidence += 1; factors.push(`${lateSubs} 2nd half substitutions made`); }

                    const goalEvents = events.filter(e => e.type === 'Goal');
                    const firstHalfGoals = goalEvents.filter(e => (e.time.elapsed || 0) <= 45).length;
                    const secondHalfGoals = goalEvents.filter(e => (e.time.elapsed || 0) > 45).length;
                    const recentGoals = goalEvents.filter(e => (e.time.elapsed || 0) >= (elapsed - 15)).length;
                    const earliestGoal = goalEvents.length > 0 ? Math.min(...goalEvents.map(e => e.time.elapsed || 90)) : null;

                    if (firstHalfGoals >= 3) { confidence += 5; factors.push(`${firstHalfGoals} first half goals ‚Äî high-tempo game`); }
                    else if (firstHalfGoals >= 2) { confidence += 4; factors.push(`${firstHalfGoals} first half goals ‚Äî attacking game established`); }

                    if (earliestGoal !== null && earliestGoal <= 15) { confidence += 3; factors.push(`Early goal (${earliestGoal}') ‚Äî game opened up early`); }
                    else if (earliestGoal !== null && earliestGoal <= 30) { confidence += 1; factors.push(`Goal before 30' ‚Äî precedent set`); }

                    if (recentGoals >= 2) { confidence += 5; factors.push(`${recentGoals} goals in last 15 mins ‚Äî game wide open!`); }
                    else if (recentGoals === 1) {
                        const lastGoal = goalEvents.filter(e => (e.time.elapsed || 0) > 45).sort((a, b) => (b.time.elapsed || 0) - (a.time.elapsed || 0))[0];
                        if (lastGoal) {
                            const scorerTeamId = lastGoal.team ? lastGoal.team.id : null;
                            const leadingTeamIsHome = homeGoals > awayGoals;
                            const leadingTeamId = leadingTeamIsHome ? hId : aId;
                            const trailingTeamId = leadingTeamIsHome ? aId : hId;

                            if (homeGoals !== awayGoals && scorerTeamId === trailingTeamId) {
                                confidence += 4; factors.push(`Trailing team just scored ‚Äî comeback energy`);
                            } else if (homeGoals !== awayGoals && scorerTeamId === leadingTeamId && goalDiff >= 2) {
                                confidence -= 3; factors.push(`Leading team extended lead ‚Äî may defend now`);
                            } else if (homeGoals === awayGoals) {
                                confidence += 3; factors.push(`Recent equalizer ‚Äî game reset, both pushing`);
                            } else {
                                confidence += 2; factors.push(`Recent goal ‚Äî momentum shift`);
                            }
                        } else {
                            confidence += 2; factors.push(`Recent goal ‚Äî momentum shift`);
                        }
                    }

                    if (secondHalfGoals > firstHalfGoals && secondHalfGoals >= 1) {
                        confidence += 3; factors.push(`2nd half more open (${secondHalfGoals} vs ${firstHalfGoals} 1H goals)`);
                    } else if (firstHalfGoals >= 2 && secondHalfGoals === 0 && elapsed >= 60) {
                        confidence -= 2; factors.push(`Active 1st half but quiet 2nd half so far`);
                    }

                    if (firstHalfGoals === 0 && secondHalfGoals === 0 && elapsed >= 65) {
                        confidence -= 3; factors.push(`Goalless after 65' ‚Äî tight defensive game`);
                    }

                    const shotRate = totalShots > 0 ? (totalShots / (elapsed / 90)) : 0;
                    const expectedShotRate = 22;
                    if (shotRate >= expectedShotRate * 1.3) { confidence += 3; factors.push(`Above-average shot rate for this stage`); }
                    else if (shotRate <= expectedShotRate * 0.6) { confidence -= 2; factors.push(`Below-average shot rate`); }

                    const totalBlocked = homeBlocked + awayBlocked;
                    if (totalBlocked >= 8) { confidence += 4; factors.push(`${totalBlocked} blocked shots ‚Äî defence under siege, rebound chances`); }
                    else if (totalBlocked >= 5) { confidence += 2; factors.push(`${totalBlocked} blocked shots ‚Äî sustained pressure on defence`); }

                    const totalGKSaves = homeGKSaves + awayGKSaves;
                    if (totalGKSaves >= 8) { confidence += 4; factors.push(`${totalGKSaves} GK saves ‚Äî keepers busy, one will get through`); }
                    else if (totalGKSaves >= 5) { confidence += 2; factors.push(`${totalGKSaves} goalkeeper saves ‚Äî genuine chances being created`); }
                    else if (totalGKSaves <= 1 && totalSoT >= 4) { confidence += 2; factors.push(`${totalSoT} SoT but only ${totalGKSaves} saves ‚Äî shots finding the net`); }

                    const avgPassAcc = (homePassAcc + awayPassAcc) / 2;
                    const passGap = Math.abs(homePassAcc - awayPassAcc);
                    if (avgPassAcc > 0) {
                        if (avgPassAcc <= 70) { confidence += 2; factors.push(`Loose passing (avg ${Math.round(avgPassAcc)}%) ‚Äî turnovers create counter-attack chances`); }
                        if (passGap >= 15) {
                            const dominantTeam = homePassAcc > awayPassAcc ? match.teams.home.name : match.teams.away.name;
                            confidence += 2; factors.push(`${dominantTeam} dominating possession quality (${Math.round(homePassAcc)}% vs ${Math.round(awayPassAcc)}%)`);
                        }
                    }

                    const totalAttacks = homeAttacks + awayAttacks;
                    if (totalAttacks > 0 && totalDangerous > 0) {
                        const dangerRatio = totalDangerous / totalAttacks;
                        if (dangerRatio >= 0.45) { confidence += 3; factors.push(`High danger ratio (${Math.round(dangerRatio * 100)}% of attacks are dangerous)`); }
                        else if (dangerRatio <= 0.25 && totalAttacks >= 80) { confidence -= 2; factors.push(`Low danger ratio ‚Äî lots of attacks but few threatening`); }
                    }

                    if (firstHalfGoals === 0 && totalSoT >= 6 && totalShots >= 14) {
                        confidence += 4; factors.push(`0-0 at HT but ${totalSoT} SoT & ${totalShots} shots ‚Äî dam about to burst`);
                    }

                    const combinedShotAccuracy = totalShots > 0 ? (totalSoT / totalShots) : 0;
                    if (combinedShotAccuracy >= 0.50 && totalSoT >= 6) { confidence += 3; factors.push(`Clinical finishing (${Math.round(combinedShotAccuracy * 100)}% accuracy) ‚Äî shots on target are landing`); }
                    else if (combinedShotAccuracy <= 0.25 && totalShots >= 12) { confidence += 1; factors.push(`Wasteful shooting (${Math.round(combinedShotAccuracy * 100)}% accuracy) ‚Äî but high volume creates chances`); }

                    const yellowCards = events.filter(e => e.type === 'Card' && e.detail === 'Yellow Card');
                    const redCards = events.filter(e => e.type === 'Card' && (e.detail === 'Red Card' || e.detail === 'Second Yellow card'));
                    const homeYellows = yellowCards.filter(e => e.team && e.team.id === hId).length;
                    const awayYellows = yellowCards.filter(e => e.team && e.team.id === aId).length;
                    const homeReds = redCards.filter(e => e.team && e.team.id === hId).length;
                    const awayReds = redCards.filter(e => e.team && e.team.id === aId).length;
                    const totalYellows = homeYellows + awayYellows;
                    const totalReds = homeReds + awayReds;

                    if (totalReds >= 1) {
                        const redTeamIsHome = homeReds > awayReds;
                        const redTeamLeading = redTeamIsHome ? (homeGoals > awayGoals) : (awayGoals > homeGoals);
                        if (redTeamLeading) {
                            confidence += 5; factors.push(`üü• Red card on leading team (${homeReds}H/${awayReds}A) ‚Äî 10 men defending, pressure coming`);
                        } else if (homeGoals === awayGoals) {
                            confidence += 3; factors.push(`üü• Red card (${homeReds}H/${awayReds}A) ‚Äî numerical advantage creates chances`);
                        } else {
                            confidence += 1; factors.push(`üü• Red card on trailing team ‚Äî may struggle to score but game opens`);
                        }
                        if (totalReds >= 2) { confidence += 3; factors.push(`Multiple red cards ‚Äî chaotic game, goals likely`); }
                    }

                    if (totalYellows >= 6) {
                        confidence += 3; factors.push(`üü® ${totalYellows} yellows ‚Äî heated game, defensive caution rising`);
                    } else if (totalYellows >= 4) {
                        confidence += 1; factors.push(`üü® ${totalYellows} yellow cards ‚Äî physical match`);
                    }

                    const homeFouls = gs(hStats, "Fouls");
                    const awayFouls = gs(aStats, "Fouls");
                    const totalFouls = homeFouls + awayFouls;
                    if (totalFouls >= 25) {
                        confidence += 3; factors.push(`${totalFouls} fouls ‚Äî scrappy game, set pieces & free kicks in dangerous areas`);
                    } else if (totalFouls >= 18) {
                        confidence += 1; factors.push(`${totalFouls} fouls ‚Äî physical contest`);
                    }

                    const bookingsOn2ndHalf = yellowCards.filter(e => (e.time.elapsed || 0) > 45);
                    const recentBookings = bookingsOn2ndHalf.filter(e => (e.time.elapsed || 0) >= (elapsed - 15)).length;
                    if (recentBookings >= 2) {
                        confidence += 2; factors.push(`${recentBookings} bookings in last 15 mins ‚Äî defenders getting stretched`);
                    }

                    if (totalYellows >= 3 && goalDiff <= 1) {
                        const defYellowsHome = yellowCards.filter(e => e.team && e.team.id === hId).length;
                        const defYellowsAway = yellowCards.filter(e => e.team && e.team.id === aId).length;
                        if (defYellowsHome >= 2 && homeGoals <= awayGoals) {
                            confidence += 2; factors.push(`Home defense on thin ice (${defYellowsHome} yellows) ‚Äî cautious tackling`);
                        }
                        if (defYellowsAway >= 2 && awayGoals <= homeGoals) {
                            confidence += 2; factors.push(`Away defense on thin ice (${defYellowsAway} yellows) ‚Äî can't tackle freely`);
                        }
                    }

                    let standings = null;
                    if (!standingsCache2hg[lid]) {
                        try {
                            const season = new Date().getFullYear();
                            const stRes = await fetch(`https://v3.football.api-sports.io/standings?league=${lid}&season=${season > 6 ? season : season - 1}`, { headers: { "x-rapidapi-key": API_KEY } });
                            const stData = await stRes.json();
                            trackAPI(1);
                            if (stData.response && stData.response[0] && stData.response[0].league && stData.response[0].league.standings) {
                                standingsCache2hg[lid] = stData.response[0].league.standings[0] || [];
                            }
                        } catch(e) {}
                    }
                    standings = standingsCache2hg[lid] || null;

                    let homePos = null, awayPos = null, totalTeams = 0;
                    if (standings) {
                        const hTeam = standings.find(t => t.team.id === hId);
                        const aTeam = standings.find(t => t.team.id === aId);
                        if (hTeam) homePos = hTeam.rank;
                        if (aTeam) awayPos = aTeam.rank;
                        totalTeams = standings.length;

                        if (homePos && awayPos) {
                            const avgPos = (homePos + awayPos) / 2;
                            const topHalf = totalTeams / 2;
                            if (avgPos <= topHalf * 0.5) { confidence += 4; factors.push(`Top teams (${homePos}${getOrdinal(homePos)} vs ${awayPos}${getOrdinal(awayPos)})`); }
                            else if (avgPos <= topHalf) { confidence += 2; factors.push(`Upper half teams (${homePos}${getOrdinal(homePos)} vs ${awayPos}${getOrdinal(awayPos)})`); }

                            const posDiff = Math.abs(homePos - awayPos);
                            if (posDiff >= totalTeams * 0.5) { confidence += 2; factors.push(`Big quality gap ‚Äî mismatch potential`); }
                        }

                        const homeDef = analyzeDefensiveStrength(standings, hId);
                        const awayDef = analyzeDefensiveStrength(standings, aId);
                        if (homeDef && awayDef) {
                            if (homeDef.rating === 'leaky' || awayDef.rating === 'leaky') { confidence += 3; factors.push(`Leaky defense in play`); }
                            if (homeDef.rating === 'fortress' && awayDef.rating === 'fortress') { confidence -= 4; factors.push(`Both teams defend well`); }
                        }

                        if (homePos && awayPos && goalDiff >= 1 && secondHalfGoals >= 1) {
                            const leadingTeamIsHome = homeGoals > awayGoals;
                            const leadingPos = leadingTeamIsHome ? homePos : awayPos;
                            const trailingPos = leadingTeamIsHome ? awayPos : homePos;
                            const leadingIsAtHome = leadingTeamIsHome;
                            const bottomThird = totalTeams * 0.66;
                            const topThird = totalTeams * 0.33;

                            if (leadingIsAtHome && leadingPos <= topThird && goalDiff >= 2) {
                                confidence -= 4; factors.push(`Strong home team leading by ${goalDiff} ‚Äî likely to manage the game`);
                            } else if (leadingIsAtHome && goalDiff === 1 && leadingPos <= topThird) {
                                confidence -= 2; factors.push(`Home team leading ‚Äî may control tempo`);
                            } else if (!leadingIsAtHome && goalDiff >= 2) {
                                confidence -= 3; factors.push(`Away team comfortable ‚Äî may sit deep`);
                            } else if (!leadingIsAtHome && goalDiff === 1 && trailingPos <= topThird) {
                                confidence += 2; factors.push(`Strong home team trailing ‚Äî expect late push`);
                            }

                            if (trailingPos >= bottomThird && goalDiff >= 2) {
                                confidence -= 2; factors.push(`Weaker team losing badly ‚Äî may accept defeat`);
                            } else if (trailingPos <= topThird && goalDiff === 1) {
                                confidence += 2; factors.push(`Quality team chasing ‚Äî likely to create chances`);
                            }

                            const leadDef = leadingTeamIsHome ? homeDef : awayDef;
                            if (leadDef && leadDef.rating === 'fortress' && goalDiff >= 1) {
                                confidence -= 3; factors.push(`Leading team has strong defense ‚Äî hard to break down`);
                            } else if (leadDef && leadDef.rating === 'leaky') {
                                confidence += 2; factors.push(`Leading team leaks goals ‚Äî deficit recoverable`);
                            }
                        }
                    }

                    let h2hData = null;
                    try {
                        const h2hRes = await fetch(`https://v3.football.api-sports.io/fixtures/headtohead?h2h=${hId}-${aId}&last=5`, { headers: { "x-rapidapi-key": API_KEY } });
                        h2hData = await h2hRes.json();
                        trackAPI(1);
                    } catch(e) {}
                    const h2h = analyzeH2H(h2hData, hId);
                    if (h2h && h2h.available) {
                        if (h2h.avgGoals >= 3.5) { confidence += 5; factors.push(`H2H avg ${h2h.avgGoals.toFixed(1)} goals/game`); }
                        else if (h2h.avgGoals >= 2.5) { confidence += 3; factors.push(`H2H avg ${h2h.avgGoals.toFixed(1)} goals`); }
                        else if (h2h.avgGoals < 1.5) { confidence -= 3; factors.push(`H2H avg only ${h2h.avgGoals.toFixed(1)} goals`); }

                        if (h2h.bttsRate >= 0.6) { confidence += 2; factors.push(`H2H BTTS rate ${Math.round(h2h.bttsRate * 100)}%`); }
                    }

                    const leagueProfile = getLeagueProfile(lid);
                    if (leagueProfile) {
                        if (leagueProfile.avgGoals >= 3.0) { confidence += 3; factors.push(`High-scoring league (avg ${leagueProfile.avgGoals})`); }
                        else if (leagueProfile.avgGoals <= 2.2) { confidence -= 2; factors.push(`Low-scoring league`); }
                        if (leagueProfile.lateGoalRate >= 0.35) { confidence += 2; factors.push(`League known for late goals`); }
                    }

                    confidence = Math.min(96, Math.max(15, confidence));

                    results.push({
                        match,
                        confidence,
                        factors,
                        stats: { homeSoT, awaySoT, homeOffT, awayOffT, homeTotal, awayTotal, homePoss, awayPoss, homeDangerous, awayDangerous, homeExpG, awayExpG, totalxG, totalCorners, homeBlocked, awayBlocked, homeGKSaves, awayGKSaves, homePassAcc, awayPassAcc, homeFouls: gs(hStats, "Fouls"), awayFouls: gs(aStats, "Fouls"), totalYellows: yellowCards.length, totalReds: redCards.length },
                        homePos, awayPos, totalTeams,
                        h2hAvail: h2h && h2h.available,
                        standingsAvail: !!standings,
                        elapsed, homeGoals, awayGoals, totalGoals,
                        lateSubs, recentGoals
                    });

                    await new Promise(r => setTimeout(r, 100));
                }

                results.sort((a, b) => b.confidence - a.confidence);

                if (results.length === 0) {
                    area.innerHTML = "<div style='text-align:center; padding:40px; color:#888;'><div style='font-size:2rem; margin-bottom:10px;'>‚öΩ</div><p>No 2nd half matches with enough stats to analyze.</p><p style='font-size:0.8rem; margin-top:8px;'>Matches need basic shot/possession data available.</p></div>";
                    btn.innerText = "‚öΩ SCAN 2ND HALF MATCHES";
                    btn.disabled = false;
                    return;
                }

                let html = `<div style="text-align:center; padding:6px; margin-bottom:10px; color:#888; font-size:0.75rem;">‚öΩ ${results.length} match${results.length !== 1 ? 'es' : ''} analyzed ¬∑ Sorted by goal confidence</div>`;

                results.forEach(r => {
                    const m = r.match;
                    const fid = m.fixture.id;
                    const confColor = r.confidence >= 80 ? 'var(--green)' : (r.confidence >= 65 ? 'var(--cyan)' : (r.confidence >= 50 ? 'var(--gold)' : 'var(--red)'));
                    const confLabel = r.confidence >= 80 ? 'VERY LIKELY' : (r.confidence >= 65 ? 'LIKELY' : (r.confidence >= 50 ? 'POSSIBLE' : 'UNLIKELY'));
                    const timeRemaining = 90 - r.elapsed;
                    const isPlaced = placedBets2hg.includes(fid);

                    const dataBadges = [];
                    if (r.standingsAvail && r.homePos && r.awayPos) dataBadges.push(`üìç ${r.homePos}${getOrdinal(r.homePos)} vs ${r.awayPos}${getOrdinal(r.awayPos)}`);
                    if (r.h2hAvail) dataBadges.push('üîÑ H2H');
                    if (r.lateSubs > 0) dataBadges.push(`üîÑ ${r.lateSubs} subs`);
                    dataBadges.push(`‚è± ${timeRemaining} min left`);

                    const barWidth = Math.min(100, r.confidence);
                    const barColor = r.confidence >= 80 ? '#2ea043' : (r.confidence >= 65 ? '#58a6ff' : (r.confidence >= 50 ? '#d29922' : '#da3633'));

                    html += `
                        <div class="match-card" style="border-left:4px solid ${confColor};">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                                <div style="font-size:0.7rem; color:#888;">${m.league.name} ${m.league.country ? '¬∑ ' + m.league.country : ''}</div>
                                <div style="font-size:0.7rem; color:${confColor}; font-weight:bold;">${r.elapsed}'</div>
                            </div>
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                                <div style="font-weight:bold; font-size:1rem;">${m.teams.home.name} vs ${m.teams.away.name}</div>
                                <div style="font-size:1.2rem; font-weight:bold; color:var(--gold);">${r.homeGoals} - ${r.awayGoals}</div>
                            </div>

                            <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                                <div style="flex:1; background:#21262d; border-radius:6px; height:8px; overflow:hidden;">
                                    <div style="width:${barWidth}%; height:100%; background:${barColor}; border-radius:6px; transition:width 0.3s;"></div>
                                </div>
                                <div style="font-size:0.9rem; font-weight:bold; color:${confColor}; min-width:45px; text-align:right;">${r.confidence}%</div>
                            </div>
                            <div style="text-align:center; font-size:0.7rem; font-weight:bold; color:${confColor}; margin-bottom:10px; text-transform:uppercase;">${confLabel} ‚Äî Another Goal</div>

                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-bottom:10px;">
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Shots on Target</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homeSoT} - ${r.stats.awaySoT}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Total Shots</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homeTotal} - ${r.stats.awayTotal}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Possession</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homePoss}% - ${r.stats.awayPoss}%</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">xG</span>
                                    <div style="font-weight:bold; color:${r.stats.totalxG > r.totalGoals ? 'var(--green)' : 'var(--gold)'};">${r.stats.homeExpG > 0 ? r.stats.homeExpG.toFixed(1) + ' - ' + r.stats.awayExpG.toFixed(1) : 'N/A'}</div>
                                </div>
                                ${r.stats.homeDangerous > 0 ? `
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Dangerous Attacks</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homeDangerous} - ${r.stats.awayDangerous}</div>
                                </div>` : ''}
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Corners</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.totalCorners}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">GK Saves</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homeGKSaves} - ${r.stats.awayGKSaves}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Blocked Shots</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homeBlocked} - ${r.stats.awayBlocked}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Fouls</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homeFouls} - ${r.stats.awayFouls}</div>
                                </div>
                                <div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Cards</span>
                                    <div style="font-weight:bold; color:${r.stats.totalReds > 0 ? 'var(--red)' : (r.stats.totalYellows >= 4 ? 'var(--gold)' : 'var(--cyan)')};">üü®${r.stats.totalYellows} ${r.stats.totalReds > 0 ? 'üü•' + r.stats.totalReds : ''}</div>
                                </div>
                                ${r.stats.homePassAcc > 0 ? `<div style="background:rgba(255,255,255,0.04); padding:6px 8px; border-radius:6px; font-size:0.7rem;">
                                    <span style="color:#888;">Pass Accuracy</span>
                                    <div style="font-weight:bold; color:var(--cyan);">${r.stats.homePassAcc}% - ${r.stats.awayPassAcc}%</div>
                                </div>` : ''}
                            </div>

                            <div style="background:rgba(255,255,255,0.03); border-radius:8px; padding:8px; margin-bottom:10px;">
                                <div style="font-size:0.68rem; color:#888; margin-bottom:4px; font-weight:bold;">KEY FACTORS</div>
                                ${r.factors.map(f => `<div style="font-size:0.7rem; color:#ccc; padding:2px 0;">‚Ä¢ ${f}</div>`).join('')}
                            </div>

                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                                <div style="font-size:0.65rem; color:#555;">${dataBadges.join(' ¬∑ ')}</div>
                            </div>

                            ${isPlaced ?
                                `<button disabled style="width:100%; padding:10px; border-radius:8px; border:1px solid var(--gold); background:rgba(210,153,34,0.15); color:var(--gold); font-size:0.8rem; font-weight:bold; cursor:default;">üìå Bet Placed ‚Äî Tracking</button>` :
                                `<button onclick="placeChallengebet(${fid}, '2nd Half Goal', '${m.teams.home.name.replace(/'/g,"\\'")} vs ${m.teams.away.name.replace(/'/g,"\\'")}', '${(m.league.name || '').replace(/'/g,"\\'")}', '1.50', 'est', ${r.homeGoals}, ${r.awayGoals}, ${r.confidence}, ${m.league.id || 0}); startChallengeCheckInterval(); this.disabled=true; this.innerHTML='üìå Bet Placed ‚Äî Tracking'; this.style.borderColor='var(--gold)'; this.style.background='rgba(210,153,34,0.15)'; this.style.color='var(--gold)';" style="width:100%; padding:10px; border-radius:8px; border:1px solid var(--green); background:rgba(46,160,67,0.1); color:var(--green); font-size:0.8rem; font-weight:bold; cursor:pointer;">üìå Bet Placed</button>`
                            }
                        </div>
                    `;
                });

                area.innerHTML = html;

            } catch(e) {
                console.error("2nd Half Goal Scan Error:", e);
                area.innerHTML = "<div style='color:#da3633; text-align:center;'>Error scanning matches. Please try again.</div>";
            }
            btn.innerText = "‚öΩ SCAN 2ND HALF MATCHES";
            btn.disabled = false;
        }

        const BOTD_LEAGUES = [
            { id: 39, name: 'Premier League', country: 'England', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø' },
            { id: 40, name: 'Championship', country: 'England', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø' },
            { id: 140, name: 'La Liga', country: 'Spain', flag: 'üá™üá∏' },
            { id: 61, name: 'Ligue 1', country: 'France', flag: 'üá´üá∑' },
            { id: 78, name: 'Bundesliga', country: 'Germany', flag: 'üá©üá™' },
            { id: 135, name: 'Serie A', country: 'Italy', flag: 'üáÆüáπ' },
            { id: 179, name: 'Premiership', country: 'Scotland', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø' },
            { id: 2, name: 'Champions League', country: 'Europe', flag: 'üèÜ' },
            { id: 3, name: 'Europa League', country: 'Europe', flag: 'üèÜ' },
            { id: 848, name: 'Conference League', country: 'Europe', flag: 'üèÜ' },
            { id: 45, name: 'FA Cup', country: 'England', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø' },
            { id: 48, name: 'League Cup', country: 'England', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø' },
            { id: 143, name: 'Copa del Rey', country: 'Spain', flag: 'üá™üá∏' },
            { id: 65, name: 'Coupe de France', country: 'France', flag: 'üá´üá∑' },
            { id: 81, name: 'DFB Pokal', country: 'Germany', flag: 'üá©üá™' },
            { id: 137, name: 'Coppa Italia', country: 'Italy', flag: 'üáÆüáπ' }
        ];

        async function scanBetOfTheDay(btn) {
            btn.innerText = "üîç ANALYZING FIXTURES...";
            btn.disabled = true;
            const area = document.getElementById('botdContent');
            area.innerHTML = "<div style='text-align:center; padding:40px;'><div class='pilot-dot' style='width:20px; height:20px; margin:0 auto; background:var(--gold); animation:pulse-gold 1s infinite;'></div><p style='margin-top:20px; color:var(--gold);'>Fetching today's fixtures from 6 major leagues...</p></div>";

            try {
                const today = new Date().toISOString().split('T')[0];
                const season = new Date().getMonth() >= 6 ? new Date().getFullYear() : new Date().getFullYear() - 1;

                trackAPI(1);
                const res = await fetch(`https://v3.football.api-sports.io/fixtures?date=${today}`, { headers: { "x-rapidapi-key": API_KEY } });
                const data = await res.json();

                if (!data.response || data.response.length === 0) {
                    area.innerHTML = "<div style='text-align:center; padding:40px; color:#888;'>No fixtures found for today.</div>";
                    btn.innerText = "üèÜ FIND TODAY'S BEST BETS";
                    btn.disabled = false;
                    return;
                }

                const botdLeagueIds = BOTD_LEAGUES.map(l => l.id);
                const todayFixtures = data.response.filter(f => botdLeagueIds.includes(f.league.id) && ['NS', 'TBD'].includes(f.fixture.status.short));

                if (todayFixtures.length === 0) {
                    area.innerHTML = "<div style='text-align:center; padding:40px; color:#888;'><div style='font-size:2rem; margin-bottom:10px;'>üèÜ</div><p>No upcoming matches in the big 6 leagues today.</p><p style='font-size:0.75rem; color:#555; margin-top:8px;'>Check back on match days!</p></div>";
                    btn.innerText = "üèÜ FIND TODAY'S BEST BETS";
                    btn.disabled = false;
                    return;
                }

                const leagueFixtures = {};
                todayFixtures.forEach(f => {
                    if (!leagueFixtures[f.league.id]) leagueFixtures[f.league.id] = [];
                    leagueFixtures[f.league.id].push(f);
                });

                area.innerHTML = `<div style='text-align:center; padding:20px; color:var(--gold);'>Analyzing ${todayFixtures.length} matches across ${Object.keys(leagueFixtures).length} leagues...</div>`;

                const bestPicks = [];
                const placedBotd = getPlacedChallenges().filter(b => b.source === 'BOTD').map(b => b.fixtureId + '_' + b.selection);

                for (const league of BOTD_LEAGUES) {
                    const fixtures = leagueFixtures[league.id];
                    if (!fixtures || fixtures.length === 0) continue;

                    let standingsData = null;
                    try {
                        trackAPI(1);
                        const stRes = await fetch(`https://v3.football.api-sports.io/standings?league=${league.id}&season=${season}`, { headers: { "x-rapidapi-key": API_KEY } });
                        const stData = await stRes.json();
                        if (stData.response && stData.response[0]) standingsData = stData.response[0].league.standings[0];
                    } catch(e) {}

                    let leagueBest = null;

                    for (const fix of fixtures) {
                        const hId = fix.teams.home.id;
                        const aId = fix.teams.away.id;
                        const hName = fix.teams.home.name;
                        const aName = fix.teams.away.name;

                        let homeForm = null, awayForm = null, h2h = null;
                        try {
                            [homeForm, awayForm] = await Promise.all([fetchTeamForm(hId), fetchTeamForm(aId)]);
                        } catch(e) {}

                        try {
                            trackAPI(1);
                            const h2hRes = await fetch(`https://v3.football.api-sports.io/fixtures/headtohead?h2h=${hId}-${aId}&last=10`, { headers: { "x-rapidapi-key": API_KEY } });
                            const h2hData = await h2hRes.json();
                            if (h2hData.response && h2hData.response.length >= 3) {
                                h2h = analyzeH2H(h2hData.response);
                            }
                        } catch(e) {}

                        let homePos = null, awayPos = null, homeGA = null, awayGA = null, totalTeams = 20;
                        if (standingsData) {
                            const hSt = standingsData.find(s => s.team.id === hId);
                            const aSt = standingsData.find(s => s.team.id === aId);
                            if (hSt) { homePos = hSt.rank; homeGA = hSt.all.goals.against; }
                            if (aSt) { awayPos = aSt.rank; awayGA = aSt.all.goals.against; }
                            totalTeams = standingsData.length;
                        }

                        const homeDef = standingsData ? analyzeDefensiveStrength(standingsData, hId) : null;
                        const awayDef = standingsData ? analyzeDefensiveStrength(standingsData, aId) : null;
                        const leagueProfile = getLeagueProfile(league.id);

                        const markets = [];

                        const homeAvgScored = homeForm ? homeForm.avgScored : (leagueProfile ? leagueProfile.avgGoals / 2 : 1.3);
                        const awayAvgScored = awayForm ? awayForm.avgScored : (leagueProfile ? leagueProfile.avgGoals / 2 : 1.1);
                        const homeAvgConceded = homeForm ? homeForm.avgConceded : 1.1;
                        const awayAvgConceded = awayForm ? awayForm.avgConceded : 1.3;
                        const combinedAvg = homeAvgScored + awayAvgScored;
                        const homeHomeAvg = homeForm && homeForm.homeAvgScored ? homeForm.homeAvgScored : homeAvgScored;
                        const awayAwayAvg = awayForm && awayForm.awayAvgScored ? awayForm.awayAvgScored : awayAvgScored;

                        let o15Prob = 50;
                        if (combinedAvg >= 3.0) o15Prob += 15;
                        else if (combinedAvg >= 2.5) o15Prob += 10;
                        else if (combinedAvg >= 2.0) o15Prob += 5;
                        if (homeForm && homeForm.overRate > 0.6) o15Prob += 8;
                        if (awayForm && awayForm.overRate > 0.6) o15Prob += 8;
                        if (h2h && h2h.avgGoals >= 3.0) o15Prob += 8;
                        else if (h2h && h2h.avgGoals >= 2.5) o15Prob += 5;
                        if (awayDef && awayDef.rating === 'leaky') o15Prob += 6;
                        if (homeDef && homeDef.rating === 'leaky') o15Prob += 6;
                        if (awayDef && awayDef.rating === 'fortress') o15Prob -= 8;
                        if (homeDef && homeDef.rating === 'fortress') o15Prob -= 8;
                        o15Prob = Math.min(95, Math.max(20, o15Prob));

                        let o25Prob = 35;
                        if (combinedAvg >= 3.5) o25Prob += 18;
                        else if (combinedAvg >= 3.0) o25Prob += 12;
                        else if (combinedAvg >= 2.5) o25Prob += 6;
                        if (homeForm && homeForm.overRate > 0.6) o25Prob += 8;
                        if (awayForm && awayForm.overRate > 0.6) o25Prob += 8;
                        if (h2h && h2h.avgGoals >= 3.5) o25Prob += 10;
                        else if (h2h && h2h.avgGoals >= 2.5) o25Prob += 5;
                        if (awayDef && awayDef.rating === 'leaky') o25Prob += 8;
                        if (homeDef && homeDef.rating === 'leaky') o25Prob += 8;
                        if (awayDef && awayDef.rating === 'fortress') o25Prob -= 10;
                        if (homeDef && homeDef.rating === 'fortress') o25Prob -= 10;
                        o25Prob = Math.min(92, Math.max(15, o25Prob));

                        let bttsPr = 35;
                        if (homeForm && homeForm.bttsRate > 0.5) bttsPr += 10;
                        if (awayForm && awayForm.bttsRate > 0.5) bttsPr += 10;
                        if (homeAvgScored >= 1.3 && awayAvgScored >= 1.0) bttsPr += 8;
                        if (homeAvgConceded >= 1.2 && awayAvgConceded >= 1.2) bttsPr += 8;
                        if (h2h && h2h.bttsRate >= 0.6) bttsPr += 8;
                        if (homeDef && homeDef.rating === 'fortress') bttsPr -= 12;
                        if (awayDef && awayDef.rating === 'fortress') bttsPr -= 12;
                        if (homeForm && homeForm.cleanSheetRate > 0.5) bttsPr -= 8;
                        if (awayForm && awayForm.cleanSheetRate > 0.5) bttsPr -= 8;
                        bttsPr = Math.min(90, Math.max(15, bttsPr));

                        let homeWinProb = 40;
                        if (homePos && awayPos) {
                            const gap = awayPos - homePos;
                            if (gap >= 8) homeWinProb += 15;
                            else if (gap >= 4) homeWinProb += 8;
                            else if (gap <= -8) homeWinProb -= 15;
                            else if (gap <= -4) homeWinProb -= 8;
                        }
                        if (homeHomeAvg >= 2.0) homeWinProb += 8;
                        if (homeForm && homeForm.avgScored > homeForm.avgConceded + 0.5) homeWinProb += 6;
                        if (awayForm && awayForm.avgConceded >= 1.8) homeWinProb += 5;
                        if (h2h && h2h.homeWinRate >= 0.5) homeWinProb += 5;
                        if (awayDef && awayDef.rating === 'leaky') homeWinProb += 5;
                        if (homeDef && homeDef.rating === 'fortress') homeWinProb += 5;
                        homeWinProb = Math.min(90, Math.max(15, homeWinProb));

                        let awayWinProb = 30;
                        if (homePos && awayPos) {
                            const gap = homePos - awayPos;
                            if (gap >= 8) awayWinProb += 15;
                            else if (gap >= 4) awayWinProb += 8;
                            else if (gap <= -8) awayWinProb -= 10;
                            else if (gap <= -4) awayWinProb -= 5;
                        }
                        if (awayAwayAvg >= 1.5) awayWinProb += 8;
                        if (awayForm && awayForm.avgScored > awayForm.avgConceded + 0.5) awayWinProb += 6;
                        if (homeForm && homeForm.avgConceded >= 1.8) awayWinProb += 5;
                        if (h2h && h2h.awayWinRate >= 0.4) awayWinProb += 5;
                        if (homeDef && homeDef.rating === 'leaky') awayWinProb += 5;
                        awayWinProb = Math.min(85, Math.max(10, awayWinProb));

                        const buildReasoning = (market, prob) => {
                            const reasons = [];
                            if (homeForm) reasons.push(`${hName} avg ${homeForm.avgScored.toFixed(1)} scored, ${homeForm.avgConceded.toFixed(1)} conceded`);
                            if (awayForm) reasons.push(`${aName} avg ${awayForm.avgScored.toFixed(1)} scored, ${awayForm.avgConceded.toFixed(1)} conceded`);
                            if (homePos && awayPos) reasons.push(`League positions: ${homePos}${getOrdinal(homePos)} vs ${awayPos}${getOrdinal(awayPos)}`);
                            if (h2h) reasons.push(`H2H avg ${h2h.avgGoals.toFixed(1)} goals, BTTS ${Math.round(h2h.bttsRate * 100)}%`);
                            if (homeDef) reasons.push(`${hName} defence: ${homeDef.rating}`);
                            if (awayDef) reasons.push(`${aName} defence: ${awayDef.rating}`);
                            return reasons;
                        };

                        const dataSources = (homeForm ? 1 : 0) + (awayForm ? 1 : 0) + (standingsData ? 1 : 0) + (h2h ? 1 : 0);

                        if (dataSources >= 2) {
                            markets.push({ market: 'Over 1.5 Goals', prob: o15Prob, reasons: buildReasoning('o15', o15Prob) });
                            markets.push({ market: 'Over 2.5 Goals', prob: o25Prob, reasons: buildReasoning('o25', o25Prob) });
                            markets.push({ market: 'BTTS', prob: bttsPr, reasons: buildReasoning('btts', bttsPr) });
                            markets.push({ market: 'Home Win', prob: homeWinProb, reasons: buildReasoning('hw', homeWinProb) });
                            markets.push({ market: 'Away Win', prob: awayWinProb, reasons: buildReasoning('aw', awayWinProb) });
                        }

                        if (markets.length > 0) {
                            const best = markets.sort((a, b) => b.prob - a.prob)[0];
                            if (!leagueBest || best.prob > leagueBest.prob) {
                                const koTime = new Date(fix.fixture.date);
                                leagueBest = {
                                    fixtureId: fix.fixture.id,
                                    home: hName, away: aName,
                                    homePos, awayPos, totalTeams,
                                    league: league,
                                    market: best.market,
                                    prob: best.prob,
                                    reasons: best.reasons,
                                    kickoff: koTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                                    dataSources,
                                    h2hAvail: !!h2h,
                                    formAvail: !!(homeForm || awayForm),
                                    standingsAvail: !!standingsData
                                };
                            }
                        }

                        await new Promise(r => setTimeout(r, 80));
                    }

                    if (leagueBest) bestPicks.push(leagueBest);
                }

                if (bestPicks.length === 0) {
                    area.innerHTML = "<div style='text-align:center; padding:40px; color:#888;'><div style='font-size:2rem; margin-bottom:10px;'>üèÜ</div><p>Not enough data to pick today's bets. Try again later.</p></div>";
                    btn.innerText = "üèÜ FIND TODAY'S BEST BETS";
                    btn.disabled = false;
                    return;
                }

                bestPicks.sort((a, b) => b.prob - a.prob);

                let html = `<div style="text-align:center; padding:6px; margin-bottom:10px; color:#888; font-size:0.75rem;">üèÜ ${bestPicks.length} league${bestPicks.length !== 1 ? 's' : ''} analyzed ¬∑ Best bet from each</div>`;

                bestPicks.forEach((pick, idx) => {
                    const confColor = pick.prob >= 75 ? 'var(--green)' : (pick.prob >= 60 ? 'var(--cyan)' : (pick.prob >= 50 ? 'var(--gold)' : 'var(--red)'));
                    const barWidth = Math.min(100, pick.prob);
                    const barColor = pick.prob >= 75 ? '#2ea043' : (pick.prob >= 60 ? '#58a6ff' : (pick.prob >= 50 ? '#d29922' : '#da3633'));
                    const isTopPick = idx === 0;
                    const betKey = pick.fixtureId + '_' + pick.market;
                    const isPlaced = placedBotd.includes(betKey);

                    const dataBadges = [];
                    if (pick.formAvail) dataBadges.push('üìä Form');
                    if (pick.standingsAvail && pick.homePos) dataBadges.push(`üìç ${pick.homePos}${getOrdinal(pick.homePos)} vs ${pick.awayPos}${getOrdinal(pick.awayPos)}`);
                    if (pick.h2hAvail) dataBadges.push('üîÑ H2H');
                    dataBadges.push(`üì° ${pick.dataSources} sources`);

                    html += `
                        <div class="match-card" style="border-left:4px solid ${confColor}; ${isTopPick ? 'border:2px solid var(--gold); box-shadow:0 0 15px rgba(210,153,34,0.15);' : ''}">
                            ${isTopPick ? '<div style="text-align:center; font-size:0.7rem; font-weight:bold; color:var(--gold); margin-bottom:8px; text-transform:uppercase; letter-spacing:1px;">‚≠ê TOP PICK OF THE DAY ‚≠ê</div>' : ''}
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                                <div style="font-size:0.7rem; color:#888;">${pick.league.flag} ${pick.league.name} ¬∑ ${pick.league.country}</div>
                                <div style="font-size:0.7rem; color:#888;">KO ${pick.kickoff}</div>
                            </div>
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                                <div style="font-weight:bold; font-size:1rem;">${pick.home} vs ${pick.away}</div>
                            </div>

                            <div style="background:rgba(210,153,34,0.08); border:1px solid rgba(210,153,34,0.2); border-radius:8px; padding:10px; margin-bottom:10px; text-align:center;">
                                <div style="font-size:0.7rem; color:#888; margin-bottom:4px;">BEST BET</div>
                                <div style="font-size:1.2rem; font-weight:bold; color:var(--gold);">${pick.market}</div>
                            </div>

                            <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                                <div style="flex:1; background:#21262d; border-radius:6px; height:8px; overflow:hidden;">
                                    <div style="width:${barWidth}%; height:100%; background:${barColor}; border-radius:6px; transition:width 0.3s;"></div>
                                </div>
                                <div style="font-size:0.9rem; font-weight:bold; color:${confColor}; min-width:45px; text-align:right;">${pick.prob}%</div>
                            </div>

                            <div style="background:rgba(255,255,255,0.03); border-radius:8px; padding:8px; margin-bottom:10px;">
                                <div style="font-size:0.68rem; color:#888; margin-bottom:4px; font-weight:bold;">WHY THIS BET</div>
                                ${pick.reasons.map(r => `<div style="font-size:0.7rem; color:#ccc; padding:2px 0;">‚Ä¢ ${r}</div>`).join('')}
                            </div>

                            <div style="font-size:0.65rem; color:#555; margin-bottom:10px;">${dataBadges.join(' ¬∑ ')}</div>

                            ${isPlaced ?
                                `<button disabled style="width:100%; padding:10px; border-radius:8px; border:1px solid var(--gold); background:rgba(210,153,34,0.15); color:var(--gold); font-size:0.8rem; font-weight:bold; cursor:default;">üìå Bet Placed ‚Äî Tracking</button>` :
                                `<button onclick="placeChallengebet(${pick.fixtureId}, '${pick.market.replace(/'/g,"\\'")}', '${pick.home.replace(/'/g,"\\'")} vs ${pick.away.replace(/'/g,"\\'")}', '${pick.league.name.replace(/'/g,"\\'")}', '1.80', 'est', 0, 0, ${pick.prob}, ${pick.league.id}); startChallengeCheckInterval(); this.disabled=true; this.innerHTML='üìå Bet Placed ‚Äî Tracking'; this.style.borderColor='var(--gold)'; this.style.background='rgba(210,153,34,0.15)'; this.style.color='var(--gold)';" style="width:100%; padding:10px; border-radius:8px; border:1px solid var(--green); background:rgba(46,160,67,0.1); color:var(--green); font-size:0.8rem; font-weight:bold; cursor:pointer;">üìå Bet Placed</button>`
                            }
                        </div>
                    `;
                });

                area.innerHTML = html;

            } catch(e) {
                console.error("BOTD Error:", e);
                area.innerHTML = "<div style='color:#da3633; text-align:center;'>Error analyzing fixtures. Please try again.</div>";
            }
            btn.innerText = "üèÜ FIND TODAY'S BEST BETS";
            btn.disabled = false;
        }

        function renderAccaCards() {
            const area = document.getElementById('accContent');
            const picks = accaCurrentPicks;
            const minRequired = accaFilterSize === 'auto' ? 2 : accaFilterSize;

            if (picks.length < minRequired) {
                area.innerHTML = "<div style='text-align:center; padding:40px; color:#888;'><div style='font-size:2rem; margin-bottom:10px;'>üìä</div><p>Not enough selections remaining. Try generating fresh accumulators.</p></div>";
                return;
            }

            const poolRemaining = accaTipPool.filter(t => {
                const fid = t.fixture.fixture.id;
                return !accaCurrentPicks.some(p => p.fixture.fixture.id === fid) && !accaDiscarded.some(d => d.fixtureId === fid);
            }).length;

            let html = `<div style="text-align:center; padding:8px; margin-bottom:12px; color:#888; font-size:0.75rem;">üìä Analyzed ${accaAnalyzedCount} matches across ${accaLeagueCount} leagues ¬∑ ${poolRemaining} alternative${poolRemaining !== 1 ? 's' : ''} available</div>`;

            let folds;
            if (accaFilterTarget > 0) {
                let combo = [];
                let runningOdds = 1;
                for (const p of picks) {
                    combo.push(p);
                    runningOdds *= parseFloat(p.odds);
                    if (runningOdds >= accaFilterTarget && combo.length >= 2) break;
                }
                folds = [combo.length];
                accaCurrentPicks.length = combo.length;
            } else if (accaFilterSize !== 'auto') {
                const sz = Math.min(accaFilterSize, picks.length);
                folds = [sz];
                if (picks.length >= sz * 2) folds.push(sz);
            } else {
                folds = picks.length >= 7 ? [4, 3] : (picks.length >= 6 ? [3, 3] : [Math.min(3, picks.length)]);
            }
            let tipIdx = 0;

            folds.forEach((foldSize, accaIdx) => {
                const accaTips = picks.slice(tipIdx, tipIdx + foldSize);
                tipIdx += foldSize;
                if (accaTips.length < foldSize) return;

                let totalOdds = 1;
                let combinedProb = 1;
                let itemsHtml = "";

                accaTips.forEach((t, slotIdx) => {
                    const g = t.fixture;
                    totalOdds *= parseFloat(t.odds);
                    combinedProb *= t.prob;
                    const confPct = Math.round(t.prob * 100);
                    const confColor = confPct >= 80 ? 'var(--green)' : (confPct >= 70 ? 'var(--cyan)' : 'var(--gold)');
                    const dataBadges = [];
                    if (t.standingsAvail && t.homePos && t.awayPos) dataBadges.push(`üìç ${t.homePos}${getOrdinal(t.homePos)} vs ${t.awayPos}${getOrdinal(t.awayPos)}`);
                    if (t.h2hAvail) dataBadges.push('üîÑ H2H');
                    if (t.homeFormAvail && t.awayFormAvail) dataBadges.push('üìà Form');
                    const canReplace = poolRemaining > 0;

                    itemsHtml += `
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:8px; margin-bottom:8px; border-left:3px solid ${confColor}; position:relative;">
                            <div style="font-size:0.7rem; color:#888; display:flex; justify-content:space-between;">${g.league.name} ${g.league.country ? '¬∑ ' + g.league.country : ''}<span style="color:${confColor}; font-weight:bold;">${confPct}%</span></div>
                            <div style="display:flex; justify-content:space-between; font-weight:bold; margin-top:3px;">
                                <span>${g.teams.home.name} vs ${g.teams.away.name}</span>
                                <span style="color:var(--gold);">@${t.odds}</span>
                            </div>
                            <div style="font-size:0.8rem; color:var(--cyan); margin-top:4px; font-weight:bold;">üî• ${t.market}</div>
                            <div style="font-size:0.68rem; color:#777; margin-top:3px;">${t.reasoning}</div>
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:4px;">
                                <div style="font-size:0.65rem; color:#555;">${dataBadges.join(' ¬∑ ')}</div>
                                ${canReplace ? `<button onclick="accaDiscardSelection(${accaIdx}, ${slotIdx})" style="background:rgba(218,54,51,0.15); border:1px solid rgba(218,54,51,0.3); color:var(--red); padding:3px 10px; border-radius:6px; font-size:0.65rem; cursor:pointer; font-weight:bold;">üîÑ Replace</button>` : ''}
                            </div>
                        </div>
                    `;
                });

                const accaProb = Math.round(combinedProb * 100);
                const hitsTarget = accaFilterTarget > 0 && totalOdds >= accaFilterTarget;
                const accaBorder = hitsTarget ? 'var(--green)' : 'var(--gold)';
                const accaTitle = accaFilterTarget > 0 ? `${foldSize}-FOLD ¬∑ ${accaFilterTarget}+ ODDS` : `${foldSize}-FOLD ACCA`;
                const targetNote = accaFilterTarget > 0 ? ` ¬∑ Target: ${accaFilterTarget}+ ${hitsTarget ? '‚úÖ' : '‚ö†Ô∏è'}` : '';
                html += `
                    <div class="match-card" style="border: 1px solid ${accaBorder};">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                            <h3 style="margin:0; color:${accaBorder};">${accaTitle}</h3>
                            <div style="background:${accaBorder}; color:#000; padding:2px 8px; border-radius:4px; font-weight:bold;">${totalOdds.toFixed(2)}</div>
                        </div>
                        <div style="font-size:0.7rem; color:#888; margin-bottom:12px;">Combined probability: ${accaProb}%${targetNote}</div>
                        ${itemsHtml}
                        <button class="bet365-btn" style="width:100%; margin-top:10px;">Load into Bet365</button>
                    </div>
                `;
            });

            if (accaBigOddsPicks.length >= 2) {
                let boTotalOdds = 1;
                let boCombinedProb = 1;
                let boItemsHtml = "";

                const boPoolRemaining = accaTipPool.filter(t => {
                    const fid = t.fixture.fixture.id;
                    return !accaBigOddsPicks.some(p => p.fixture.fixture.id === fid) && !accaBigOddsDiscarded.some(d => d.fixtureId === fid);
                }).length;

                accaBigOddsPicks.forEach((t, slotIdx) => {
                    const g = t.fixture;
                    boTotalOdds *= parseFloat(t.odds);
                    boCombinedProb *= t.prob;
                    const confPct = Math.round(t.prob * 100);
                    const confColor = confPct >= 80 ? 'var(--green)' : (confPct >= 70 ? 'var(--cyan)' : 'var(--gold)');
                    const dataBadges = [];
                    if (t.standingsAvail && t.homePos && t.awayPos) dataBadges.push(`üìç ${t.homePos}${getOrdinal(t.homePos)} vs ${t.awayPos}${getOrdinal(t.awayPos)}`);
                    if (t.h2hAvail) dataBadges.push('üîÑ H2H');
                    if (t.homeFormAvail && t.awayFormAvail) dataBadges.push('üìà Form');
                    const canReplace = boPoolRemaining > 0;

                    boItemsHtml += `
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:8px; margin-bottom:8px; border-left:3px solid ${confColor}; position:relative;">
                            <div style="font-size:0.7rem; color:#888; display:flex; justify-content:space-between;">${g.league.name} ${g.league.country ? '¬∑ ' + g.league.country : ''}<span style="color:${confColor}; font-weight:bold;">${confPct}%</span></div>
                            <div style="display:flex; justify-content:space-between; font-weight:bold; margin-top:3px;">
                                <span>${g.teams.home.name} vs ${g.teams.away.name}</span>
                                <span style="color:var(--gold);">@${t.odds}</span>
                            </div>
                            <div style="font-size:0.8rem; color:var(--cyan); margin-top:4px; font-weight:bold;">üî• ${t.market}</div>
                            <div style="font-size:0.68rem; color:#777; margin-top:3px;">${t.reasoning}</div>
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:4px;">
                                <div style="font-size:0.65rem; color:#555;">${dataBadges.join(' ¬∑ ')}</div>
                                ${canReplace ? `<button onclick="accaDiscardBigOdds(${slotIdx})" style="background:rgba(218,54,51,0.15); border:1px solid rgba(218,54,51,0.3); color:var(--red); padding:3px 10px; border-radius:6px; font-size:0.65rem; cursor:pointer; font-weight:bold;">üîÑ Replace</button>` : ''}
                            </div>
                        </div>
                    `;
                });

                const boProb = Math.round(boCombinedProb * 100);
                const oddsColor = boTotalOdds >= 10 ? 'var(--green)' : 'var(--gold)';
                const borderColor = boTotalOdds >= 10 ? 'var(--green)' : 'var(--gold)';
                html += `
                    <div class="match-card" style="border: 1px solid ${borderColor};">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                            <h3 style="margin:0; color:${borderColor};">üé∞ BIG ODDS ACCA</h3>
                            <div style="background:${borderColor}; color:#000; padding:2px 8px; border-radius:4px; font-weight:bold;">${boTotalOdds.toFixed(2)}</div>
                        </div>
                        <div style="font-size:0.7rem; color:#888; margin-bottom:12px;">Target: 10.00+ odds ¬∑ ${accaBigOddsPicks.length} selections ¬∑ Combined probability: ${boProb}%</div>
                        ${boItemsHtml}
                        <button class="bet365-btn" style="width:100%; margin-top:10px;">Load into Bet365</button>
                    </div>
                `;
            }

            area.innerHTML = html;
        }

        function setStrategy(strat, el) {
            const prevStrategy = currentStrategy;
            currentStrategy = strat;
            document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            el.classList.add('active');
            if (prevStrategy === 'challenge' && strat !== 'challenge') {
                stopChallengeAutoRefresh();
            }
            applyFilter();
        }

        function stopChallengeAutoRefresh() {
            if (challengeAutoRefreshInterval) {
                clearInterval(challengeAutoRefreshInterval);
                challengeAutoRefreshInterval = null;
            }
        }

        function startChallengeAutoRefresh() {
            stopChallengeAutoRefresh();
            challengeAutoRefreshInterval = setInterval(() => {
                if (currentStrategy === 'challenge') {
                    scanChallengePicks(true);
                } else {
                    stopChallengeAutoRefresh();
                }
            }, 150000);
        }

        async function fetchLiveOdds(fixtureIds) {
            if (fixtureIds.length === 0) return {};
            try {
                trackAPI(1);
                const res = await fetch(`https://v3.football.api-sports.io/odds/live`, {
                    headers: { "x-rapidapi-key": API_KEY }
                });
                const data = await res.json();
                if (data.response && data.response.length > 0) {
                    const oddsMap = {};
                    data.response.forEach(entry => {
                        const fid = entry.fixture?.id;
                        if (!fid || !fixtureIds.includes(fid)) return;
                        const bet365 = entry.bookmakers?.find(b => b.name === "Bet365" || b.id === 8);
                        const bookie = bet365 || (entry.bookmakers && entry.bookmakers[0]);
                        if (!bookie || !bookie.bets) return;
                        oddsMap[fid] = {};
                        bookie.bets.forEach(bet => {
                            const name = bet.name?.toLowerCase() || "";
                            if (name.includes("over/under") || name.includes("goals over")) {
                                bet.values.forEach(v => {
                                    if (v.value === "Over 0.5") oddsMap[fid]['o05'] = v.odd;
                                    if (v.value === "Over 1.5") oddsMap[fid]['o15'] = v.odd;
                                    if (v.value === "Over 2.5") oddsMap[fid]['o25'] = v.odd;
                                });
                            }
                            if (name.includes("both teams") || name === "btts") {
                                bet.values.forEach(v => {
                                    if (v.value === "Yes") oddsMap[fid]['btts'] = v.odd;
                                });
                            }
                            if (name.includes("next goal") || name.includes("next to score")) {
                                bet.values.forEach(v => {
                                    if (v.value === "Home" || v.value === "1") oddsMap[fid]['next_home'] = v.odd;
                                    if (v.value === "Away" || v.value === "2") oddsMap[fid]['next_away'] = v.odd;
                                });
                            }
                        });
                    });
                    liveOddsCache = { ...liveOddsCache, ...oddsMap };
                    return oddsMap;
                }
            } catch(e) {
                console.warn("Live odds fetch failed:", e);
            }
            return {};
        }

        function getChallengeStreak() {
            try {
                const data = JSON.parse(localStorage.getItem('challengeStreak') || '{}');
                return {
                    currentStreak: data.currentStreak || 0,
                    bestStreak: data.bestStreak || 0,
                    totalWins: data.totalWins || 0,
                    totalBets: data.totalBets || 0,
                    history: data.history || []
                };
            } catch(e) { return { currentStreak: 0, bestStreak: 0, totalWins: 0, totalBets: 0, history: [] }; }
        }

        function saveChallengeStreak(data) {
            localStorage.setItem('challengeStreak', JSON.stringify(data));
        }

        function recordChallengeResult(selection, matchName, won, leagueId, confidence) {
            const streak = getChallengeStreak();
            streak.totalBets++;
            if (won) {
                streak.totalWins++;
                streak.currentStreak++;
                if (streak.currentStreak > streak.bestStreak) streak.bestStreak = streak.currentStreak;
            } else {
                streak.currentStreak = 0;
            }
            streak.history.unshift({ selection, match: matchName, won, time: Date.now() });
            if (streak.history.length > 50) streak.history = streak.history.slice(0, 50);
            saveChallengeStreak(streak);
            if (leagueId) {
                const marketKey = getMarketKey(selection);
                recordMarketOutcome(leagueId, marketKey, won);
            }
            if (confidence) {
                recordConfidenceResult(confidence, won);
            }
        }

        function getPlacedChallenges() {
            try { return JSON.parse(localStorage.getItem('placedChallenges') || '[]'); }
            catch(e) { return []; }
        }
        function savePlacedChallenges(bets) {
            localStorage.setItem('placedChallenges', JSON.stringify(bets));
        }

        function renderPlacedBetsTracker(pendingBets, resolvedBets) {
            let html = `<div style="margin:12px 10px 0; padding:10px 12px; background:rgba(210,153,34,0.06); border:1px solid rgba(210,153,34,0.2); border-radius:10px;">
                <div style="font-size:0.8rem; font-weight:bold; color:var(--gold); margin-bottom:8px;">üìã Placed Bets Tracker</div>`;

            if (pendingBets.length > 0) {
                html += `<div style="margin-bottom:6px;">`;
                pendingBets.forEach(b => {
                    const ago = Math.round((Date.now() - b.placedAt) / 60000);
                    const noteVal = (b.note || '').replace(/"/g, '&quot;');
                    html += `<div style="padding:6px 0; border-bottom:1px solid rgba(255,255,255,0.05);">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <div style="font-size:0.75rem; font-weight:bold; color:#ddd;">${b.selection}</div>
                                <div style="font-size:0.65rem; color:#888;">${b.match} (${b.homeGoalsAtPlace}-${b.awayGoalsAtPlace} when placed)</div>
                            </div>
                            <span style="font-size:0.65rem; padding:3px 8px; border-radius:8px; background:rgba(210,153,34,0.15); color:var(--gold); font-weight:bold;">‚è≥ ${ago}m ago</span>
                        </div>
                        <textarea class="bet-note-input" placeholder="Add a note..." rows="1" onfocus="this.rows=2" onblur="this.rows=1; saveBetNote(${b.fixtureId}, decodeURIComponent('${encodeURIComponent(b.selection)}'), this.value)">${noteVal}</textarea>
                    </div>`;
                });
                html += `</div>`;
            }

            if (resolvedBets.length > 0) {
                const grouped = {};
                resolvedBets.forEach(b => {
                    const d = new Date(b.placedAt).toISOString().split('T')[0];
                    if (!grouped[d]) grouped[d] = [];
                    grouped[d].push(b);
                });
                const sortedDates = Object.keys(grouped).sort((a, b) => b.localeCompare(a));
                const today = new Date().toISOString().split('T')[0];

                sortedDates.forEach(date => {
                    const dayBets = grouped[date];
                    let wins = 0, losses = 0;
                    dayBets.forEach(b => { if (b.result) wins++; else losses++; });
                    const delta = wins - losses;
                    const deltaStr = delta >= 0 ? `+${delta}` : `${delta}`;
                    const deltaColor = delta > 0 ? 'var(--green)' : (delta < 0 ? 'var(--red)' : '#888');
                    const dateLabel = date === today ? 'Today' : date;
                    const uid = 'pbt-' + date.replace(/[^a-z0-9]/gi, '');

                    html += `<div style="border-top:1px solid rgba(255,255,255,0.05);">
                        <div onclick="document.getElementById('${uid}').style.display = document.getElementById('${uid}').style.display === 'none' ? 'block' : 'none'; this.querySelector('.pbt-chev').textContent = document.getElementById('${uid}').style.display === 'none' ? '‚ñ∂' : '‚ñº'" style="padding:8px 0; display:flex; justify-content:space-between; align-items:center; cursor:pointer; user-select:none;">
                            <div style="display:flex; align-items:center; gap:6px;">
                                <span class="pbt-chev" style="color:#888; font-size:0.65rem;">‚ñ∂</span>
                                <span style="color:#ccc; font-weight:bold; font-size:0.8rem;">üìÖ ${dateLabel}</span>
                                <span style="color:#888; font-size:0.7rem;">${dayBets.length} bet${dayBets.length !== 1 ? 's' : ''}</span>
                                <span style="font-size:0.7rem; color:#888;">${wins}W ${losses}L</span>
                            </div>
                            <span style="font-weight:bold; color:${deltaColor}; font-size:0.8rem;">${deltaStr}</span>
                        </div>
                        <div id="${uid}" style="display:none;">`;

                    dayBets.forEach(b => {
                        const wonColor = b.result ? 'var(--green)' : 'var(--red)';
                        const wonIcon = b.result ? '‚úÖ' : '‚ùå';
                        const wonText = b.result ? 'WON' : 'LOST';
                        html += `<div style="display:flex; justify-content:space-between; align-items:center; padding:5px 0 5px 16px; border-top:1px solid rgba(255,255,255,0.03);">
                            <div>
                                <div style="font-size:0.73rem; font-weight:bold; color:#ddd;">${b.selection} @ ${b.odds}</div>
                                <div style="font-size:0.63rem; color:#888;">${b.match} (FT: ${b.finalScore})</div>
                            </div>
                            <span style="font-size:0.65rem; padding:3px 8px; border-radius:8px; background:${b.result ? 'rgba(46,160,67,0.15)' : 'rgba(218,54,51,0.15)'}; color:${wonColor}; font-weight:bold;">${wonIcon} ${wonText}</span>
                        </div>`;
                    });

                    html += `</div></div>`;
                });
            }

            html += `</div>`;
            return html;
        }

        function placeChallengebet(fixtureId, selection, match, league, odds, oddsSource, homeGoals, awayGoals, confidence, leagueId) {
            const bets = getPlacedChallenges();
            if (bets.some(b => b.fixtureId === fixtureId && b.selection === selection)) return;
            const betObj = {
                fixtureId, selection, match, league, odds, oddsSource, confidence,
                homeGoalsAtPlace: homeGoals, awayGoalsAtPlace: awayGoals,
                placedAt: Date.now(), status: 'pending', result: null,
                leagueId: leagueId || null
            };
            bets.push(betObj);
            savePlacedChallenges(bets);
        }

        function resolveChallengeBet(bet, finalHome, finalAway, events) {
            if (bet.status !== 'pending') return bet;
            const sel = bet.selection;
            const totalGoals = finalHome + finalAway;
            let won = false;

            if (sel === 'Over 0.5 Goals') {
                won = totalGoals > 0;
            } else if (sel === 'Over 1.5 Goals') {
                won = totalGoals > 1;
            } else if (sel === 'Over 2.5 Goals') {
                won = totalGoals > 2;
            } else if (sel === 'Over 3.5 Goals') {
                won = totalGoals > 3;
            } else if (sel.startsWith('Anytime Goalscorer:')) {
                const playerName = sel.replace('Anytime Goalscorer: ', '').trim().toLowerCase();
                if (events && events.length > 0) {
                    won = events.some(e => {
                        if (e.type !== 'Goal' || !e.player || !e.player.name) return false;
                        const eventName = e.player.name.toLowerCase();
                        return eventName === playerName || eventName.includes(playerName) || playerName.includes(eventName);
                    });
                } else {
                    won = false;
                }
            } else if (sel.startsWith('Anytime Booking:')) {
                const playerName = sel.replace('Anytime Booking: ', '').trim().toLowerCase();
                if (events && events.length > 0) {
                    won = events.some(e => {
                        if (e.type !== 'Card' || !e.player || !e.player.name) return false;
                        const eventName = e.player.name.toLowerCase();
                        return eventName === playerName || eventName.includes(playerName) || playerName.includes(eventName);
                    });
                } else {
                    won = false;
                }
            } else if (sel === '2nd Half Goal') {
                won = totalGoals > (bet.homeGoalsAtPlace + bet.awayGoalsAtPlace);
            } else if (sel === 'Both Teams to Score') {
                won = finalHome > 0 && finalAway > 0;
            } else if (sel.startsWith('Next Goal:')) {
                const teamName = sel.replace('Next Goal: ', '').trim();
                const matchParts = bet.match.split(' vs ');
                const isHome = matchParts[0].trim() === teamName;
                const goalsAfterHome = finalHome - bet.homeGoalsAtPlace;
                const goalsAfterAway = finalAway - bet.awayGoalsAtPlace;
                if (goalsAfterHome + goalsAfterAway === 0) {
                    won = false;
                } else if (events && events.length > 0) {
                    const goalEvents = events
                        .filter(e => e.type === 'Goal' && e.time && e.time.elapsed)
                        .sort((a, b) => {
                            const tA = (a.time.elapsed || 0) + (a.time.extra || 0);
                            const tB = (b.time.elapsed || 0) + (b.time.extra || 0);
                            return tA - tB;
                        });
                    let hCount = 0, aCount = 0;
                    let nextGoalTeam = null;
                    for (const ge of goalEvents) {
                        const isHomeGoal = ge.team && ge.team.id && matchParts[0].trim() === (ge.team.name || '').trim();
                        if (isHomeGoal) hCount++;
                        else aCount++;
                        if (hCount > bet.homeGoalsAtPlace || aCount > bet.awayGoalsAtPlace) {
                            nextGoalTeam = isHomeGoal ? 'home' : 'away';
                            break;
                        }
                    }
                    won = (isHome && nextGoalTeam === 'home') || (!isHome && nextGoalTeam === 'away');
                } else {
                    if (isHome) won = goalsAfterHome > 0 && (goalsAfterAway === 0 || goalsAfterHome > goalsAfterAway);
                    else won = goalsAfterAway > 0 && (goalsAfterHome === 0 || goalsAfterAway > goalsAfterHome);
                }
            }

            bet.status = 'resolved';
            bet.result = won;
            bet.finalScore = `${finalHome}-${finalAway}`;
            recordChallengeResult(bet.selection, bet.match, won, bet.leagueId, bet.confidence);
            return bet;
        }

        let challengeCheckInterval = null;

        async function checkPlacedChallenges() {
            const bets = getPlacedChallenges();
            const pending = bets.filter(b => b.status === 'pending');
            if (pending.length === 0) {
                stopChallengeCheckInterval();
                return;
            }

            const fixtureIds = [...new Set(pending.map(b => b.fixtureId))].slice(0, 20);
            const idsStr = fixtureIds.join('-');
            try {
                trackAPI(1);
                const res = await fetch(`https://v3.football.api-sports.io/fixtures?ids=${idsStr}`, { headers: { "x-rapidapi-key": API_KEY } });
                const data = await res.json();
                if (!data.response) return;

                let anyResolved = false;
                const resolvedResults = [];
                data.response.forEach(fix => {
                    const status = fix.fixture.status.short;
                    if (['FT', 'AET', 'PEN'].includes(status)) {
                        const fHome = fix.goals.home;
                        const fAway = fix.goals.away;
                        bets.forEach(b => {
                            if (b.fixtureId === fix.fixture.id && b.status === 'pending') {
                                resolveChallengeBet(b, fHome, fAway, fix.events);
                                anyResolved = true;
                                resolvedResults.push({ selection: b.selection, won: b.result, match: b.match });
                            }
                        });
                    }
                });
                resolvedResults.forEach(r => {
                    const icon = r.won ? '‚úÖ' : '‚ùå';
                    const status = r.won ? 'WON' : 'LOST';
                    sendNotification(`${icon} Bet ${status}`, `${r.selection} ‚Äî ${r.match}`, 'tft-result-' + Date.now());
                });

                savePlacedChallenges(bets);
                if (anyResolved && currentStrategy === 'challenge') {
                    scanChallengePicks(true);
                }
                const stillPending = bets.filter(b => b.status === 'pending');
                if (stillPending.length === 0) stopChallengeCheckInterval();
            } catch(e) { console.log('Check placed error:', e); }
        }

        function startChallengeCheckInterval() {
            if (challengeCheckInterval) return;
            challengeCheckInterval = setInterval(checkPlacedChallenges, 120000);
            checkPlacedChallenges();
        }

        function stopChallengeCheckInterval() {
            if (challengeCheckInterval) {
                clearInterval(challengeCheckInterval);
                challengeCheckInterval = null;
            }
        }

        function cleanupOldPlacedBets() {
            const bets = getPlacedChallenges();
            const cutoff = Date.now() - (10 * 24 * 60 * 60 * 1000);
            const kept = bets.filter(b => b.placedAt > cutoff || b.status === 'pending');
            if (kept.length !== bets.length) savePlacedChallenges(kept);
        }

        async function loadSchedule() {
            trackAPI(1);
            const schedDiv = document.getElementById('schedContent');
            schedDiv.innerHTML = "<p style='text-align:center; color:#888; margin-top:50px;'>Loading Elite Fixtures...</p>";
            const localDate = new Date().toLocaleDateString('en-CA'); 
            try {
                const res = await fetch(`https://v3.football.api-sports.io/fixtures?date=${localDate}`, { headers: { "x-rapidapi-key": API_KEY } });
                const data = await res.json();
                const eliteGames = data.response.filter(m => ELITE_IDS.includes(m.league.id));
                eliteGames.sort((a, b) => a.fixture.timestamp - b.fixture.timestamp);

                if(eliteGames.length === 0) { schedDiv.innerHTML = "<p style='text-align:center; color:#888; margin-top:50px;'>No Elite Games Scheduled Today.</p>"; return; }

                let html = "";
                eliteGames.forEach(m => {
                    const date = new Date(m.fixture.timestamp * 1000);
                    const time = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    html += `<div class="sched-card"><div style="text-align:center; margin-right:15px;"><div class="sched-time">${time}</div></div><div class="sched-teams"><div class="sched-league">${m.league.country} ‚Ä¢ ${m.league.name}</div><div>${m.teams.home.name} vs ${m.teams.away.name}</div></div></div>`;
                });
                schedDiv.innerHTML = html;
            } catch(e) { schedDiv.innerHTML = "<p style='text-align:center; color:#da3633;'>Error loading schedule.</p>"; }
        }

        function playPing() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
        }

        function togglePilot() {
            pilotMode = !pilotMode;
            if(pilotMode) {
                // Defensive check for Notification API
                if (typeof Notification !== 'undefined') {
                    if (Notification.permission !== "granted") { 
                        Notification.requestPermission(); 
                    }
                }
                pilotBtn.classList.add('active');
                pilotBtn.innerHTML = `<div class="pilot-dot"></div> ON (2.5m)`;
                playPing(); 
                runScan(true); 
                pilotInterval = setInterval(() => runScan(true), 150000); 
            } else {
                pilotBtn.classList.remove('active');
                pilotBtn.innerHTML = `<div class="pilot-dot"></div> Auto-Pilot`;
                clearInterval(pilotInterval);
            }
        }

        function toggleCardPilot() {
            const btn = document.getElementById('cardPilotBtn');
            if (cardPilotInterval) {
                clearInterval(cardPilotInterval);
                cardPilotInterval = null;
                btn.classList.remove('active');
                btn.innerHTML = `<div class="pilot-dot"></div> Auto-Pilot (30s)`;
            } else {
                const scanBtn = document.querySelector('.card-scan-btn');
                scanGlobalCards(scanBtn);
                cardPilotInterval = setInterval(() => scanGlobalCards(scanBtn), 30000); // 30s
                btn.classList.add('active');
                btn.innerHTML = `<div class="pilot-dot"></div> ON (30s)`;
            }
        }

        let strategyCounts = { all: 0, drought: 0, alert: 0, red: 0, challenge: 0 };
        let challengePicksCache = [];

        function updateBadges() {
            updateChipBadges();
        }

        function updateChipBadges() {
            Object.keys(strategyCounts).forEach(key => {
                if (key === 'challenge') return;
                const badge = document.getElementById(`badge-${key}`);
                if (badge) {
                    badge.innerText = strategyCounts[key];
                    if (strategyCounts[key] > 0) {
                        badge.style.display = 'block';
                        badge.classList.add('active');
                        if (key === 'alert' || key === 'red') badge.classList.add('urgent');
                    } else {
                        badge.style.display = 'none';
                        badge.classList.remove('active', 'urgent');
                    }
                }
            });
        }

        function updateChallengeBadge(count) {
            const badge = document.getElementById('badge-challenge');
            if (badge) {
                if (count > 0) {
                    badge.innerText = count;
                    badge.style.display = 'block';
                    badge.classList.add('active');
                } else {
                    badge.style.display = 'none';
                    badge.classList.remove('active');
                }
            }
        }

        function isAlertMatch(m) {
            const s = m.goals;
            const h = m.teams.home;
            const a = m.teams.away;
            const t = m.fixture.status.elapsed;
            
            // Logic 1: Late game tight score (1 goal diff, 75m+)
            if (Math.abs(s.home - s.away) === 1 && t > 75) return true;
            
            // Logic 2: Favorite chasing in Elite leagues
            if (s.home < s.away && (s.away - s.home === 1) && ELITE_IDS.includes(m.league.id)) return true;
            
            // Logic 3: Chokehold or Siege (requires stats, but we can proxy)
            if (m.events) {
                const recentShots = m.events.filter(e => e.type === 'Goal' || (e.type === 'Card' && e.time.elapsed > t - 10)).length;
                if (recentShots > 2) return true;
            }

            return false;
        }

        function calculateStrategyCounts() {
            const oldCounts = { ...strategyCounts };
            strategyCounts = { all: 0, drought: 0, alert: 0, red: 0, challenge: 0 };
            const mode = document.getElementById('filterSelect').value;
            
            allMatches.forEach(m => {
                const league = (m.league.name || "").toLowerCase();
                const blocked = ["friendly", "friendlies", "club friendlies", "u19", "u20", "u21", "u23", "youth", "reserve", "reserves"];
                if(blocked.some(word => league.includes(word))) return;

                const fid = m.fixture.id;
                const statsStatus = matchStatsMap[fid] || 'limited';
                if (mode === 'full' && statsStatus !== 'full') return;
                if (mode === 'limited' && statsStatus !== 'limited') return;

                strategyCounts.all++;

                // Red Card
                if (m.events && m.events.some(e => e.type === 'Card' && e.detail === 'Red Card')) {
                    strategyCounts.red++;
                }

                // Goal Drought
                if (m.goals.home + m.goals.away > 0 && m.events) {
                    const goalTimes = m.events
                        .filter(e => e.type === 'Goal')
                        .map(e => e.time.elapsed + (e.time.extra || 0));
                    if (goalTimes.length > 0) {
                        const lastGoalTime = Math.max(...goalTimes);
                        const timeSince = m.fixture.status.elapsed - lastGoalTime;
                        if (timeSince > 50) strategyCounts.drought++;
                    }
                }

                // Goal Alert!
                if (isAlertMatch(m)) strategyCounts.alert++;

            });

            let increased = false;
            Object.keys(strategyCounts).forEach(key => {
                if (strategyCounts[key] > oldCounts[key]) increased = true;
            });
            if (increased && pilotMode) {
                if (strategyCounts.red > oldCounts.red) {
                    playAlertSound('card');
                } else if (strategyCounts.alert > oldCounts.alert) {
                    playAlertSound('goal');
                } else if (strategyCounts.drought > oldCounts.drought) {
                    playAlertSound('corner');
                } else {
                    playAlertSound('goal');
                }
            }

            updateChipBadges();
        }

        async function checkStatsAvailability(matches) {
            const blocked = ["friendly", "friendlies", "club friendlies", "u19", "u20", "u21", "u23", "youth", "reserve", "reserves"];
            const validMatches = matches.filter(m => {
                const league = (m.league.name || "").toLowerCase();
                return !blocked.some(word => league.includes(word));
            });

            const unchecked = validMatches.filter(m => !(m.fixture.id in matchStatsMap));
            
            const batchSize = 5;
            for (let i = 0; i < unchecked.length; i += batchSize) {
                const batch = unchecked.slice(i, i + batchSize);
                await Promise.all(batch.map(async m => {
                    const fid = m.fixture.id;
                    try {
                        const res = await fetch(`https://v3.football.api-sports.io/fixtures/statistics?fixture=${fid}`, {
                            headers: { "x-rapidapi-key": API_KEY }
                        });
                        const data = await res.json();
                        if (data.response && data.response.length >= 2) {
                            matchStatsMap[fid] = 'full';
                        } else {
                            const pRes = await fetch(`https://v3.football.api-sports.io/fixtures/players?fixture=${fid}`, {
                                headers: { "x-rapidapi-key": API_KEY }
                            });
                            const pData = await pRes.json();
                            matchStatsMap[fid] = (pData.response && pData.response.length >= 2) ? 'full' : 'limited';
                        }
                    } catch(e) {
                        matchStatsMap[fid] = 'limited';
                    }
                }));
                if (i + batchSize < unchecked.length) await new Promise(r => setTimeout(r, 500));
            }
        }

        async function runScan(isAuto = false) {
            trackAPI(1);
            if(!isAuto) {
                mainBtn.innerText = "Scanning Global Feeds..."; mainBtn.disabled = true;
                content.innerHTML = "<p style='text-align:center; margin-top:50px; color:#666'>Fetching live data & checking stats availability...</p>";
            } else {
                mainBtn.innerText = "ü§ñ Auto-Scanning...";
            }
            try {
                const res = await fetch("https://v3.football.api-sports.io/fixtures?live=all", {
                    headers: { "x-rapidapi-key": API_KEY, "x-rapidapi-host": "v3.football.api-sports.io" }
                });
                const data = await res.json();
                
                if (data.errors && data.errors.requests) {
                    console.warn("Auto-scan skipped: API Limit reached.");
                    return;
                }
                if(!data.response || data.results === 0) {
                    if(!isAuto) content.innerHTML = "<p style='text-align:center; margin-top:50px'>No live games.</p>";
                    allMatches = [];
                } else {
                    allMatches = data.response.filter(m => m.fixture.status.elapsed >= 60 && m.fixture.status.elapsed <= 85);
                    const favs = getFavLeagues();
                    allMatches.sort((a, b) => {
                        const aFav = favs.includes(a.league.id) ? 1 : 0;
                        const bFav = favs.includes(b.league.id) ? 1 : 0;
                        if (bFav !== aFav) return bFav - aFav;
                        return b.fixture.status.elapsed - a.fixture.status.elapsed;
                    });
                    checkBetOutcomes(allMatches);
                    await checkStatsAvailability(allMatches);
                    calculateStrategyCounts();
                    applyFilter(isAuto);
                }
            } catch(e) { 
                console.error("Scan Error:", e);
                if(!isAuto) content.innerHTML = `<p style='text-align:center; margin-top:50px; color:#da3633'>Error: ${e.message}</p>`; 
            }
            mainBtn.innerText = "üéØ SCAN MARKETS"; mainBtn.disabled = false;
        }

        async function enrichEliteMatches(matches) {
            // SEQUENTIAL WATERFALL TO PREVENT RATE LIMITING
            for (const m of matches) {
                // AUTO-OPEN ANALYSIS FOR ALL FIXTURES
                const container = document.getElementById(`stats-${m.fixture.id}`);
                if (container && (container.innerHTML === 'Loading Stats...' || container.style.display === "none")) {
                    const btn = document.getElementById(`an-btn-${m.fixture.id}`);
                    await deepAnalyze(btn, m.fixture.id, m.teams.home.name.replace(/'/g, "\\'"), m.teams.away.name.replace(/'/g, "\\'"), m.goals.home, m.goals.away, false, false, m.league.id, m.league.season, m.teams.home.id, m.teams.away.id);
                    // DELAY BETWEEN MATCHES TO RESPECT API LIMITS
                    await new Promise(r => setTimeout(r, 1200));
                }
            }
        }

        function applyFilter(isAuto = false) {
            const mode = document.getElementById('filterSelect').value;
            content.innerHTML = "";
            let highValueFound = false;
            const placedBets = getHistory().map(b => b.id);
            calculateStrategyCounts();

            if(allMatches.length === 0) { content.innerHTML = "<p style='text-align:center; margin-top:50px; color:#888'>No games in 60-85min window.</p>"; return; }

            if (currentStrategy === 'challenge') {
                scanChallengePicks();
                return;
            }

            const filtered = allMatches.filter(m => {
                const league = (m.league.name || "").toLowerCase();
                const blocked = ["friendly", "friendlies", "club friendlies", "u19", "u20", "u21", "u23", "youth", "reserve", "reserves"];
                if(blocked.some(word => league.includes(word))) return false; 
                
                const fid = m.fixture.id;
                const statsStatus = matchStatsMap[fid] || 'limited';
                if (mode === 'full' && statsStatus !== 'full') return false;
                if (mode === 'limited' && statsStatus !== 'limited') return false;

                if (currentStrategy === 'challenge') return false;
                if (currentStrategy === 'all') return true;
                if (currentStrategy === 'red') {
                    if(!m.events) return false;
                    return m.events.some(e => e.type === 'Card' && e.detail === 'Red Card');
                }
                if (currentStrategy === 'alert') {
                    return isAlertMatch(m);
                }
                
                if (currentStrategy === 'drought') {
                    if (m.goals.home + m.goals.away === 0) return false; 
                    if (!m.events) return false;
                    
                    const goalTimes = m.events
                        .filter(e => e.type === 'Goal')
                        .map(e => e.time.elapsed + (e.time.extra || 0));

                    if (goalTimes.length === 0) return false;

                    const lastGoalTime = Math.max(...goalTimes);
                    const timeSince = m.fixture.status.elapsed - lastGoalTime;

                    return (timeSince > 50);
                }
                
                return true;
            });

            // 1. Initial Render
            filtered.forEach(m => {
                const hasFullStats = matchStatsMap[m.fixture.id] === 'full';
                const isPlaced = placedBets.includes(m.fixture.id);
                createCard(m, isPlaced, hasFullStats);
            });
            
            if(isAuto && highValueFound) playPing();
            
            // AUTO-ENRICHMENT REMOVED - GOING BACK TO MANUAL MODE
            // if(matchesToEnrich.length > 0) {
            //     enrichEliteMatches(matchesToEnrich).then(() => updateBadges());
            // }
        }

        async function scanChallengePicks(isAutoRefresh = false) {
            if (challengeScanLock) return;
            challengeScanLock = true;
            try { await _doScanChallengePicks(isAutoRefresh); } finally { challengeScanLock = false; }
        }

        async function _doScanChallengePicks(isAutoRefresh = false) {
            if (!isAutoRefresh) {
                content.innerHTML = `<div style="text-align:center; padding:40px 15px;">
                    <div style="font-size:2rem; margin-bottom:10px;">üéØ</div>
                    <div style="color:var(--gold); font-weight:bold; font-size:1.1rem; margin-bottom:8px;">Scanning Challenge Picks...</div>
                    <div style="color:#888; font-size:0.85rem;">Fetching stats & live odds for matches</div>
                    <div style="margin-top:15px; width:60%; height:3px; background:rgba(255,255,255,0.1); border-radius:2px; margin:15px auto; overflow:hidden;">
                        <div id="challengeProgress" style="width:0%; height:100%; background:var(--gold); border-radius:2px; transition:width 0.3s;"></div>
                    </div>
                </div>`;
            }

            const blocked = ["friendly", "friendlies", "club friendlies", "u19", "u20", "u21", "u23", "youth", "reserve", "reserves"];
            const eligible = allMatches.filter(m => {
                const league = (m.league.name || "").toLowerCase();
                if (blocked.some(word => league.includes(word))) return false;
                const elapsed = m.fixture.status.elapsed;
                return elapsed >= 60 && elapsed <= 85;
            });

            if (eligible.length === 0) {
                content.innerHTML = `<div style="text-align:center; padding:50px 15px; color:#888;">
                    <div style="font-size:2rem; margin-bottom:10px;">üéØ</div>
                    <p>No live games in the 60-85 min window right now.</p>
                    <p style="font-size:0.8rem; margin-top:8px;">Scan markets first, then try Challenge Picks.</p>
                </div>`;
                stopChallengeAutoRefresh();
                return;
            }

            const fixtureIds = eligible.map(m => m.fixture.id);
            const [_, oddsData] = await Promise.all([
                Promise.resolve(),
                fetchLiveOdds(fixtureIds)
            ]);

            const analyzed = [];
            const progressBar = document.getElementById('challengeProgress');
            
            for (let i = 0; i < eligible.length; i++) {
                const m = eligible[i];
                if (progressBar) progressBar.style.width = `${Math.round(((i + 1) / eligible.length) * 100)}%`;
                try {
                    trackAPI(1);
                    const statRes = await fetch(`https://v3.football.api-sports.io/fixtures/statistics?fixture=${m.fixture.id}`, {
                        headers: { "x-rapidapi-key": API_KEY }
                    });
                    const statData = await statRes.json();
                    
                    if (statData.response && statData.response.length >= 2) {
                        const hStats = statData.response[0].statistics;
                        const aStats = statData.response[1].statistics;
                        
                        const getStat = (arr, type) => {
                            const item = arr.find(s => s.type === type);
                            if (item && item.value !== null && item.value !== undefined) {
                                const v = typeof item.value === 'string' ? parseFloat(item.value) : item.value;
                                return isNaN(v) ? 0 : v;
                            }
                            return 0;
                        };
                        
                        const stats = {
                            homeSoT: getStat(hStats, "Shots on Goal"),
                            awaySoT: getStat(aStats, "Shots on Goal"),
                            homeCorners: getStat(hStats, "Corner Kicks"),
                            awayCorners: getStat(aStats, "Corner Kicks"),
                            homePoss: getStat(hStats, "Ball Possession") || 50,
                            awayPoss: getStat(aStats, "Ball Possession") || 50,
                            homeTotal: getStat(hStats, "Total Shots"),
                            awayTotal: getStat(aStats, "Total Shots"),
                            homeShotsInBox: getStat(hStats, "Shots insidebox"),
                            awayShotsInBox: getStat(aStats, "Shots insidebox"),
                            homeShotsOutBox: getStat(hStats, "Shots outsidebox"),
                            awayShotsOutBox: getStat(aStats, "Shots outsidebox"),
                            homeBigChances: getStat(hStats, "expected_goals") > 0 ? Math.round(getStat(hStats, "expected_goals") / 0.35) : 0,
                            awayBigChances: getStat(aStats, "expected_goals") > 0 ? Math.round(getStat(aStats, "expected_goals") / 0.35) : 0
                        };
                        
                        const totalSoT = stats.homeSoT + stats.awaySoT;
                        const totalShots = stats.homeTotal + stats.awayTotal;
                        const totalCorners = stats.homeCorners + stats.awayCorners;
                        const hasPoss = stats.homePoss > 0 && stats.awayPoss > 0 && stats.homePoss !== 50;
                        const dataPoints = (totalShots > 0 ? 1 : 0) + (totalSoT > 0 ? 1 : 0) + (totalCorners > 0 ? 1 : 0) + (hasPoss ? 1 : 0);
                        
                        if (dataPoints >= 3 && totalShots >= 5) {
                            m.analyzedStats = stats;
                            m.dataQuality = dataPoints;
                            analyzed.push(m);
                        }
                    }
                    await new Promise(r => setTimeout(r, 350));
                } catch(e) {
                    console.warn("Challenge picks: stats fetch failed for", m.fixture.id);
                }
            }

            const formPromises = [];
            const uniqueTeams = new Set();
            analyzed.forEach(m => {
                if (!uniqueTeams.has(m.teams.home.id)) { uniqueTeams.add(m.teams.home.id); formPromises.push(fetchTeamForm(m.teams.home.id)); }
                if (!uniqueTeams.has(m.teams.away.id)) { uniqueTeams.add(m.teams.away.id); formPromises.push(fetchTeamForm(m.teams.away.id)); }
            });
            await Promise.all(formPromises);

            const standingsPromises = [];
            const fetchedLeagues = new Set();
            analyzed.forEach(m => {
                const lKey = `${m.league.id}_${m.league.season}`;
                if (!fetchedLeagues.has(lKey)) {
                    fetchedLeagues.add(lKey);
                    standingsPromises.push(fetchStandingsForLeague(m.league.id, m.league.season));
                }
            });
            await Promise.all(standingsPromises);

            analyzed.forEach(m => {
                const refStr = m.fixture.referee;
                if (refStr && m.events) {
                    const cards = m.events.filter(e => e.type === 'Card').length;
                    const elapsed = m.fixture.status.elapsed || 45;
                    const estFouls = Math.max(cards * 4, Math.round((elapsed / 90) * 22));
                    learnRefProfile(refStr.split(',')[0].trim(), cards, estFouls);
                }
            });

            const allCandidates = getAllChallengeCandidates(analyzed);

            const playerPropTips = await findPlayerPropTips(analyzed, allCandidates);
            playerPropTips.forEach(tip => {
                if (!allCandidates.some(c => c.fixtureId === tip.fixtureId && c.selection === tip.selection)) {
                    allCandidates.push(tip);
                }
            });
            allCandidates.sort((a, b) => b.confidence - a.confidence);

            updateChallengeBadge(allCandidates.length);

            if (isAutoRefresh && allCandidates.length > 0) {
                const topPick = allCandidates[0];
                sendNotification('üéØ Challenge Pick Found', `${topPick.selection} (${topPick.confidence}%) ‚Äî ${topPick.match}`, 'tft-challenge');
            }

            if (allCandidates.length === 0) {
                let noPicksHtml = `<div style="text-align:center; padding:50px 15px; color:#888;">
                    <div style="font-size:2rem; margin-bottom:10px;">üéØ</div>
                    <p>No high-confidence picks found right now.</p>
                    <p style="font-size:0.8rem; margin-top:8px;">Checked ${eligible.length} matches, ${analyzed.length} had enough stats. None met the 78% confidence threshold.</p>
                </div>`;
                const pbAll = getPlacedChallenges();
                const pbPending = pbAll.filter(b => b.status === 'pending');
                const pbResolved = pbAll.filter(b => b.status === 'resolved').sort((a, b) => b.placedAt - a.placedAt);
                if (pbPending.length > 0 || pbResolved.length > 0) {
                    noPicksHtml += renderPlacedBetsTracker(pbPending, pbResolved);
                }
                if (pbPending.length > 0) startChallengeCheckInterval();
                content.innerHTML = noPicksHtml;
                startChallengeAutoRefresh();
                return;
            }

            const streak = getChallengeStreak();
            const now = new Date();
            const nextRefresh = new Date(now.getTime() + 150000);
            const refreshTime = nextRefresh.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});

            let html = `<div style="padding:5px 0 10px;">`;

            if (streak.totalBets > 0) {
                const streakColor = streak.currentStreak >= 5 ? "var(--green)" : (streak.currentStreak >= 3 ? "var(--gold)" : "#ccc");
                const winRate = streak.totalBets > 0 ? Math.round((streak.totalWins / streak.totalBets) * 100) : 0;
                html += `<div style="background:var(--card); border:1px solid rgba(255,255,255,0.08); border-radius:10px; padding:10px 14px; margin:0 10px 10px; display:flex; justify-content:space-between; align-items:center;">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span style="font-size:1.3rem;">${streak.currentStreak >= 5 ? 'üî•' : (streak.currentStreak >= 3 ? '‚ö°' : 'üìä')}</span>
                        <div>
                            <div style="font-size:0.8rem; font-weight:bold; color:${streakColor};">Streak: ${streak.currentStreak} Win${streak.currentStreak !== 1 ? 's' : ''}</div>
                            <div style="font-size:0.65rem; color:#666;">Best: ${streak.bestStreak} | Rate: ${winRate}% (${streak.totalWins}/${streak.totalBets})</div>
                        </div>
                    </div>
                    <div style="display:flex; gap:3px;">
                        ${streak.history.slice(0, 8).map(h => `<div style="width:8px; height:8px; border-radius:50%; background:${h.won ? 'var(--green)' : 'var(--red)'};"></div>`).join('')}
                    </div>
                </div>`;
            }

            html += `<div style="text-align:center; margin-bottom:12px;">
                    <span style="color:var(--gold); font-weight:bold; font-size:0.9rem;">üéØ ${allCandidates.length} Challenge Pick${allCandidates.length > 1 ? 's' : ''} Found</span>
                    <span style="color:#666; font-size:0.75rem; margin-left:8px;">(${analyzed.length}/${eligible.length} matches had stats)</span>
                </div>`;

            const grouped = {};
            allCandidates.forEach(c => {
                if (!grouped[c.fixtureId]) grouped[c.fixtureId] = [];
                grouped[c.fixtureId].push(c);
            });

            Object.values(grouped).forEach(tips => {
                tips.sort((a, b) => b.confidence - a.confidence);
                const first = tips[0];
                const borderColor = first.confidence >= 85 ? 'var(--green)' : 'rgba(255,255,255,0.08)';

                html += `<div style="background:var(--card); border:1px solid ${borderColor}; border-radius:12px; padding:12px 14px; margin:0 10px 10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                        <span style="font-size:0.7rem; color:#888;">${first.league}</span>
                        <span style="font-size:0.65rem; color:#555;">${tips.length > 1 ? '2 tips' : '1 tip'}</span>
                    </div>
                    <div style="font-weight:bold; font-size:0.95rem; margin-bottom:4px;">${first.match}</div>
                    <div style="display:flex; gap:6px; margin-top:4px; font-size:0.7rem; color:#666; flex-wrap:wrap;">
                        <span style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px;">SoT: ${first.homeSoT}-${first.awaySoT}</span>
                        <span style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px;">Shots: ${first.homeTotal}-${first.awayTotal}</span>
                        <span style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px;">Corners: ${first.homeCorners}-${first.awayCorners}</span>
                        <span style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px;">Poss: ${first.homePoss}%-${first.awayPoss}%</span>
                    </div>`;

                tips.forEach((c, tipIdx) => {
                    const confColor = c.confidence >= 88 ? "var(--green)" : (c.confidence >= 82 ? "var(--gold)" : "#ccc");
                    const tierLabel = c.confidence >= 88 ? "STRONG" : (c.confidence >= 82 ? "SOLID" : "FAIR");
                    const tierBg = c.confidence >= 88 ? "rgba(46,160,67,0.12)" : (c.confidence >= 82 ? "rgba(210,153,34,0.12)" : "rgba(255,255,255,0.05)");
                    const isLiveOdds = c.oddsSource === 'live';
                    const oddsLabel = isLiveOdds ? `<span style="color:var(--green); font-size:0.6rem; margin-left:4px;">LIVE</span>` : `<span style="color:#666; font-size:0.6rem; margin-left:4px;">EST</span>`;
                    const tipLabel = tips.length > 1 ? `<span style="font-size:0.6rem; color:#555; text-transform:uppercase; font-weight:600;">${tipIdx === 0 ? 'Primary Pick' : 'Alternative Pick'}</span>` : '';

                    html += `<div style="margin-top:10px; padding-top:${tipIdx > 0 ? '10px' : '6px'}; ${tipIdx > 0 ? 'border-top:1px dashed rgba(255,255,255,0.08);' : ''}">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                            ${tipLabel}
                            <span style="font-size:0.7rem; background:${tierBg}; color:${confColor}; padding:2px 8px; border-radius:10px; font-weight:bold;">${tierLabel} ${c.confidence}%</span>
                        </div>
                        <div style="display:flex; justify-content:space-between; align-items:center; margin:6px 0;">
                            <div style="background:rgba(46,160,67,0.1); border:1px solid rgba(46,160,67,0.3); padding:5px 12px; border-radius:8px;">
                                <span style="color:var(--green); font-weight:bold; font-size:0.9rem;">‚úÖ ${c.selection}</span>
                            </div>
                            <span style="color:var(--gold); font-weight:bold; font-size:0.95rem;">@ ${c.odds}${oddsLabel}</span>
                        </div>
                        <div style="font-size:0.75rem; color:#aaa; line-height:1.4;">${c.reasoning}</div>
                        <div style="display:flex; gap:6px; margin-top:8px;">
                            ${getPlacedChallenges().some(b => b.fixtureId === c.fixtureId && b.selection === c.selection) ?
                            `<button disabled style="flex:1; padding:8px; border-radius:6px; border:1px solid var(--gold); background:rgba(210,153,34,0.15); color:var(--gold); font-size:0.75rem; font-weight:bold; cursor:default;">üìå Bet Placed ‚Äî Tracking</button>` :
                            `<button data-fid="${c.fixtureId}" data-sel="${encodeURIComponent(c.selection)}" data-match="${encodeURIComponent(c.match)}" data-league="${encodeURIComponent(c.league)}" data-odds="${c.odds}" data-osrc="${c.oddsSource}" data-hg="${c.homeGoals}" data-ag="${c.awayGoals}" data-conf="${c.confidence}" data-lid="${c.leagueId || 0}" onclick="placeChallengebet(parseInt(this.dataset.fid), decodeURIComponent(this.dataset.sel), decodeURIComponent(this.dataset.match), decodeURIComponent(this.dataset.league), this.dataset.odds, this.dataset.osrc, parseInt(this.dataset.hg), parseInt(this.dataset.ag), parseInt(this.dataset.conf), parseInt(this.dataset.lid)||null); this.disabled=true; this.innerHTML='üìå Bet Placed ‚Äî Tracking'; this.style.borderColor='var(--gold)'; this.style.background='rgba(210,153,34,0.15)'; this.style.color='var(--gold)'; startChallengeCheckInterval();" style="flex:1; padding:8px; border-radius:6px; border:1px solid var(--green); background:rgba(46,160,67,0.1); color:var(--green); font-size:0.75rem; font-weight:bold; cursor:pointer;">üìå Bet Placed</button>`}
                        </div>
                    </div>`;
                });

                html += `</div>`;
            });

            const placedBetsAll = getPlacedChallenges();
            const pendingBets = placedBetsAll.filter(b => b.status === 'pending');
            const recentResolved = placedBetsAll.filter(b => b.status === 'resolved').sort((a, b) => b.placedAt - a.placedAt);

            if (pendingBets.length > 0 || recentResolved.length > 0) {
                html += renderPlacedBetsTracker(pendingBets, recentResolved);
            }

            if (pendingBets.length > 0) startChallengeCheckInterval();

            html += `<div style="text-align:center; padding:8px; color:#555; font-size:0.7rem;">
                üîÑ Auto-refresh in ~2.5 min (${refreshTime}) | ${isAutoRefresh ? 'Auto-updated' : 'Manual scan'}
            </div>`;
            html += `</div>`;
            content.innerHTML = html;

            cleanupOldPlacedBets();
            startChallengeAutoRefresh();
        }

        function getRecentGoalMinutes(match) {
            if (!match.events) return null;
            const goals = match.events.filter(e => e.type === 'Goal');
            if (goals.length === 0) return null;
            const lastGoal = goals.reduce((latest, g) => {
                const t = ((g.time && g.time.elapsed) || 0) + ((g.time && g.time.extra) || 0);
                return t > latest ? t : latest;
            }, 0);
            return lastGoal;
        }

        function getTimeCurve(elapsed) {
            if (elapsed >= 82) return 1.18;
            if (elapsed >= 80) return 1.16;
            if (elapsed >= 78) return 1.14;
            if (elapsed >= 76) return 1.12;
            if (elapsed >= 74) return 1.10;
            if (elapsed >= 72) return 1.08;
            if (elapsed >= 70) return 1.06;
            if (elapsed >= 68) return 1.03;
            if (elapsed >= 66) return 1.01;
            return 1.0;
        }

        function getSoTFloor(elapsed) {
            if (elapsed >= 78) return 5;
            if (elapsed >= 73) return 4;
            return 3;
        }

        function getAllChallengeCandidates(matches) {
            let allCandidates = [];
            
            matches.forEach(m => {
                const stats = m.analyzedStats;
                if (!stats) return;
                
                const fixtureId = m.fixture.id;
                const elapsed = m.fixture.status.elapsed;
                const totalGoals = m.goals.home + m.goals.away;
                const homeName = m.teams.home.name;
                const awayName = m.teams.away.name;
                const matchName = `${homeName} vs ${awayName}`;
                const league = `${m.league.country} ‚Ä¢ ${m.league.name}`;
                
                const leagueProfile = getLeagueProfile(m.league.id);
                const scoreState = getScoreState(m.goals.home, m.goals.away);
                const pressure = calculateSmartPressure(stats);
                const momentum = calculateMomentum(m, stats);
                const enhancedXG = calculateEnhancedXG(stats);

                const homeForm = getTeamFormData(m.teams.home.id);
                const awayForm = getTeamFormData(m.teams.away.id);
                const standings = standingsCache[`${m.league.id}_${m.league.season}`];
                const homeDef = analyzeDefensiveStrength(standings, m.teams.home.id);
                const awayDef = analyzeDefensiveStrength(standings, m.teams.away.id);
                const refProfile = getRefProfile(m.fixture.referee);
                const weatherImpact = estimateWeatherImpact(m.fixture.venue, elapsed);
                const xgGap = analyzeXGGap(enhancedXG, m.goals.home, m.goals.away);
                const subImpact = analyzeSubstitutionImpact(m.events, elapsed);
                const scoreFlow = analyzeScoreFlow(m.events, elapsed, m.goals.home, m.goals.away);
                const homeCongestion = analyzeFixtureCongestion(homeForm);
                const awayCongestion = analyzeFixtureCongestion(awayForm);
                const possTrend = analyzePossessionTrend(stats, momentum);
                const shotAcc = analyzeShotAccuracy(stats);
                const h2Momentum = analyzeSecondHalfMomentum(stats, elapsed, totalGoals, m.events);

                const totalSoT = stats.homeSoT + stats.awaySoT;
                const totalShots = stats.homeTotal + stats.awayTotal;
                const totalCorners = stats.homeCorners + stats.awayCorners;

                const timeMultiplier = getTimeCurve(elapsed);
                const leagueBoost = leagueProfile.tempo === "high" ? 1.06 : (leagueProfile.tempo === "low" ? 0.92 : 1.0);
                const lateGoalBoost = leagueProfile.lateGoalRate > 0.30 ? 1.08 : 1.0;

                const lastGoalMin = getRecentGoalMinutes(m);
                const recentGoalBoost = (lastGoalMin !== null && (elapsed - lastGoalMin) <= 5) ? 1.06 : 1.0;
                const recentGoalNote = (lastGoalMin !== null && (elapsed - lastGoalMin) <= 5) ? ` ‚ö° Goal at ${lastGoalMin}' ‚Äî game is open!` : '';

                const homeRed = m.events ? m.events.some(e => e.type === 'Card' && e.detail === 'Red Card' && e.team.id === m.teams.home.id) : false;
                const awayRed = m.events ? m.events.some(e => e.type === 'Card' && e.detail === 'Red Card' && e.team.id === m.teams.away.id) : false;

                const redCardPenalty = (selection) => {
                    if (!selection.startsWith("Over") && selection !== "Both Teams to Score") return 0;
                    if (homeRed && m.goals.home > m.goals.away && stats.homePoss < 42) return -6;
                    if (awayRed && m.goals.away > m.goals.home && stats.awayPoss < 42) return -6;
                    if (homeRed && m.goals.home > m.goals.away) return -3;
                    if (awayRed && m.goals.away > m.goals.home) return -3;
                    return 0;
                };

                const fixtureLiveOdds = liveOddsCache[fixtureId] || {};

                const getRealisticOdds = (market, elapsed) => {
                    if (market === 'o05') {
                        if (elapsed >= 80) return (1.01 + Math.random() * 0.03).toFixed(2);
                        if (elapsed >= 75) return (1.05 + Math.random() * 0.05).toFixed(2);
                        return (1.12 + Math.random() * 0.08).toFixed(2);
                    }
                    if (market === 'o15') {
                        if (elapsed >= 75) return (1.20 + Math.random() * 0.10).toFixed(2);
                        if (elapsed >= 65) return (1.33 + Math.random() * 0.12).toFixed(2);
                        return (1.45 + Math.random() * 0.15).toFixed(2);
                    }
                    if (market === 'o25') {
                        if (elapsed >= 70) return (1.50 + Math.random() * 0.20).toFixed(2);
                        if (elapsed >= 60) return (1.65 + Math.random() * 0.20).toFixed(2);
                        return (1.80 + Math.random() * 0.20).toFixed(2);
                    }
                    if (market === 'btts') return (1.50 + Math.random() * 0.25).toFixed(2);
                    if (market === 'next') return (1.60 + Math.random() * 0.30).toFixed(2);
                    if (market === 'goalscorer') {
                        if (elapsed >= 75) return (2.20 + Math.random() * 0.50).toFixed(2);
                        if (elapsed >= 65) return (2.50 + Math.random() * 0.60).toFixed(2);
                        return (2.80 + Math.random() * 0.70).toFixed(2);
                    }
                    return (1.40 + Math.random() * 0.30).toFixed(2);
                };

                const getOddsWithSource = (market, elapsed, isHome) => {
                    let liveKey = market;
                    if (market === 'next') liveKey = isHome ? 'next_home' : 'next_away';
                    if (fixtureLiveOdds[liveKey]) {
                        return { odds: parseFloat(fixtureLiveOdds[liveKey]).toFixed(2), source: 'live' };
                    }
                    return { odds: getRealisticOdds(market, elapsed), source: 'estimated' };
                };

                let matchCandidates = [];

                const addCandidate = (selection, oddsInfo, confidence, reasoning) => {
                    const rcPenalty = redCardPenalty(selection);
                    if (rcPenalty < 0) {
                        confidence = Math.max(50, confidence + rcPenalty);
                        const busTeam = homeRed ? homeName : awayName;
                        reasoning += ` üü• ${busTeam} down to 10 men and leading ‚Äî likely parking the bus (‚àí${Math.abs(rcPenalty)}%).`;
                    }
                    const isHome = selection.includes(homeName);
                    const formAdj = applyFormBoost(confidence, homeForm, awayForm, selection, isHome);
                    const defAdj = applyDefenseAdjustment(confidence, homeDef, awayDef, selection);
                    const histAdj = applyHistoricalPatternBoost(m.league.id, selection);
                    const calibAdj = getCalibrationAdjustment(confidence);
                    const congestionBoost = Math.max(homeCongestion.boost, awayCongestion.boost);
                    const congestionNote = homeCongestion.boost >= awayCongestion.boost ? homeCongestion.note : awayCongestion.note;
                    confidence = Math.max(50, Math.min(96, confidence + formAdj.boost + defAdj.boost + histAdj.boost + xgGap.boost + subImpact.boost + scoreFlow.boost + congestionBoost + possTrend.boost + shotAcc.boost + h2Momentum.boost + calibAdj.boost));
                    if (formAdj.note) reasoning += ` ${formAdj.note}`;
                    if (defAdj.note) reasoning += ` ${defAdj.note}`;
                    if (histAdj.note) reasoning += ` ${histAdj.note}`;
                    if (xgGap.note) reasoning += ` ${xgGap.note}`;
                    if (subImpact.note) reasoning += ` ${subImpact.note}`;
                    if (scoreFlow.note) reasoning += ` ${scoreFlow.note}`;
                    if (congestionNote) reasoning += ` ${congestionNote}`;
                    if (possTrend.note) reasoning += ` ${possTrend.note}`;
                    if (shotAcc.note) reasoning += ` ${shotAcc.note}`;
                    if (h2Momentum.note) reasoning += ` ${h2Momentum.note}`;
                    if (calibAdj.note) reasoning += ` ${calibAdj.note}`;
                    if (weatherImpact.note && weatherImpact.boost !== 0) reasoning += ` ${weatherImpact.note}`;
                    const candidateObj = { fixtureId, match: matchName, league, selection, odds: oddsInfo.odds, oddsSource: oddsInfo.source, confidence, reasoning, totalSoT, totalShots, homeSoT: stats.homeSoT, awaySoT: stats.awaySoT, homeTotal: stats.homeTotal, awayTotal: stats.awayTotal, homeCorners: stats.homeCorners, awayCorners: stats.awayCorners, homePoss: Math.round(stats.homePoss), awayPoss: Math.round(stats.awayPoss), homeGoals: m.goals.home, awayGoals: m.goals.away, leagueId: m.league.id };
                    matchCandidates.push(candidateObj);
                };

                const sotFloor = getSoTFloor(elapsed);
                if (totalGoals === 0 && elapsed >= 65 && totalSoT >= sotFloor) {
                    let conf = Math.min(92, Math.round(scoreState.goalProb * 100 * timeMultiplier * lateGoalBoost * recentGoalBoost));
                    let reason = `0-0 at ${elapsed}' in ${leagueProfile.name} (${Math.round(leagueProfile.lateGoalRate * 100)}% late goal rate).`;
                    if (totalSoT >= 8) { conf = Math.min(94, conf + 6); reason += ` ${totalSoT} SoT - breakthrough imminent!`; }
                    else if (totalSoT >= 5) { conf = Math.min(93, conf + 4); reason += ` ${totalSoT} shots on target already.`; }
                    else { reason += ` ${totalSoT} SoT, ${totalShots} total shots.`; }
                    if (momentum.surgeDetected) { conf = Math.min(94, conf + 3); reason += ` ‚ö° Momentum surge!`; }
                    addCandidate("Over 0.5 Goals", getOddsWithSource('o05', elapsed), conf, reason);
                }
                
                if (totalGoals === 1 && elapsed >= 50 && elapsed <= 80 && totalSoT >= 4) {
                    let conf = Math.min(90, Math.round(scoreState.goalProb * 100 * timeMultiplier * leagueBoost * recentGoalBoost));
                    const chasingTeam = m.goals.home < m.goals.away ? homeName : awayName;
                    const chasingStats = m.goals.home < m.goals.away ? `${stats.homeSoT} SoT` : `${stats.awaySoT} SoT`;
                    let reason = `${m.goals.home}-${m.goals.away} at ${elapsed}'. ${chasingTeam} chasing (${chasingStats}).`;
                    if (totalSoT >= 7) { conf = Math.min(92, conf + 4); reason += ` Open game, ${totalSoT} SoT total.`; }
                    if (totalShots >= 18) { conf = Math.min(92, conf + 3); reason += ` ${totalShots} total shots.`; }
                    if (momentum.surgeDetected) { conf = Math.min(92, conf + 3); reason += ` ‚ö° Momentum surge!`; }
                    if (recentGoalNote) reason += recentGoalNote;
                    addCandidate("Over 1.5 Goals", getOddsWithSource('o15', elapsed), conf, reason);
                }
                
                if (totalGoals === 2 && elapsed >= 45 && elapsed <= 75 && totalSoT >= 6 && totalShots >= 14) {
                    let conf = Math.min(88, Math.round(scoreState.goalProb * 100 * leagueBoost * recentGoalBoost));
                    let reason = `${m.goals.home}-${m.goals.away} at ${elapsed}'. ${scoreState.desc}`;
                    if (totalShots >= 22) { conf = Math.min(90, conf + 4); reason += ` Very open - ${totalShots} shots, ${totalSoT} on target.`; }
                    else { reason += ` ${totalShots} shots, ${totalSoT} SoT.`; }
                    if (totalCorners >= 8) { conf = Math.min(90, conf + 2); reason += ` ${totalCorners} corners.`; }
                    if (recentGoalNote) reason += recentGoalNote;
                    addCandidate("Over 2.5 Goals", getOddsWithSource('o25', elapsed), conf, reason);
                }

                if (totalGoals >= 1 && m.goals.home === 0 && elapsed >= 55 && elapsed <= 78) {
                    const leadingSoT = stats.awaySoT;
                    const leadingShots = stats.awayTotal;
                    const leaderParked = (leadingSoT <= 1 && leadingShots <= 3 && stats.awayPoss < 40);
                    if (stats.homeSoT >= 2 && stats.homeTotal >= 4 && !leaderParked) {
                        let conf = Math.min(85, Math.round(scoreState.bttsProb * 100 * timeMultiplier * recentGoalBoost));
                        let reason = `${homeName} 0 goals but ${stats.homeSoT} SoT and ${stats.homeTotal} shots.`;
                        if (leadingSoT >= 3) { reason += ` ${awayName} still attacking (${leadingSoT} SoT).`; }
                        if (pressure.dominance === "home_siege" || pressure.dominance === "home_edge") { conf = Math.min(88, conf + 4); reason += ` Home pressure ${pressure.hPercent}%.`; }
                        if (momentum.surgeTeam === "home") { conf = Math.min(88, conf + 3); reason += ` ‚ö° Home momentum surge!`; }
                        if (recentGoalNote) reason += recentGoalNote;
                        if (conf >= 78) addCandidate("Both Teams to Score", getOddsWithSource('btts', elapsed), conf, reason);
                    }
                } else if (totalGoals >= 1 && m.goals.away === 0 && elapsed >= 55 && elapsed <= 78) {
                    const leadingSoT = stats.homeSoT;
                    const leadingShots = stats.homeTotal;
                    const leaderParked = (leadingSoT <= 1 && leadingShots <= 3 && stats.homePoss < 40);
                    if (stats.awaySoT >= 2 && stats.awayTotal >= 4 && !leaderParked) {
                        let conf = Math.min(83, Math.round(scoreState.bttsProb * 100 * timeMultiplier * recentGoalBoost));
                        let reason = `${awayName} 0 goals but ${stats.awaySoT} SoT and ${stats.awayTotal} shots.`;
                        if (leadingSoT >= 3) { reason += ` ${homeName} still attacking (${leadingSoT} SoT).`; }
                        if (pressure.dominance === "away_siege" || pressure.dominance === "away_edge") { conf = Math.min(86, conf + 4); reason += ` Away pressure ${pressure.aPercent}%.`; }
                        if (momentum.surgeTeam === "away") { conf = Math.min(86, conf + 3); reason += ` ‚ö° Away momentum surge!`; }
                        if (recentGoalNote) reason += recentGoalNote;
                        if (conf >= 78) addCandidate("Both Teams to Score", getOddsWithSource('btts', elapsed), conf, reason);
                    }
                }

                if (pressure.dominance === "home_siege" && stats.homeSoT >= 3 && elapsed >= 55 && m.goals.home <= m.goals.away) {
                    let conf = Math.min(87, Math.round(76 * timeMultiplier * leagueBoost * recentGoalBoost));
                    let reason = `${homeName} siege: ${stats.homeSoT} SoT, ${stats.homeTotal} shots, ${stats.homeCorners} corners (${pressure.hPercent}% pressure).`;
                    if (momentum.surgeTeam === "home") { conf = Math.min(90, conf + 4); reason += ` ‚ö° Home momentum surge!`; }
                    if (stats.homePoss >= 60) { conf = Math.min(90, conf + 2); reason += ` ${Math.round(stats.homePoss)}% possession.`; }
                    if (recentGoalNote) reason += recentGoalNote;
                    addCandidate(`Next Goal: ${homeName}`, getOddsWithSource('next', elapsed, true), conf, reason);
                }
                
                if (pressure.dominance === "away_siege" && stats.awaySoT >= 3 && elapsed >= 55 && m.goals.away <= m.goals.home) {
                    let conf = Math.min(85, Math.round(74 * timeMultiplier * leagueBoost * recentGoalBoost));
                    let reason = `${awayName} siege: ${stats.awaySoT} SoT, ${stats.awayTotal} shots, ${stats.awayCorners} corners (${pressure.aPercent}% pressure).`;
                    if (momentum.surgeTeam === "away") { conf = Math.min(88, conf + 4); reason += ` ‚ö° Away momentum surge!`; }
                    if (stats.awayPoss >= 60) { conf = Math.min(88, conf + 2); reason += ` ${Math.round(stats.awayPoss)}% possession.`; }
                    if (recentGoalNote) reason += recentGoalNote;
                    addCandidate(`Next Goal: ${awayName}`, getOddsWithSource('next', elapsed, false), conf, reason);
                }
                
                if (m.events && totalSoT >= 2) {
                    if (awayRed && !homeRed && elapsed >= 50 && stats.homeSoT >= 2) {
                        let conf = Math.min(90, Math.round(84 * timeMultiplier));
                        addCandidate(`Next Goal: ${homeName}`, getOddsWithSource('next', elapsed, true), conf, `üü• ${awayName} 10 men! ${homeName}: ${stats.homeSoT} SoT, ${stats.homeTotal} shots. ${90 - elapsed} mins with man advantage.`);
                    }
                    if (homeRed && !awayRed && elapsed >= 50 && stats.awaySoT >= 2) {
                        let conf = Math.min(90, Math.round(84 * timeMultiplier));
                        addCandidate(`Next Goal: ${awayName}`, getOddsWithSource('next', elapsed, false), conf, `üü• ${homeName} 10 men! ${awayName}: ${stats.awaySoT} SoT, ${stats.awayTotal} shots. ${90 - elapsed} mins with man advantage.`);
                    }
                }

                const minsLeft = 90 - elapsed;

                const topCandidate = matchCandidates.length > 0 ? matchCandidates.sort((a, b) => b.confidence - a.confidence)[0] : null;
                if (topCandidate && topCandidate.selection.startsWith('Over')) {
                    const chain = suggestMarketChain(totalGoals, elapsed, topCandidate.confidence, stats);
                    if (chain && !matchCandidates.some(c => c.selection === chain.selection)) {
                        addCandidate(chain.selection, getOddsWithSource(chain.marketKey, elapsed), chain.confidence, chain.reasoning);
                    }
                }

                if (matchCandidates.length > 0) {
                    matchCandidates.sort((a, b) => b.confidence - a.confidence);
                    allCandidates.push(matchCandidates[0]);
                    if (matchCandidates.length >= 2 && matchCandidates[1].confidence >= 78 && matchCandidates[1].selection !== matchCandidates[0].selection) {
                        allCandidates.push(matchCandidates[1]);
                    }
                }
            });
            
            const filtered = allCandidates.filter(c => c.confidence >= 78);
            filtered.sort((a, b) => {
                if (b.confidence !== a.confidence) return b.confidence - a.confidence;
                return (b.totalSoT + b.totalShots) - (a.totalSoT + a.totalShots);
            });
            return filtered;
        }

        async function findPlayerPropTips(matches, existingCandidates) {
            const propTips = [];
            const qualifying = matches.filter(m => {
                const stats = m.analyzedStats;
                if (!stats) return false;
                const elapsed = m.fixture.status.elapsed || 0;
                const totalSoT = (stats.homeSoT || 0) + (stats.awaySoT || 0);
                return elapsed >= 55 && elapsed <= 85 && totalSoT >= 4;
            }).slice(0, 3);

            for (const m of qualifying) {
                try {
                    trackAPI(1);
                    const res = await fetch(`https://v3.football.api-sports.io/fixtures/players?fixture=${m.fixture.id}`, { headers: { "x-rapidapi-key": API_KEY } });
                    const data = await res.json();
                    if (!data.response || data.response.length < 2) continue;

                    const elapsed = m.fixture.status.elapsed || 70;
                    const stats = m.analyzedStats;
                    const homeName = m.teams.home.name;
                    const awayName = m.teams.away.name;
                    const matchName = `${homeName} vs ${awayName}`;
                    const league = m.league.name;
                    const refName = m.fixture.referee ? m.fixture.referee.split(',')[0].trim() : null;
                    const refProfile = refName ? getRefProfile(refName) : null;
                    const refStrictness = refProfile ? refProfile.strictness : 'unknown';

                    const baseTipObj = {
                        totalSoT: (stats.homeSoT || 0) + (stats.awaySoT || 0),
                        totalShots: (stats.homeTotal || 0) + (stats.awayTotal || 0),
                        homeSoT: stats.homeSoT || 0,
                        awaySoT: stats.awaySoT || 0,
                        homeTotal: stats.homeTotal || 0,
                        awayTotal: stats.awayTotal || 0,
                        homeCorners: stats.homeCorners || 0,
                        awayCorners: stats.awayCorners || 0,
                        homePoss: Math.round(stats.homePoss || 50),
                        awayPoss: Math.round(stats.awayPoss || 50),
                        homeGoals: m.goals.home,
                        awayGoals: m.goals.away,
                        leagueId: m.league.id
                    };

                    let topThreats = [];
                    let bookingRisks = [];

                    data.response.forEach(t => {
                        if (!t.players) return;
                        t.players.forEach(p => {
                            if (!p.statistics || !p.statistics[0]) return;
                            const s = p.statistics[0];
                            if (!s.games) return;
                            const mins = s.games.minutes || 0;
                            if (mins < 30) return;

                            if (s.shots && s.goals && s.goals.total === 0 && (s.shots.on || 0) >= 2) {
                                const shotsOn = s.shots.on || 0;
                                const shotsTotal = s.shots.total || 0;
                                const keyPasses = (s.passes && s.passes.key) || 0;
                                const dribbles = (s.dribbles && s.dribbles.success) || 0;
                                const threatScore = shotsOn * 4 + (shotsTotal - shotsOn) * 1.5 + keyPasses * 1.5 + dribbles * 0.5;
                                topThreats.push({
                                    name: p.player.name, id: p.player.id, team: t.team.name,
                                    shotsOn, shotsTotal, keyPasses, threatScore, mins
                                });
                            }

                            if (s.fouls && s.cards) {
                                const fouls = s.fouls.committed || 0;
                                const hasYellow = s.cards.yellow || 0;
                                const hasRed = s.cards.red || 0;
                                if (fouls >= 2 && !hasYellow && !hasRed) {
                                    let cardProb = Math.min(95, Math.round(fouls * 18 + (fouls >= 3 ? 15 : 0) + (elapsed >= 70 ? 10 : 0)));
                                    if (refStrictness === 'strict') cardProb = Math.min(95, cardProb + 10);
                                    else if (refStrictness === 'lenient') cardProb = Math.max(50, cardProb - 8);
                                    const pos = s.games.position || '';
                                    const isDefender = pos === 'D' || pos === 'Defender';
                                    const isMidfielder = pos === 'M' || pos === 'Midfielder';
                                    if (isDefender || isMidfielder) cardProb = Math.min(95, cardProb + 5);
                                    bookingRisks.push({
                                        name: p.player.name, id: p.player.id, team: t.team.name,
                                        fouls, cardProb, pos, mins
                                    });
                                }
                            }
                        });
                    });

                    topThreats.sort((a, b) => b.threatScore - a.threatScore);
                    const bestGoalscorer = topThreats[0];
                    if (bestGoalscorer && bestGoalscorer.threatScore >= 8) {
                        let conf = Math.min(88, Math.round(74 + bestGoalscorer.threatScore * 0.8));
                        conf = Math.min(90, conf + (elapsed >= 70 ? 3 : (elapsed >= 65 ? 2 : 0)));
                        const reason = `üéØ ${bestGoalscorer.name} (${bestGoalscorer.team}): ${bestGoalscorer.shotsOn} SoT, ${bestGoalscorer.shotsTotal} total shots, ${bestGoalscorer.keyPasses} key passes ‚Äî 0 goals. Active threat at ${elapsed}'.`;
                        propTips.push({
                            fixtureId: m.fixture.id, match: matchName, league,
                            selection: `Anytime Goalscorer: ${bestGoalscorer.name}`,
                            odds: (2.20 + Math.random() * 0.80).toFixed(2),
                            oddsSource: 'estimated', confidence: conf, reasoning: reason,
                            ...baseTipObj
                        });
                    }

                    bookingRisks.sort((a, b) => b.cardProb - a.cardProb);
                    const bestBooking = bookingRisks[0];
                    if (bestBooking && bestBooking.cardProb >= 55) {
                        let conf = Math.min(90, Math.round(bestBooking.cardProb * 0.9));
                        conf = Math.min(92, conf + (elapsed >= 70 ? 3 : (elapsed >= 65 ? 2 : 0)));
                        if (refStrictness === 'strict') conf = Math.min(92, conf + 3);
                        const refNote = refProfile ? ` üëÆ Ref: ${refName} (${refStrictness}).` : '';
                        const posLabel = bestBooking.pos ? ` Position: ${bestBooking.pos}.` : '';
                        const reason = `üü® ${bestBooking.name} (${bestBooking.team}): ${bestBooking.fouls} fouls committed, 0 cards so far.${posLabel}${refNote} High booking risk at ${elapsed}'.`;
                        propTips.push({
                            fixtureId: m.fixture.id, match: matchName, league,
                            selection: `Anytime Booking: ${bestBooking.name}`,
                            odds: (1.60 + Math.random() * 0.50).toFixed(2),
                            oddsSource: 'estimated', confidence: conf, reasoning: reason,
                            ...baseTipObj
                        });
                    }

                } catch(e) { console.log('Player prop fetch error:', e); }
            }
            return propTips;
        }

        function createCard(m, isPlaced, hasFullStats) {
            const div = document.createElement('div');
            div.className = `match-card ${isPlaced ? 'placed' : ''}`;
            div.id = `card-${m.fixture.id}`;
            
            // Fetch standings for card
            getStandings(m.fixture.id, m.teams.home.id, m.teams.away.id, m.league.id, m.league.season);

            const h = m.teams.home;
            const a = m.teams.away;
            const s = m.goals;
            const t = m.fixture.status.elapsed;
            const lid = m.league.id;
            const sid = m.league.season;
            
            let refName = "";
            if (m.fixture.referee) { refName = `<span class="ref-name">üëÆ ${m.fixture.referee.split(',')[0]}</span>`; }
            
            let hGoals = "", aGoals = "";
            let hRed = false, aRed = false;

            if (m.events) {
                hGoals = m.events.filter(e => e.type === 'Goal' && e.team.id === h.id).map(e => e.time.elapsed + "'").join(', ');
                aGoals = m.events.filter(e => e.type === 'Goal' && e.team.id === a.id).map(e => e.time.elapsed + "'").join(', ');
                hRed = m.events.some(e => e.type === 'Card' && e.detail === 'Red Card' && e.team.id === h.id);
                aRed = m.events.some(e => e.type === 'Card' && e.detail === 'Red Card' && e.team.id === a.id);
            }

            const hRedBadge = hRed ? "<div class='red-card-badge'>üü• RED CARD</div>" : "";
            const aRedBadge = aRed ? "<div class='red-card-badge'>üü• RED CARD</div>" : "";
            const placedBadge = isPlaced ? "<div class='placed-badge'>‚úÖ BET PLACED</div>" : "";
            const limitedBadge = !hasFullStats ? "<div style='text-align:center; padding:4px 8px; background:rgba(210,163,34,0.15); border:1px solid rgba(210,163,34,0.3); border-radius:6px; color:var(--gold); font-size:0.75rem; margin-bottom:8px;'>‚ö†Ô∏è Limited Data ‚Äî Analysis may be unavailable</div>" : "";

            let upsetHtml = "";
            if (s.home < s.away && (s.away - s.home === 1)) {
                upsetHtml = `<div class="upset-badge">üî• UPSET ALERT: ${h.name} Chasing!</div>`;
            }

            let predText = "Monitoring...";
            let confVal = 0;
            let confClass = "conf-low";

            if (s.home === s.away) {
                if (s.home > 1) { predText = "‚öîÔ∏è High Score Draw"; confVal = 78; }
                else if (s.home === 0) { predText = "üõ°Ô∏è 0-0 Stalemate"; confVal = 70; }
                else { predText = "‚ö†Ô∏è Tight Match"; confVal = 75; }
                if(hRed || aRed) { predText = "‚öîÔ∏è 10 Men vs 11"; confVal = 85; }
            } 
            else if (Math.abs(s.home - s.away) === 1) {
                predText = "‚öΩ Late Goal Likely";
                confVal = (t > 75) ? 90 : 82;
            } 
            else {
                predText = "üîí Result Likely Safe";
                confVal = 94;
            }
            
            if(upsetHtml !== "") { predText = "üî• Favorite Chasing"; confVal = 95; }
            if(confVal >= 80) confClass = "conf-high"; else if(confVal >= 60) confClass = "conf-med";

            // MANUAL ANALYSIS CONTAINER
            let analysisBlock = `
                <div id="stats-${m.fixture.id}" class="analysis-box" style="text-align:center; color:#888; margin-bottom:15px; min-height: 20px; display: block !important;">
                    <span style="color:var(--gold)">Ready for Analysis</span>
                </div>
                <div class="btn-container-main" style="display: flex !important; flex-direction: column !important; gap: 10px !important; width: 100% !important; margin-top: 15px !important; position: relative !important;">
                    <button class="analyze-btn" id="an-btn-${m.fixture.id}" 
                            style="width: 100% !important; background: var(--blue) !important; border: 2px solid #388bfd !important; color: white !important; padding: 18px 10px !important; font-weight: 900 !important; border-radius: 10px !important; cursor: pointer !important; display: block !important; visibility: visible !important; -webkit-appearance: none; appearance: none; font-size: 1.1rem !important; box-shadow: 0 4px 12px rgba(31, 111, 235, 0.4) !important;" 
                            onclick="deepAnalyze(this, ${m.fixture.id}, '${h.name.replace(/'/g, "\\'")}', '${a.name.replace(/'/g, "\\'")}', ${s.home}, ${s.away}, ${hRed}, ${aRed}, ${lid}, ${sid}, ${h.id}, ${a.id})">
                        ‚ö° ANALYZE MATCH
                    </button>
                    
                    <div style="display: flex !important; gap: 10px !important; width: 100% !important;">
                        <button class="player-btn" id="pl-btn-${m.fixture.id}" style="flex: 1 !important; padding: 14px !important; border-radius: 8px !important; background: #21262d !important; border: 1px solid #30363d !important; color: #ccc !important; font-weight: bold !important; cursor: pointer !important; display: block !important; -webkit-appearance: none; appearance: none;" onclick="checkPlayers(this, ${m.fixture.id})">üïµÔ∏è Players</button>
                        <a class="bet365-btn" href="https://www.bet365.com/#/IP/B1" target="_blank" style="flex: 1 !important; background: #00703c !important; color: white !important; padding: 14px !important; border-radius: 8px !important; text-decoration: none !important; text-align: center !important; font-weight: bold !important; display: block !important; border: 1px solid #005c31 !important;">Bet365</a>
                        <button class="mark-btn ${isPlaced ? 'active' : ''}" style="width: 50px !important; background: #21262d !important; border: 1px solid #30363d !important; border-radius: 8px !important; font-size: 1.2rem !important; cursor: pointer !important; display: flex !important; align-items: center !important; justify-content: center !important; -webkit-appearance: none; appearance: none;" onclick="toggleBet(${m.fixture.id}, ${s.home}, ${s.away}, '${h.name.replace(/'/g, "\\'")} vs ${a.name.replace(/'/g, "\\'")}'); this.classList.toggle('active')">üìå</button>
                    </div>
                </div>`;

            div.innerHTML = `
                ${placedBadge}
                ${limitedBadge}
                <div class="league-name" style="display:flex; justify-content:space-between; align-items:center;">
                    <span><span class="fav-star ${isFavLeague(m.league.id) ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavLeague(${m.league.id}); this.classList.toggle('active');">‚òÖ</span>${m.league.country} ‚Ä¢ ${m.league.name}</span>
                    <span style="font-family:monospace; color:var(--gold); font-weight:bold;">${t}'</span>
                </div>
                <div class="score-row">
                    <div class="team-col" style="align-items:flex-end; text-align:right;">
                        <div style="display:flex; align-items:center;">
                            <span id="rank-h-${m.fixture.id}" class="rank-on-card"></span>
                            <span class="team-name">${h.name} <span class="pos-badge" id="pos-h-${m.fixture.id}"></span></span>
                        </div>
                        <span class="goal-times">${hGoals}</span>
                        ${hRedBadge}
                    </div>
                    <span class="score-box">${s.home}-${s.away}</span>
                    <div class="team-col" style="align-items:flex-start; text-align:left;">
                        <div style="display:flex; align-items:center;">
                            <span class="team-name">${a.name} <span class="pos-badge" id="pos-a-${m.fixture.id}"></span></span>
                            <span id="rank-a-${m.fixture.id}" class="rank-on-card"></span>
                        </div>
                        <span class="goal-times">${aGoals}</span>
                        ${aRedBadge}
                    </div>
                </div>
                ${m.events && m.events.length > 0 ? renderTimeline(m.events) : ''}
                <div style="text-align:center; color:#888; font-size:0.8rem; margin-top:5px;">${t}' Played ${refName}</div>
                ${upsetHtml}
                <div class="pred-row">
                    <span class="pred-text" id="pred-text-${m.fixture.id}">${predText}</span>
                    <span class="conf-badge ${confClass}" id="pred-badge-${m.fixture.id}">${confVal}%</span>
                </div>
                ${analysisBlock}
                <div id="p-${m.fixture.id}" class="player-box"></div>
            `;
            content.appendChild(div);
        }

        async function getStandings(fid, hId, aId, lid, sid) {
            try {
                const res = await fetch(`https://v3.football.api-sports.io/standings?league=${lid}&season=${sid}`, { headers: { "x-rapidapi-key": API_KEY } });
                const data = await res.json();
                if(data.response && data.response.length > 0) {
                    const standings = data.response[0].league.standings[0];
                    const homePos = standings.find(s => s.team.id === hId);
                    const awayPos = standings.find(s => s.team.id === aId);
                    
                    if(homePos) {
                        const hBadge = document.getElementById(`pos-h-${fid}`);
                        if(hBadge) hBadge.innerText = homePos.rank;
                        const match = allMatches.find(m => m.fixture.id === fid);
                        if(match) match.homePos = homePos.rank;
                    }
                    if(awayPos) {
                        const aBadge = document.getElementById(`pos-a-${fid}`);
                        if(aBadge) aBadge.innerText = awayPos.rank;
                        const match = allMatches.find(m => m.fixture.id === fid);
                        if(match) match.awayPos = awayPos.rank;
                    }
                }
            } catch(e) {}
        }

        async function deepAnalyze(btn, id, hName, aName, hGoals, aGoals, hRed, aRed, leagueId, season, hId, aId) {
            trackAPI(3);
            const statBox = document.getElementById(`stats-${id}`);
            if(btn) btn.innerText = "Scanning..."; 

            try {
                let statData, oddsData, standData, h2hData;
                const fetchWithRetry = async (url, retries = 2) => {
                    for(let i=0; i<=retries; i++) {
                        try {
                            const res = await fetch(url, { headers: { "x-rapidapi-key": API_KEY } });
                            if(res.ok) {
                                const d = await res.json();
                                if (d.errors && Object.keys(d.errors).length > 0) {
                                    console.warn(`API Error for ${url}:`, d.errors);
                                    if (d.errors.requests || d.errors.rateLimit) {
                                         await new Promise(r => setTimeout(r, 2000));
                                         continue;
                                    }
                                }
                                return d;
                            }
                        } catch(e) { console.error("Fetch failed:", e); }
                        await new Promise(r => setTimeout(r, 1000));
                    }
                    return null;
                };

                statData = await fetchWithRetry(`https://v3.football.api-sports.io/fixtures/statistics?fixture=${id}`);
                h2hData = (hId && aId) ? await fetchWithRetry(`https://v3.football.api-sports.io/fixtures/headtohead?h2h=${hId}-${aId}&last=5`) : null;
                if(!statData) throw new Error("Stat Fetch Failed");
                
                oddsData = await fetchWithRetry(`https://v3.football.api-sports.io/odds/live?fixture=${id}`);
                standData = await fetchWithRetry(`https://v3.football.api-sports.io/standings?league=${leagueId}&season=${season}`);

                let hStats = [], aStats = [];
                let isSynthetic = false;

                if(!statData.response || statData.response.length === 0) {
                    isSynthetic = true;
                    const playerRes = await fetchWithRetry(`https://v3.football.api-sports.io/fixtures/players?fixture=${id}`);
                    const playerData = playerRes;
                    
                    if(playerData && playerData.response && playerData.response.length > 0) {
                        let hTotalShots = 0, aTotalShots = 0, hOnTarget = 0, aOnTarget = 0, hCorn = 0, aCorn = 0, hFouls = 0, aFouls = 0;
                        
                        // Check if response has two team objects
                        if(playerData.response.length >= 2) {
                            // Home Team
                            playerData.response[0].players.forEach(p => { 
                                const ps = p.statistics[0];
                                hTotalShots += (ps.shots.total||0); 
                                hOnTarget += (ps.shots.on||0); 
                                hCorn += (ps.goals.assists||0);
                                hFouls += (ps.fouls.committed||0);
                            });
                            
                            // Away Team
                            playerData.response[1].players.forEach(p => { 
                                const ps = p.statistics[0];
                                aTotalShots += (ps.shots.total||0); 
                                aOnTarget += (ps.shots.on||0); 
                                aCorn += (ps.goals.assists||0);
                                aFouls += (ps.fouls.committed||0);
                            });
                        }
                        
                        hStats = [{type:"Total Shots",value:hTotalShots}, {type:"Shots on Goal",value:hOnTarget}, {type:"Corner Kicks",value:hCorn}, {type:"Fouls",value:hFouls}, {type:"Passes %",value:65}];
                        aStats = [{type:"Total Shots",value:aTotalShots}, {type:"Shots on Goal",value:aOnTarget}, {type:"Corner Kicks",value:aCorn}, {type:"Fouls",value:aFouls}, {type:"Passes %",value:65}];
                    } else {
                        statBox.innerHTML = "<div class='ignore-msg'>‚ö†Ô∏è MATCH IGNORED: Insufficient Data</div>";
                        const card = document.getElementById(`card-${id}`);
                        if(card) {
                            card.classList.add('ghost');
                            card.style.opacity = "0.4";
                            card.style.filter = "grayscale(1)";
                        }
                        if(btn) btn.innerText = "‚ö° Analyze";
                        return;
                    }
                } else {
                    hStats = statData.response[0].statistics;
                    aStats = statData.response[1].statistics;
                }

                let hRank = "", aRank = "";
                let hForm = "", aForm = "";
                if(standData && standData.response && standData.response.length > 0 && standData.response[0].league && standData.response[0].league.standings && standData.response[0].league.standings.length > 0) {
                    const table = standData.response[0].league.standings[0];
                    const hTeam = table.find(t => t.team.name === hName);
                    const aTeam = table.find(t => t.team.name === aName);
                    const formatForm = (f) => f ? f.split('').map(c => `<span class="form-${c.toLowerCase()}">${c}</span>`).join('') : '';
                    if(hTeam) { hRank = `<span class="rank-badge">[${hTeam.rank}]</span>`; if(hTeam.form) hForm = `<span class="form-badge">${formatForm(hTeam.form.slice(-5))}</span>`; }
                    if(aTeam) { aRank = `<span class="rank-badge">[${aTeam.rank}]</span>`; if(aTeam.form) aForm = `<span class="form-badge">${formatForm(aTeam.form.slice(-5))}</span>`; }
                    
                    // UPDATE CARD RANKS
                    if(hTeam) { const el = document.getElementById(`rank-h-${id}`); if(el) el.innerText = `[#${hTeam.rank}]`; }
                    if(aTeam) { const el = document.getElementById(`rank-a-${id}`); if(el) el.innerText = `[#${aTeam.rank}]`; }
                }

                const getStat = (arr, type) => { 
                    const i = arr.find(s => s.type === type || s.type === type.replace(" ", "")); 
                    if(i && i.value) return parseFloat(i.value);
                    return 0; 
                };

                let hSoT = getStat(hStats, "Shots on Goal");
                let aSoT = getStat(aStats, "Shots on Goal");
                let hTotal = getStat(hStats, "Total Shots");
                let aTotal = getStat(aStats, "Total Shots");
                let hCorn = getStat(hStats, "Corner Kicks");
                let aCorn = getStat(aStats, "Corner Kicks");
                let hFouls = getStat(hStats, "Fouls");
                let aFouls = getStat(aStats, "Fouls");
                let hPass = getStat(hStats, "Passes %") || getStat(hStats, "Ball Possession");
                let aPass = getStat(aStats, "Passes %") || getStat(aStats, "Ball Possession");
                if (typeof hPass === 'string') hPass = parseFloat(hPass) || 50;
                if (typeof aPass === 'string') aPass = parseFloat(aPass) || 50;
                if (isNaN(hPass)) hPass = 50;
                if (isNaN(aPass)) aPass = 50;
                
                // ANALYTICS ENGINE v2
                const matchStats = { homeSoT: hSoT, awaySoT: aSoT, homeTotal: hTotal, awayTotal: aTotal, homeCorners: hCorn, awayCorners: aCorn, homePoss: hPass, awayPoss: aPass };
                const pressure = calculateSmartPressure(matchStats);
                const leagueProfile = getLeagueProfile(leagueId);
                const scoreState = getScoreState(hGoals, aGoals);
                const momentum = calculateMomentum(allMatches.find(mm => mm.fixture.id === id) || { fixture: { id, status: { elapsed: 70 } }, goals: { home: hGoals, away: aGoals } }, matchStats);
                const h2h = analyzeH2H(h2hData, hId);
                const smartResult = generateSmartVerdict(allMatches.find(mm => mm.fixture.id === id) || { fixture: { id, status: { elapsed: 70 } }, goals: { home: hGoals, away: aGoals }, teams: { home: { name: hName }, away: { name: aName } }, league: { id: leagueId } }, pressure, momentum, scoreState, leagueProfile, h2h);

                const hPercent = pressure.hPercent;
                const aPercent = pressure.aPercent;
                const hxG = pressure.hxG;
                const axG = pressure.axG;

                let h2hHtml = '';
                if (h2h.available) {
                    h2hHtml = `<div class="stat-bar"><span>H2H (Last ${h2h.totalMatches})</span><span class="stat-val">${h2h.hWins}W - ${h2h.draws}D - ${h2h.aWins}W | Avg ${h2h.avgGoals.toFixed(1)} goals</span></div>`;
                }

                const vColor = smartResult.confidence >= 85 ? "var(--green)" : (smartResult.confidence >= 70 ? "var(--gold)" : "#da3633");
                const synthBadge = isSynthetic ? "<span class='synth-badge'>[SYNTH]</span>" : "";
                const leagueBadge = `<span style="font-size:0.7rem; background:rgba(56,139,253,0.15); color:var(--blue); padding:2px 6px; border-radius:4px; margin-left:5px;">${leagueProfile.name} ‚Ä¢ ${leagueProfile.tempo.toUpperCase()} tempo</span>`;
                const momentumBadge = momentum.surgeDetected ? `<div style="text-align:center; margin:5px 0; padding:4px 8px; background:rgba(210,153,34,0.15); border:1px solid var(--gold); border-radius:6px; font-size:0.75rem; color:var(--gold);">‚ö° MOMENTUM SURGE DETECTED${momentum.surgeTeam !== 'none' ? ` (${momentum.surgeTeam === 'home' ? hName : aName})` : ''}</div>` : '';
                const scoreStateHtml = `<div class="stat-bar"><span>Score State</span><span class="stat-val" style="font-size:0.75rem;">${scoreState.desc}</span></div>`;
                const xgHTML = hxG > 0 ? `<div class="stat-bar"><span>xG</span><span class="stat-val">${hxG.toFixed(2)} - ${axG.toFixed(2)}</span></div>` : "";

                let tipsHtml = '';
                if (smartResult.allTips.length > 0) {
                    tipsHtml = `<div style="margin-top:8px; padding:8px; background:rgba(46,160,67,0.08); border:1px solid rgba(46,160,67,0.3); border-radius:8px;">
                        <div style="font-size:0.7rem; color:var(--green); text-transform:uppercase; margin-bottom:5px; font-weight:bold;">AI Bet Tips (${(typeof userConfThreshold !== 'undefined' ? userConfThreshold : 75)}%+ confidence)</div>`;
                    smartResult.allTips.forEach(t => {
                        const tipColor = t.conf >= 90 ? "var(--green)" : (t.conf >= 80 ? "var(--gold)" : "#ccc");
                        tipsHtml += `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.05);">
                            <span style="font-size:0.8rem; font-weight:bold;">${t.tip}</span>
                            <span style="font-size:0.75rem; color:${tipColor}; font-weight:bold;">${t.conf}%</span>
                        </div>
                        <div style="font-size:0.7rem; color:#888; margin-bottom:4px;">${t.reason}</div>`;
                    });
                    tipsHtml += `</div>`;
                }

                statBox.innerHTML = `
                    <div style="text-align:center; margin-bottom:5px; font-weight:bold; color:${vColor}; font-size:1rem;">${smartResult.verdict} ${synthBadge}</div>
                    <div style="text-align:center; margin-bottom:8px;">${leagueBadge}</div>
                    ${momentumBadge}
                    ${h2hHtml}
                    ${scoreStateHtml}
                    <div class="gauge-labels">
                        <span>${hName} ${hRank} ${hForm} (${hPercent}%)</span>
                        <span>${aName} ${aRank} ${aForm} (${aPercent}%)</span>
                    </div>
                    <div class="gauge-container"><div class="gauge-home" style="width:${hPercent}%"></div><div class="gauge-away" style="width:${aPercent}%"></div></div>
                    ${xgHTML}
                    <div class="stat-bar"><span>Shots (Total)</span><span class="stat-val">${hTotal} (${hSoT}) - ${aTotal} (${aSoT})</span></div>
                    <div class="stat-bar"><span>Corners</span><span class="stat-val">${hCorn} - ${aCorn}</span></div>
                    ${tipsHtml}
                    <button class="copy-btn" onclick="copyTip('${hName}', '${aName}', '${smartResult.verdict}', ${smartResult.confidence})">üìã Copy Report</button>
                `;
                const newConf = smartResult.confidence;
                
                const predText = document.getElementById(`pred-text-${id}`);
                if(predText) { predText.innerText = smartResult.verdict; predText.style.color = vColor; }
                
                // Recalculate counts whenever a card is enriched/updated
                calculateStrategyCounts();
                
            } catch(e) { 
                console.error("Analysis Error:", e);
                statBox.innerHTML = "<div style='color:#da3633;'>Error analyzing.</div>"; 
            }
            if(btn) btn.innerText = "‚ö° Analyze";
        }

        async function checkPlayers(btn, id) {
            trackAPI(1);
            const area = document.getElementById(`p-${id}`);
            
            // TOGGLE LOGIC
            if(area.style.display === 'block') {
                area.style.display = 'none';
                btn.innerText = "üïµÔ∏è Check Players";
                return;
            }
            
            area.style.display = 'block';
            btn.innerText = "‚ùå Close Players";
            area.innerHTML = "<div style='color:#888; text-align:center;'>Scanning Players...</div>";

            try {
                const res = await fetch(`https://v3.football.api-sports.io/fixtures/players?fixture=${id}`, { headers: { "x-rapidapi-key": API_KEY } });
                const data = await res.json();
                
                let players = [];
                if(data.response && data.response.length > 0) {
                    data.response.forEach(t => t.players.forEach(p => {
                        const s = p.statistics[0];
                        // THREAT RATING (Goals/Assists only)
                        const hts = (s.shots.on || 0) * 3 + (s.shots.total - (s.shots.on||0) || 0) * 1 + (s.passes.key || 0) * 2 + (s.dribbles.success || 0) * 0.5;
                        const rating = Math.min(10, hts).toFixed(1);

                        if (hts > 2) {
                            players.push({
                                name: p.player.name,
                                team: t.team.name,
                                rating: rating,
                                rawScore: hts,
                                details: `${s.shots.on||0} SoT, ${s.passes.key||0} KP`
                            });
                        }
                    }));
                }

                players.sort((a, b) => b.rawScore - a.rawScore);
                
                let html = "";
                if (players.length === 0) {
                    html = "<div style='text-align:center; color:#888;'>No significant player stats yet.</div>";
                } else {
                    players.slice(0, 5).forEach(p => { 
                        let badgeClass = "rate-med";
                        let typeText = "Threat";
                        if (p.rawScore >= 8) { badgeClass = "rate-high"; typeText = "üî• GOAL THREAT"; }
                        else if (p.rawScore >= 5) { badgeClass = "rate-med"; typeText = "üÖ∞Ô∏è CREATOR"; }

                        html += `
                            <div class="player-row">
                                <div>
                                    <div class="player-name">${p.name} <span style="font-size:0.7rem; color:#666">(${p.team})</span></div>
                                    <div class="player-detail">${p.details}</div>
                                </div>
                                <div style="text-align:right;">
                                    <div class="player-rating ${badgeClass}">${typeText}</div>
                                    <div style="font-size:0.7rem; color:#888; margin-top:2px;">RATING: ${p.rating}</div>
                                </div>
                            </div>
                        `;
                    });
                }
                area.innerHTML = html;

            } catch(e) { area.innerHTML = "<div style='color:#da3633; text-align:center;'>Error checking players.</div>"; }
        }

        // --- NEW CARD SCANNER (ELITE ONLY) ---
        async function scanGlobalCards(btn) {
            btn.innerText = "‚ö†Ô∏è Scanning Elite Leagues...";
            const area = document.getElementById('cardContent');
            area.innerHTML = "<div style='text-align:center; padding:20px; color:#888'>Scanning player discipline across Elite matches... This may take a moment.</div>";
            
            // ELITE FILTER
            const liveIDs = allMatches
                .filter(m => ELITE_IDS.includes(m.league.id))
                .map(m => m.fixture.id);

            if(liveIDs.length === 0) {
                area.innerHTML = "<div style='text-align:center; padding:20px; color:#da3633'>No live Elite matches to scan.</div>";
                btn.innerText = "‚ö†Ô∏è SCAN GLOBAL CARD RISKS";
                return;
            }

            let riskPlayers = [];
            
            // BATCH REQUESTS
            for (let i = 0; i < liveIDs.length; i += 5) {
                const batch = liveIDs.slice(i, i + 5);
                const promises = batch.map(id => 
                    fetch(`https://v3.football.api-sports.io/fixtures/players?fixture=${id}`, { headers: { "x-rapidapi-key": API_KEY } })
                    .then(r => r.json())
                    .catch(e => null)
                );
                trackAPI(batch.length);
                
                const results = await Promise.all(promises);
                const pBets = getMarkedPlayers();
                
                results.forEach(data => {
                    if(data && data.response) {
                        const match = allMatches.find(m => m.fixture.id === data.parameters.fixture);
                        let refName = match && match.fixture.referee ? match.fixture.referee.split(',')[0] : "Unknown Ref";
                        let refStrict = "";

                        let liveFouls = 0;
                        let liveCards = 0;
                        data.response.forEach(t => t.players.forEach(p => {
                            const s = p.statistics[0];
                            liveFouls += (s.fouls && s.fouls.committed) || 0;
                            if (s.cards && s.cards.yellow) liveCards++;
                            if (s.cards && s.cards.red) liveCards++;
                        }));

                        const knownRef = getRefProfile(match ? match.fixture.referee : null);
                        if (knownRef) {
                            if (knownRef.strictness === 'strict') refStrict = `<div class="ref-badge ref-strict">üëÆ STRICT ‚Äî avg ${knownRef.avgCards.toFixed(1)} cards/game${knownRef.learned ? ' (learned)' : ''}</div>`;
                            else if (knownRef.strictness === 'lenient') refStrict = `<div class="ref-badge ref-lenient">üí§ LENIENT ‚Äî avg ${knownRef.avgCards.toFixed(1)} cards/game${knownRef.learned ? ' (learned)' : ''}</div>`;
                            else refStrict = `<div class="ref-badge">‚öñÔ∏è MODERATE ‚Äî avg ${knownRef.avgCards.toFixed(1)} cards/game${knownRef.learned ? ' (learned)' : ''}</div>`;
                        }
                        if (liveFouls > 0) {
                            const liveRatio = liveCards / Math.max(1, liveFouls);
                            const elapsed = match ? (match.fixture.status.elapsed || 45) : 45;
                            const projCards = Math.round((liveCards / Math.max(1, elapsed)) * 90 * 10) / 10;
                            let liveBadge = '';
                            if (liveRatio > 0.25 || projCards >= 5) liveBadge = `<div class="ref-badge ref-strict">‚ö° LIVE: ${liveCards} cards from ${liveFouls} fouls (${Math.round(liveRatio*100)}%) ‚Äî pace: ~${projCards.toFixed(1)} cards/game</div>`;
                            else if (liveRatio < 0.10 && liveFouls >= 8) liveBadge = `<div class="ref-badge ref-lenient">‚ö° LIVE: ${liveCards} cards from ${liveFouls} fouls (${Math.round(liveRatio*100)}%) ‚Äî lenient today</div>`;
                            else if (liveFouls >= 4) liveBadge = `<div class="ref-badge">‚ö° LIVE: ${liveCards} cards / ${liveFouls} fouls (${Math.round(liveRatio*100)}%)</div>`;
                            refStrict += liveBadge;
                        }
                        if (liveFouls > 0) {
                            learnRefProfile(refName, liveCards, liveFouls);
                        }

                        const liveRatioVal = liveFouls > 0 ? (liveCards / Math.max(1, liveFouls)) : 0;
                        const elapsedMin = match ? (match.fixture.status.elapsed || 45) : 45;
                        const projCardsVal = liveFouls > 0 ? Math.round((liveCards / Math.max(1, elapsedMin)) * 90 * 10) / 10 : 0;
                        const meterPct = Math.min(100, Math.round(liveRatioVal * 300));
                        const meterColor = meterPct >= 75 ? '#da3633' : (meterPct >= 40 ? '#d29922' : '#3fb950');
                        const meterLabel = meterPct >= 75 ? 'HOT' : (meterPct >= 40 ? 'WARM' : 'COOL');
                        const matchHeader = match ? `${match.teams.home.name} vs ${match.teams.away.name}` : 'Unknown Match';
                        const matchId = data.parameters.fixture;

                        data.response.forEach(t => t.players.forEach(p => {
                            const s = p.statistics[0];
                            if (s.fouls.committed >= 2 && !s.cards.yellow && !s.cards.red) {
                                const time = match ? match.fixture.status.elapsed + "'" : "Live";
                                const uid = `${matchId}-${p.player.id}`;
                                const isMarked = pBets.includes(uid);
                                
                                const playerFouls = s.fouls.committed || 0;
                                const cardProb = Math.min(95, Math.round(playerFouls * (liveRatioVal > 0 ? liveRatioVal : 0.18) * 100 + (playerFouls >= 3 ? 15 : 0) + (elapsedMin >= 70 ? 10 : 0)));

                                riskPlayers.push({
                                    uid: uid,
                                    name: p.player.name,
                                    team: t.team.name,
                                    time: time,
                                    fouls: playerFouls,
                                    ref: refName,
                                    refBadge: refStrict,
                                    isMarked: isMarked,
                                    isSubbed: s.games.minutes === null || (s.games.sub && s.games.sub === "out") || false,
                                    pos: s.games.position || "",
                                    cardProb: cardProb,
                                    matchHeader: matchHeader,
                                    matchId: matchId,
                                    meterPct: meterPct,
                                    meterColor: meterColor,
                                    meterLabel: meterLabel
                                });
                            }
                        }));
                    }
                });
            }

            riskPlayers.sort((a, b) => {
                if (a.matchId !== b.matchId) return a.matchId - b.matchId;
                return b.fouls - a.fouls;
            });

            let html = "";
            if(riskPlayers.length === 0) {
                html = "<div style='text-align:center; padding:20px; color:#888'>No high-risk players found in Elite leagues yet.</div>";
            } else {
                let lastMatchId = null;
                riskPlayers.forEach(p => {
                    const activeClass = p.isMarked ? 'active' : '';
                    const markClass = p.isMarked ? 'marked' : '';
                    const subbedClass = p.isSubbed ? 'subbed-off' : '';
                    const tick = p.isMarked ? '‚úì' : '';
                    const subLabel = p.isSubbed ? ' <span style="color:var(--red); font-size:0.7rem;">[SUBBED OFF]</span>' : '';
                    const posLabel = p.pos ? `<span class="pos-badge" style="color:var(--cyan); border:1px solid var(--cyan); background:rgba(63, 185, 80, 0.1); padding:1px 6px; font-size:0.7rem; margin-left:5px;">${p.pos}</span>` : '';

                    if (p.matchId !== lastMatchId) {
                        lastMatchId = p.matchId;
                        html += `
                            <div style="padding:10px 12px 6px; margin-top:8px; border-bottom:1px solid #333;">
                                <div style="font-size:0.85rem; font-weight:600; color:#e6edf3;">${p.matchHeader} <span style="color:#888; font-weight:normal">${p.time}</span></div>
                                <div style="font-size:0.7rem; color:#888; margin:2px 0;">Ref: ${p.ref}</div>
                                ${p.refBadge}
                                <div style="margin-top:6px;">
                                    <div style="display:flex; justify-content:space-between; font-size:0.65rem; color:#888; margin-bottom:2px;">
                                        <span>Temperament</span>
                                        <span style="color:${p.meterColor}; font-weight:600;">${p.meterLabel}</span>
                                    </div>
                                    <div style="height:6px; background:#222; border-radius:3px; overflow:hidden;">
                                        <div style="height:100%; width:${p.meterPct}%; background:${p.meterColor}; border-radius:3px; transition:width 0.5s;"></div>
                                    </div>
                                </div>
                            </div>`;
                    }

                    let foulClass = '';
                    let riskLabel = '';
                    if (p.fouls >= 3) {
                        foulClass = 'danger';
                        riskLabel = ' üî¥';
                    } else if (p.fouls === 2) {
                        const isHighRisk = p.pos && (p.pos.toUpperCase().includes('DEF') || p.pos.toUpperCase().includes('MID') || p.pos === 'D' || p.pos === 'M');
                        if (isHighRisk) {
                            foulClass = 'critical';
                            riskLabel = ' üü†';
                        } else {
                            foulClass = 'warning';
                            riskLabel = ' üü°';
                        }
                    }
                    
                    const probColor = p.cardProb >= 60 ? '#da3633' : (p.cardProb >= 35 ? '#d29922' : '#3fb950');
                    html += `
                        <div class="card-table-row ${markClass} ${subbedClass}">
                            <div class="card-check-btn ${activeClass}" onclick="togglePlayerBet('${p.uid}', this)">${tick}</div>
                            <div class="card-player-info">
                                <div class="card-player-name">${p.name}${subLabel} ${posLabel} <span style="font-weight:normal; color:#666">(${p.team})</span></div>
                                <div style="display:flex; align-items:center; gap:8px; margin-top:3px;">
                                    <div class="card-foul-badge ${foulClass}" style="margin:0;">${p.fouls} Fouls${riskLabel}</div>
                                    <div style="font-size:0.65rem; color:${probColor}; font-weight:600;">üÉè ${p.cardProb}% card risk</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            area.innerHTML = html;
            btn.innerText = "‚ö†Ô∏è SCAN GLOBAL CARD RISKS";
        }

        function getMarkedPlayers() { return JSON.parse(localStorage.getItem('cardBets') || "[]"); }
        function togglePlayerBet(uid, el) {
            let pBets = getMarkedPlayers();
            if(pBets.includes(uid)) {
                pBets = pBets.filter(b => b !== uid);
                el.classList.remove('active');
                el.innerText = "";
                el.parentElement.classList.remove('marked');
            } else {
                pBets.push(uid);
                el.classList.add('active');
                el.innerText = "‚úì";
                el.parentElement.classList.add('marked');
            }
            localStorage.setItem('cardBets', JSON.stringify(pBets));
        }

        // ========== ¬£5 TO ¬£500 CHALLENGE ==========
        const CHALLENGE_START = 5;
        const CHALLENGE_TARGET = 500;
        
        let rejectedFixtures = []; // Track rejected fixtures in this session
        
        function getChallengeState() {
            return JSON.parse(localStorage.getItem('challenge') || JSON.stringify({
                active: false,
                stake: CHALLENGE_START,
                history: [],
                lostDate: null,
                currentBet: null
            }));
        }
        
        function saveChallengeState(state) {
            localStorage.setItem('challenge', JSON.stringify(state));
        }
        
        function loadChallengeState() {
            const state = getChallengeState();
            updateChallengeUI(state);
        }
        
        function updateChallengeUI(state) {
            const stakeEl = document.getElementById('currentStake');
            const progressEl = document.getElementById('challengeProgress');
            const percentEl = document.getElementById('progressPercent');
            const historyEl = document.getElementById('challengeHistory');
            
            stakeEl.innerText = `¬£${state.stake.toFixed(2)}`;
            const progress = Math.min(100, ((state.stake - CHALLENGE_START) / (CHALLENGE_TARGET - CHALLENGE_START)) * 100);
            progressEl.style.width = `${Math.max(1, progress)}%`;
            percentEl.innerText = `${progress.toFixed(0)}%`;
            renderMilestones(state.stake);
            
            // Show appropriate screen
            document.getElementById('challengeStartScreen').style.display = 'none';
            document.getElementById('challengeActiveScreen').style.display = 'none';
            document.getElementById('challengeLostScreen').style.display = 'none';
            document.getElementById('challengeWonScreen').style.display = 'none';
            document.getElementById('suggestedBet').style.display = 'none';
            
            if (state.stake >= CHALLENGE_TARGET) {
                document.getElementById('challengeWonScreen').style.display = 'block';
                document.getElementById('finalAmount').innerText = `¬£${state.stake.toFixed(2)}`;
            } else if (state.lostDate) {
                const today = new Date().toISOString().split('T')[0];
                if (state.lostDate === today) {
                    document.getElementById('challengeLostScreen').style.display = 'block';
                    document.getElementById('lostAmount').innerText = `¬£${state.history.length > 0 ? state.history[state.history.length-1].stakeBefore.toFixed(2) : '5.00'}`;
                    document.getElementById('nextChallengeTime').innerText = "Come back tomorrow to try again!";
                } else {
                    // Auto-reset on new day after loss
                    state.stake = CHALLENGE_START;
                    state.active = false;
                    state.lostDate = null;
                    state.currentBet = null;
                    state.history = [];
                    saveChallengeState(state);
                    stakeEl.innerText = `¬£${CHALLENGE_START.toFixed(2)}`;
                    progressEl.style.width = '1%';
                    percentEl.innerText = '1%';
                    document.getElementById('challengeStartScreen').style.display = 'block';
                }
            } else if (!state.active) {
                document.getElementById('challengeStartScreen').style.display = 'block';
            } else {
                document.getElementById('challengeActiveScreen').style.display = 'block';
                if (state.currentBet) {
                    displaySuggestedBet(state.currentBet, state.stake);
                }
            }
            
            let histHtml = '';
            if (state.history.length === 0) {
                histHtml = '<div style="text-align:center; color:#666; padding:20px;">No bets yet. Start your challenge!</div>';
            } else {
                const grouped = {};
                state.history.forEach(bet => {
                    const d = bet.date || 'Unknown';
                    if (!grouped[d]) grouped[d] = [];
                    grouped[d].push(bet);
                });
                const sortedDates = Object.keys(grouped).sort((a, b) => b.localeCompare(a));
                sortedDates.forEach(date => {
                    const dayBets = grouped[date];
                    let dayWins = 0, dayLosses = 0, dayDelta = 0;
                    dayBets.forEach(b => {
                        if (b.result === 'won') { dayWins++; dayDelta += (b.stakeAfter - b.stakeBefore); }
                        else { dayLosses++; dayDelta -= b.stakeBefore; }
                    });
                    const deltaStr = dayDelta >= 0 ? `+¬£${dayDelta.toFixed(2)}` : `-¬£${Math.abs(dayDelta).toFixed(2)}`;
                    const deltaColor = dayDelta >= 0 ? 'var(--green)' : 'var(--red)';
                    const dateLabel = date === new Date().toISOString().split('T')[0] ? 'Today' : date;
                    const uid = 'chist-' + date.replace(/[^a-z0-9]/gi, '');
                    histHtml += `
                        <div style="border-bottom:1px solid #30363d;">
                            <div onclick="document.getElementById('${uid}').style.display = document.getElementById('${uid}').style.display === 'none' ? 'block' : 'none'; this.querySelector('.chev').textContent = document.getElementById('${uid}').style.display === 'none' ? '‚ñ∂' : '‚ñº'" style="padding:12px 14px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; user-select:none;">
                                <div style="display:flex; align-items:center; gap:8px;">
                                    <span class="chev" style="color:#888; font-size:0.7rem;">‚ñ∂</span>
                                    <span style="color:white; font-weight:bold; font-size:0.9rem;">üìÖ ${dateLabel}</span>
                                    <span style="color:#888; font-size:0.8rem;">${dayBets.length} bet${dayBets.length !== 1 ? 's' : ''}</span>
                                    <span style="font-size:0.75rem; color:#888;">${dayWins}W ${dayLosses}L</span>
                                </div>
                                <span style="font-weight:bold; color:${deltaColor}; font-size:0.95rem;">${deltaStr}</span>
                            </div>
                            <div id="${uid}" style="display:none;">`;
                    dayBets.slice().reverse().forEach(bet => {
                        const resultClass = bet.result === 'won' ? 'color:var(--green)' : 'color:var(--red)';
                        const resultIcon = bet.result === 'won' ? '‚úÖ' : '‚ùå';
                        histHtml += `
                            <div style="padding:10px 14px 10px 32px; border-top:1px solid #1c2128; display:flex; justify-content:space-between; align-items:center; background:#0d1117;">
                                <div>
                                    <div style="font-weight:bold; color:#ccc; font-size:0.85rem;">${bet.match}</div>
                                    <div style="font-size:0.78rem; color:var(--blue);">${bet.selection} @ ${bet.odds}</div>
                                </div>
                                <div style="text-align:right;">
                                    <div style="${resultClass}; font-weight:bold; font-size:0.85rem;">${resultIcon} ${bet.result.toUpperCase()}</div>
                                    <div style="font-size:0.78rem; color:#888;">¬£${bet.stakeBefore.toFixed(2)} ‚Üí ¬£${bet.stakeAfter.toFixed(2)}</div>
                                </div>
                            </div>`;
                    });
                    histHtml += `</div></div>`;
                });
            }
            historyEl.innerHTML = histHtml;
        }
        
        function startChallenge() {
            const state = {
                active: true,
                stake: CHALLENGE_START,
                history: [],
                lostDate: null,
                currentBet: null
            };
            saveChallengeState(state);
            updateChallengeUI(state);
        }
        
        function resetChallenge(forceReset = false) {
            const state = getChallengeState();
            const today = new Date().toISOString().split('T')[0];
            
            if (forceReset || state.lostDate !== today) {
                const newState = {
                    active: false,
                    stake: CHALLENGE_START,
                    history: [],
                    lostDate: null,
                    currentBet: null
                };
                saveChallengeState(newState);
                updateChallengeUI(newState);
            }
        }
        
        async function findNextBet(btn) {
            btn.innerText = "üîç Scanning Live Markets...";
            btn.disabled = true;
            
            try {
                trackAPI(1);
                const res = await fetch("https://v3.football.api-sports.io/fixtures?live=all", {
                    headers: { "x-rapidapi-key": API_KEY, "x-rapidapi-host": "v3.football.api-sports.io" }
                });
                const data = await res.json();
                
                if (!data.response || data.response.length === 0) {
                    btn.innerText = "‚ùå No live games found. Try again later.";
                    setTimeout(() => { btn.innerText = "üîç FIND NEXT BET"; btn.disabled = false; }, 3000);
                    return;
                }
                
                // Filter to all leagues in 30-85 min window, excluding rejected fixtures
                const eligible = data.response.filter(m => {
                    const elapsed = m.fixture.status.elapsed;
                    return elapsed >= 30 && elapsed <= 85 && !rejectedFixtures.includes(m.fixture.id);
                });
                
                if (eligible.length === 0) {
                    btn.innerText = "‚ùå No live games in window. Try again later.";
                    setTimeout(() => { btn.innerText = "üîç FIND NEXT BET"; btn.disabled = false; }, 3000);
                    return;
                }
                
                btn.innerText = `üîç Analyzing ${Math.min(8, eligible.length)} matches...`;
                const analyzed = [];
                for (let i = 0; i < Math.min(8, eligible.length); i++) {
                    const m = eligible[i];
                    try {
                        trackAPI(1);
                        const statRes = await fetch(`https://v3.football.api-sports.io/fixtures/statistics?fixture=${m.fixture.id}`, {
                            headers: { "x-rapidapi-key": API_KEY }
                        });
                        const statData = await statRes.json();
                        
                        if (statData.response && statData.response.length >= 2) {
                            const hStats = statData.response[0].statistics;
                            const aStats = statData.response[1].statistics;
                            
                            const getStat = (arr, type) => {
                                const item = arr.find(s => s.type === type);
                                if (item && item.value !== null && item.value !== undefined) {
                                    const v = typeof item.value === 'string' ? parseFloat(item.value) : item.value;
                                    return isNaN(v) ? 0 : v;
                                }
                                return 0;
                            };
                            
                            const stats = {
                                homeSoT: getStat(hStats, "Shots on Goal"),
                                awaySoT: getStat(aStats, "Shots on Goal"),
                                homeCorners: getStat(hStats, "Corner Kicks"),
                                awayCorners: getStat(aStats, "Corner Kicks"),
                                homePoss: getStat(hStats, "Ball Possession") || 50,
                                awayPoss: getStat(aStats, "Ball Possession") || 50,
                                homeTotal: getStat(hStats, "Total Shots"),
                                awayTotal: getStat(aStats, "Total Shots"),
                                homeShotsInBox: getStat(hStats, "Shots insidebox"),
                                awayShotsInBox: getStat(aStats, "Shots insidebox"),
                                homeShotsOutBox: getStat(hStats, "Shots outsidebox"),
                                awayShotsOutBox: getStat(aStats, "Shots outsidebox"),
                                homeBigChances: getStat(hStats, "expected_goals") > 0 ? Math.round(getStat(hStats, "expected_goals") / 0.35) : 0,
                                awayBigChances: getStat(aStats, "expected_goals") > 0 ? Math.round(getStat(aStats, "expected_goals") / 0.35) : 0
                            };
                            
                            const totalSoT = stats.homeSoT + stats.awaySoT;
                            const totalShots = stats.homeTotal + stats.awayTotal;
                            const totalCorners = stats.homeCorners + stats.awayCorners;
                            const hasPoss = stats.homePoss > 0 && stats.awayPoss > 0 && stats.homePoss !== 50;
                            
                            const dataPoints = (totalShots > 0 ? 1 : 0) + (totalSoT > 0 ? 1 : 0) + (totalCorners > 0 ? 1 : 0) + (hasPoss ? 1 : 0);
                            
                            if (dataPoints >= 3 && totalShots >= 5) {
                                m.analyzedStats = stats;
                                m.dataQuality = dataPoints;
                                analyzed.push(m);
                            }
                        }
                        await new Promise(r => setTimeout(r, 400));
                    } catch(e) {
                        console.warn("Stats fetch failed for fixture", m.fixture.id);
                    }
                }
                
                if (analyzed.length === 0) {
                    btn.innerText = "‚ùå No matches with enough stats. Try later.";
                    setTimeout(() => { btn.innerText = "üîç FIND NEXT BET"; btn.disabled = false; }, 3000);
                    return;
                }
                
                const bestBet = findBestBetWithStats(analyzed);
                
                if (!bestBet) {
                    btn.innerText = "‚ùå No confident selection found. Try again.";
                    setTimeout(() => { btn.innerText = "üîç FIND NEXT BET"; btn.disabled = false; }, 3000);
                    return;
                }
                
                // Save and display
                const state = getChallengeState();
                state.currentBet = bestBet;
                saveChallengeState(state);
                displaySuggestedBet(bestBet, state.stake);
                
            } catch(e) {
                console.error("Challenge scan error:", e);
                btn.innerText = "‚ùå Error scanning. Try again.";
                setTimeout(() => { btn.innerText = "üîç FIND NEXT BET"; btn.disabled = false; }, 3000);
                return;
            }
            
            btn.innerText = "üîç FIND NEXT BET";
            btn.disabled = false;
        }
        
        function findBestBetWithStats(matches) {
            let candidates = [];
            
            matches.forEach(m => {
                const stats = m.analyzedStats;
                if (!stats) return;
                
                const fixtureId = m.fixture.id;
                const elapsed = m.fixture.status.elapsed;
                const totalGoals = m.goals.home + m.goals.away;
                const homeName = m.teams.home.name;
                const awayName = m.teams.away.name;
                const matchName = `${homeName} vs ${awayName}`;
                const league = `${m.league.country} ‚Ä¢ ${m.league.name}`;
                
                const leagueProfile = getLeagueProfile(m.league.id);
                const scoreState = getScoreState(m.goals.home, m.goals.away);
                const pressure = calculateSmartPressure(stats);
                const momentum = calculateMomentum(m, stats);

                const totalSoT = stats.homeSoT + stats.awaySoT;
                const totalShots = stats.homeTotal + stats.awayTotal;
                const totalCorners = stats.homeCorners + stats.awayCorners;

                const timeMultiplier = elapsed >= 75 ? 1.12 : (elapsed >= 70 ? 1.06 : 1.0);
                const leagueBoost = leagueProfile.tempo === "high" ? 1.06 : (leagueProfile.tempo === "low" ? 0.92 : 1.0);
                const lateGoalBoost = leagueProfile.lateGoalRate > 0.30 ? 1.08 : 1.0;
                
                const getRealisticOdds = (market, elapsed) => {
                    if (market === 'o05') {
                        if (elapsed >= 80) return (1.01 + Math.random() * 0.03).toFixed(2);
                        if (elapsed >= 75) return (1.05 + Math.random() * 0.05).toFixed(2);
                        return (1.12 + Math.random() * 0.08).toFixed(2);
                    }
                    if (market === 'o15') {
                        if (elapsed >= 75) return (1.20 + Math.random() * 0.10).toFixed(2);
                        if (elapsed >= 65) return (1.33 + Math.random() * 0.12).toFixed(2);
                        return (1.45 + Math.random() * 0.15).toFixed(2);
                    }
                    if (market === 'o25') {
                        if (elapsed >= 70) return (1.50 + Math.random() * 0.20).toFixed(2);
                        if (elapsed >= 60) return (1.65 + Math.random() * 0.20).toFixed(2);
                        return (1.80 + Math.random() * 0.20).toFixed(2);
                    }
                    if (market === 'btts') return (1.50 + Math.random() * 0.25).toFixed(2);
                    if (market === 'next') return (1.60 + Math.random() * 0.30).toFixed(2);
                    if (market === 'goalscorer') {
                        if (elapsed >= 75) return (2.20 + Math.random() * 0.50).toFixed(2);
                        if (elapsed >= 65) return (2.50 + Math.random() * 0.60).toFixed(2);
                        return (2.80 + Math.random() * 0.70).toFixed(2);
                    }
                    return (1.40 + Math.random() * 0.30).toFixed(2);
                };

                // === OVER 0.5 GOALS (0-0 games, late, with shot activity) ===
                if (totalGoals === 0 && elapsed >= 65 && totalSoT >= 3) {
                    let conf = Math.min(92, Math.round(scoreState.goalProb * 100 * timeMultiplier * lateGoalBoost));
                    let reason = `0-0 at ${elapsed}' in ${leagueProfile.name} (${Math.round(leagueProfile.lateGoalRate * 100)}% late goal rate).`;
                    if (totalSoT >= 8) {
                        conf = Math.min(94, conf + 6);
                        reason += ` ${totalSoT} SoT - breakthrough imminent!`;
                    } else if (totalSoT >= 5) {
                        conf = Math.min(93, conf + 4);
                        reason += ` ${totalSoT} shots on target already.`;
                    } else {
                        reason += ` ${totalSoT} SoT, ${totalShots} total shots.`;
                    }
                    if (momentum.surgeDetected) { conf = Math.min(94, conf + 3); reason += ` ‚ö° Momentum surge!`; }
                    candidates.push({ fixtureId, match: matchName, league, selection: "Over 0.5 Goals", odds: getRealisticOdds('o05', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                }
                
                // === OVER 1.5 GOALS (1 goal scored, evidence of more coming) ===
                if (totalGoals === 1 && elapsed >= 50 && elapsed <= 80 && totalSoT >= 4) {
                    let conf = Math.min(90, Math.round(scoreState.goalProb * 100 * timeMultiplier * leagueBoost));
                    const chasingTeam = m.goals.home < m.goals.away ? homeName : awayName;
                    const chasingStats = m.goals.home < m.goals.away ? `${stats.homeSoT} SoT` : `${stats.awaySoT} SoT`;
                    let reason = `${m.goals.home}-${m.goals.away} at ${elapsed}'. ${chasingTeam} chasing (${chasingStats}).`;
                    if (totalSoT >= 7) { conf = Math.min(92, conf + 4); reason += ` Open game, ${totalSoT} SoT total.`; }
                    if (totalShots >= 18) { conf = Math.min(92, conf + 3); reason += ` ${totalShots} total shots.`; }
                    if (momentum.surgeDetected) { conf = Math.min(92, conf + 3); reason += ` ‚ö° Momentum surge!`; }
                    candidates.push({ fixtureId, match: matchName, league, selection: "Over 1.5 Goals", odds: getRealisticOdds('o15', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                }
                
                // === OVER 2.5 GOALS (2 goals, open game with lots of chances) ===
                if (totalGoals === 2 && elapsed >= 45 && elapsed <= 75 && totalSoT >= 6 && totalShots >= 14) {
                    let conf = Math.min(88, Math.round(scoreState.goalProb * 100 * leagueBoost));
                    let reason = `${m.goals.home}-${m.goals.away} at ${elapsed}'. ${scoreState.desc}`;
                    if (totalShots >= 22) { conf = Math.min(90, conf + 4); reason += ` Very open - ${totalShots} shots, ${totalSoT} on target.`; }
                    else { reason += ` ${totalShots} shots, ${totalSoT} SoT.`; }
                    if (totalCorners >= 8) { conf = Math.min(90, conf + 2); reason += ` ${totalCorners} corners.`; }
                    candidates.push({ fixtureId, match: matchName, league, selection: "Over 2.5 Goals", odds: getRealisticOdds('o25', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                }

                // === BTTS (one team yet to score but showing genuine attacking intent) ===
                if (totalGoals >= 1 && m.goals.home === 0 && elapsed >= 55 && elapsed <= 78) {
                    if (stats.homeSoT >= 2 && stats.homeTotal >= 4) {
                        let conf = Math.min(85, Math.round(scoreState.bttsProb * 100 * timeMultiplier));
                        let reason = `${homeName} 0 goals but ${stats.homeSoT} SoT and ${stats.homeTotal} shots.`;
                        if (pressure.dominance === "home_siege" || pressure.dominance === "home_edge") { conf = Math.min(88, conf + 4); reason += ` Home pressure ${pressure.hPercent}%.`; }
                        if (momentum.surgeTeam === "home") { conf = Math.min(88, conf + 3); reason += ` ‚ö° Home momentum surge!`; }
                        if (conf >= 78) {
                            candidates.push({ fixtureId, match: matchName, league, selection: "Both Teams to Score", odds: getRealisticOdds('btts', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                        }
                    }
                } else if (totalGoals >= 1 && m.goals.away === 0 && elapsed >= 55 && elapsed <= 78) {
                    if (stats.awaySoT >= 2 && stats.awayTotal >= 4) {
                        let conf = Math.min(83, Math.round(scoreState.bttsProb * 100 * timeMultiplier));
                        let reason = `${awayName} 0 goals but ${stats.awaySoT} SoT and ${stats.awayTotal} shots.`;
                        if (pressure.dominance === "away_siege" || pressure.dominance === "away_edge") { conf = Math.min(86, conf + 4); reason += ` Away pressure ${pressure.aPercent}%.`; }
                        if (momentum.surgeTeam === "away") { conf = Math.min(86, conf + 3); reason += ` ‚ö° Away momentum surge!`; }
                        if (conf >= 78) {
                            candidates.push({ fixtureId, match: matchName, league, selection: "Both Teams to Score", odds: getRealisticOdds('btts', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                        }
                    }
                }

                // === NEXT GOAL (only when one side has CLEAR dominance backed by real stats) ===
                if (pressure.dominance === "home_siege" && stats.homeSoT >= 3 && elapsed >= 55 && m.goals.home <= m.goals.away) {
                    let conf = Math.min(87, Math.round(76 * timeMultiplier * leagueBoost));
                    let reason = `${homeName} siege: ${stats.homeSoT} SoT, ${stats.homeTotal} shots, ${stats.homeCorners} corners (${pressure.hPercent}% pressure).`;
                    if (momentum.surgeTeam === "home") { conf = Math.min(90, conf + 4); reason += ` ‚ö° Home momentum surge!`; }
                    if (stats.homePoss >= 60) { conf = Math.min(90, conf + 2); reason += ` ${stats.homePoss}% possession.`; }
                    candidates.push({ fixtureId, match: matchName, league, selection: `Next Goal: ${homeName}`, odds: getRealisticOdds('next', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                }
                
                if (pressure.dominance === "away_siege" && stats.awaySoT >= 3 && elapsed >= 55 && m.goals.away <= m.goals.home) {
                    let conf = Math.min(85, Math.round(74 * timeMultiplier * leagueBoost));
                    let reason = `${awayName} siege: ${stats.awaySoT} SoT, ${stats.awayTotal} shots, ${stats.awayCorners} corners (${pressure.aPercent}% pressure).`;
                    if (momentum.surgeTeam === "away") { conf = Math.min(88, conf + 4); reason += ` ‚ö° Away momentum surge!`; }
                    if (stats.awayPoss >= 60) { conf = Math.min(88, conf + 2); reason += ` ${stats.awayPoss}% possession.`; }
                    candidates.push({ fixtureId, match: matchName, league, selection: `Next Goal: ${awayName}`, odds: getRealisticOdds('next', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                }
                
                // === RED CARD ADVANTAGE (concrete advantage, still requires some shot activity) ===
                if (m.events && totalSoT >= 2) {
                    const homeRed = m.events.some(e => e.type === 'Card' && e.detail === 'Red Card' && e.team.id === m.teams.home.id);
                    const awayRed = m.events.some(e => e.type === 'Card' && e.detail === 'Red Card' && e.team.id === m.teams.away.id);
                    
                    if (awayRed && !homeRed && elapsed >= 50 && stats.homeSoT >= 2) {
                        let conf = Math.min(90, Math.round(84 * timeMultiplier));
                        let reason = `üü• ${awayName} 10 men! ${homeName}: ${stats.homeSoT} SoT, ${stats.homeTotal} shots. ${90 - elapsed} mins with man advantage.`;
                        candidates.push({ fixtureId, match: matchName, league, selection: `Next Goal: ${homeName}`, odds: getRealisticOdds('next', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                    }
                    if (homeRed && !awayRed && elapsed >= 50 && stats.awaySoT >= 2) {
                        let conf = Math.min(90, Math.round(84 * timeMultiplier));
                        let reason = `üü• ${homeName} 10 men! ${awayName}: ${stats.awaySoT} SoT, ${stats.awayTotal} shots. ${90 - elapsed} mins with man advantage.`;
                        candidates.push({ fixtureId, match: matchName, league, selection: `Next Goal: ${awayName}`, odds: getRealisticOdds('next', elapsed), confidence: conf, reasoning: reason, totalSoT, totalShots });
                    }
                }
            });
            
            const filtered = candidates.filter(c => c.confidence >= 78);
            filtered.sort((a, b) => {
                if (b.confidence !== a.confidence) return b.confidence - a.confidence;
                return (b.totalSoT + b.totalShots) - (a.totalSoT + a.totalShots);
            });
            return filtered.length > 0 ? filtered[0] : null;
        }
        
        function displaySuggestedBet(bet, stake) {
            document.getElementById('suggestedBet').style.display = 'block';
            document.getElementById('betMatch').innerText = bet.match;
            document.getElementById('betLeague').innerText = bet.league;
            document.getElementById('betType').innerText = bet.selection;
            document.getElementById('betOdds').innerText = `@ ${bet.odds}`;
            document.getElementById('betReasoning').innerText = bet.reasoning;
            document.getElementById('betStake').innerText = `¬£${stake.toFixed(2)}`;
            document.getElementById('betReturn').innerText = `¬£${(stake * parseFloat(bet.odds)).toFixed(2)}`;
        }
        
        async function rejectAndFindNew(btn) {
            const state = getChallengeState();
            if (state.currentBet && state.currentBet.fixtureId) {
                rejectedFixtures.push(state.currentBet.fixtureId);
            }
            state.currentBet = null;
            saveChallengeState(state);
            document.getElementById('suggestedBet').style.display = 'none';
            
            // Find a new bet
            const findBtn = document.querySelector('#challengeActiveScreen .card-scan-btn');
            if (findBtn) {
                await findNextBet(findBtn);
            }
        }
        
        function markBetResult(result) {
            const state = getChallengeState();
            if (!state.currentBet) return;
            
            const bet = state.currentBet;
            const stakeBefore = state.stake;
            let stakeAfter = stakeBefore;
            
            if (result === 'won') {
                stakeAfter = stakeBefore * parseFloat(bet.odds);
                playPing();
            }
            
            // Add to history
            state.history.push({
                match: bet.match,
                selection: bet.selection,
                odds: bet.odds,
                result: result,
                stakeBefore: stakeBefore,
                stakeAfter: result === 'won' ? stakeAfter : stakeBefore,
                date: new Date().toISOString().split('T')[0]
            });
            
            if (result === 'won') {
                state.stake = stakeAfter;
                state.currentBet = null;
                
                // Check if target reached
                if (state.stake >= CHALLENGE_TARGET) {
                    saveChallengeState(state);
                    updateChallengeUI(state);
                    return;
                }
            } else {
                // Lost - set lostDate to today
                state.lostDate = new Date().toISOString().split('T')[0];
                state.active = false;
            }
            
            saveChallengeState(state);
            updateChallengeUI(state);
        }
        // ========== END CHALLENGE ==========

        // ========== CONFIDENCE THRESHOLD ==========
        let userConfThreshold = parseInt(localStorage.getItem('confThreshold') || '75');
        (function initSlider() {
            const sl = document.getElementById('confThreshold');
            const lb = document.getElementById('confThresholdLabel');
            if (sl) { sl.value = userConfThreshold; }
            if (lb) { lb.textContent = userConfThreshold + '%'; }
        })();
        function updateConfThreshold(val) {
            userConfThreshold = parseInt(val);
            localStorage.setItem('confThreshold', val);
            const lb = document.getElementById('confThresholdLabel');
            if (lb) lb.textContent = val + '%';
        }

        // ========== FAVOURITE LEAGUES ==========
        function getFavLeagues() {
            try { return JSON.parse(localStorage.getItem('favLeagues') || '[]'); } catch(e) { return []; }
        }
        function toggleFavLeague(leagueId) {
            let favs = getFavLeagues();
            if (favs.includes(leagueId)) { favs = favs.filter(l => l !== leagueId); }
            else { favs.push(leagueId); }
            localStorage.setItem('favLeagues', JSON.stringify(favs));
        }
        function isFavLeague(leagueId) { return getFavLeagues().includes(leagueId); }

        // ========== BET NOTES ==========
        function saveBetNote(fixtureId, selection, note) {
            const bets = getPlacedChallenges();
            const bet = bets.find(b => b.fixtureId === fixtureId && b.selection === selection);
            if (bet) { bet.note = note; savePlacedChallenges(bets); }
        }

        // ========== NOTIFICATIONS ==========
        let notificationsEnabled = localStorage.getItem('tft_notifications') === 'true';

        async function requestNotificationPermission() {
            if (!('Notification' in window)) return false;
            if (Notification.permission === 'granted') return true;
            if (Notification.permission === 'denied') return false;
            const result = await Notification.requestPermission();
            return result === 'granted';
        }

        function sendNotification(title, body, tag) {
            if (!notificationsEnabled || !('Notification' in window) || Notification.permission !== 'granted') return;
            try {
                const n = new Notification(title, {
                    body: body,
                    icon: './target_PNG26.png',
                    tag: tag || 'tft-alert',
                    renotify: true,
                    silent: false
                });
                setTimeout(() => n.close(), 8000);
            } catch(e) { console.log('Notification error:', e); }
        }

        async function toggleNotifications() {
            const btn = document.getElementById('notifBtn');
            if (notificationsEnabled) {
                notificationsEnabled = false;
                localStorage.setItem('tft_notifications', 'false');
                btn.classList.remove('notif-on');
                btn.innerHTML = 'üîï';
                btn.title = 'Notifications Off';
            } else {
                const granted = await requestNotificationPermission();
                if (granted) {
                    notificationsEnabled = true;
                    localStorage.setItem('tft_notifications', 'true');
                    btn.classList.add('notif-on');
                    btn.innerHTML = 'üîî';
                    btn.title = 'Notifications On';
                    sendNotification('The Final Third', 'Notifications enabled! You\'ll be alerted when tips are found.', 'tft-setup');
                }
            }
        }

        // ========== ALERT SOUNDS ==========
        function playAlertSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            if (type === 'goal') {
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.start(); osc.stop(audioCtx.currentTime + 0.5);
            } else if (type === 'corner') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.1);
                osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
                osc.start(); osc.stop(audioCtx.currentTime + 0.35);
            } else if (type === 'card') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.setValueAtTime(500, audioCtx.currentTime + 0.1);
                osc.frequency.setValueAtTime(400, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                osc.start(); osc.stop(audioCtx.currentTime + 0.4);
            } else {
                playPing();
            }
        }

        // ========== MATCH TIMELINE ==========
        function renderTimeline(events) {
            if (!events || events.length === 0) return '';
            let markers = '';
            events.forEach(e => {
                if (!e.time || !e.time.elapsed) return;
                const min = e.time.elapsed + (e.time.extra || 0);
                const pct = Math.min(100, (min / 90) * 100);
                let color = '#888'; let icon = '';
                if (e.type === 'Goal') { color = '#2ea043'; icon = 'Goal'; }
                else if (e.type === 'Card' && e.detail === 'Yellow Card') { color = '#d29922'; icon = 'Yellow'; }
                else if (e.type === 'Card' && e.detail === 'Red Card') { color = '#da3633'; icon = 'Red'; }
                else if (e.type === 'subst') { color = '#1f6feb'; icon = 'Sub'; }
                else return;
                const team = e.team ? e.team.name : '';
                const player = e.player ? e.player.name : '';
                markers += `<div class="timeline-marker" style="left:${pct}%; background:${color};" title="${min}' ${icon} ${player} (${team})"><div class="timeline-tooltip">${min}' ${icon} ${player}</div></div>`;
            });
            return `<div class="match-timeline"><div class="timeline-half"></div>${markers}</div>`;
        }

        // ========== BANKROLL MILESTONES ==========
        function renderMilestones(currentStake) {
            const milestones = [
                { amount: 5, label: '¬£5' },
                { amount: 25, label: '¬£25' },
                { amount: 50, label: '¬£50' },
                { amount: 100, label: '¬£100' },
                { amount: 250, label: '¬£250' },
                { amount: 500, label: '¬£500' }
            ];
            const track = document.getElementById('milestoneTrack');
            if (!track) return;
            let html = '';
            milestones.forEach(m => {
                const pct = ((m.amount - 5) / (500 - 5)) * 100;
                const reached = currentStake >= m.amount ? 'reached' : '';
                html += `<div class="milestone-dot ${reached}" style="left:${pct}%;"></div>`;
                html += `<div class="milestone-label" style="left:${pct}%; ${reached ? 'color:var(--gold);' : ''}">${m.label}</div>`;
            });
            track.innerHTML = html;
        }

        // exportCSV defined earlier, no duplicate needed

        // ========== STATS DASHBOARD ==========
        function renderStatsDashboard() {
            const container = document.getElementById('statsContent');
            const challenges = getPlacedChallenges();
            const streak = getChallengeStreak();
            const historyBets = getHistory();

            const resolved = challenges.filter(b => b.status === 'resolved');
            const totalBets = resolved.length + historyBets.filter(b => b.status === 'WIN' || b.status === 'LOSS').length;
            const totalWins = resolved.filter(b => b.result === true).length + historyBets.filter(b => b.status === 'WIN').length;
            const totalLosses = resolved.filter(b => b.result === false).length + historyBets.filter(b => b.status === 'LOSS').length;
            const winRate = totalBets > 0 ? Math.round((totalWins / totalBets) * 100) : 0;
            const winColor = winRate >= 60 ? 'var(--green)' : (winRate >= 45 ? 'var(--gold)' : 'var(--red)');

            let html = `<h3 style="color:var(--blue); margin:0 0 15px;">üìà Performance Dashboard</h3>`;

            html += `<div class="stats-grid">
                <div class="stat-tile"><div class="stat-tile-value" style="color:var(--blue);">${totalBets}</div><div class="stat-tile-label">Total Bets</div></div>
                <div class="stat-tile"><div class="stat-tile-value" style="color:${winColor};">${winRate}%</div><div class="stat-tile-label">Win Rate</div></div>
                <div class="stat-tile"><div class="stat-tile-value" style="color:var(--green);">${totalWins}</div><div class="stat-tile-label">Wins</div></div>
                <div class="stat-tile"><div class="stat-tile-value" style="color:var(--red);">${totalLosses}</div><div class="stat-tile-label">Losses</div></div>
            </div>`;

            html += `<div class="stats-grid">
                <div class="stat-tile"><div class="stat-tile-value" style="color:var(--gold);">${streak.currentStreak}</div><div class="stat-tile-label">Current Streak</div></div>
                <div class="stat-tile"><div class="stat-tile-value" style="color:var(--green);">${streak.bestStreak}</div><div class="stat-tile-label">Best Streak</div></div>
            </div>`;

            // Market performance
            const marketStats = {};
            resolved.forEach(b => {
                const key = getMarketLabel(b.selection);
                if (!marketStats[key]) marketStats[key] = { wins: 0, total: 0 };
                marketStats[key].total++;
                if (b.result) marketStats[key].wins++;
            });
            historyBets.forEach(b => {
                if (b.status !== 'WIN' && b.status !== 'LOSS') return;
                const key = getMarketLabel(b.selection || 'Unknown');
                if (!marketStats[key]) marketStats[key] = { wins: 0, total: 0 };
                marketStats[key].total++;
                if (b.status === 'WIN') marketStats[key].wins++;
            });

            if (Object.keys(marketStats).length > 0) {
                html += `<div class="stats-card"><div style="font-size:0.85rem; font-weight:bold; color:var(--gold); margin-bottom:12px;">By Market Type</div>`;
                const sorted = Object.entries(marketStats).sort((a, b) => b[1].total - a[1].total);
                sorted.forEach(([market, data]) => {
                    const rate = Math.round((data.wins / data.total) * 100);
                    const barColor = rate >= 60 ? 'var(--green)' : (rate >= 45 ? 'var(--gold)' : 'var(--red)');
                    html += `<div class="stats-bar">
                        <div class="stats-bar-label">${market}</div>
                        <div class="stats-bar-track"><div class="stats-bar-fill" style="width:${rate}%; background:${barColor};"></div></div>
                        <div class="stats-bar-val">${rate}% <span style="color:#666; font-size:0.6rem;">(${data.total})</span></div>
                    </div>`;
                });
                html += `</div>`;
            }

            // League performance
            const leagueStats = {};
            resolved.forEach(b => {
                const key = b.league || 'Unknown';
                if (!leagueStats[key]) leagueStats[key] = { wins: 0, total: 0 };
                leagueStats[key].total++;
                if (b.result) leagueStats[key].wins++;
            });

            if (Object.keys(leagueStats).length > 0) {
                html += `<div class="stats-card"><div style="font-size:0.85rem; font-weight:bold; color:var(--purple); margin-bottom:12px;">By League</div>`;
                const sortedL = Object.entries(leagueStats).sort((a, b) => b[1].total - a[1].total);
                sortedL.forEach(([league, data]) => {
                    const rate = Math.round((data.wins / data.total) * 100);
                    const barColor = rate >= 60 ? 'var(--green)' : (rate >= 45 ? 'var(--gold)' : 'var(--red)');
                    html += `<div class="stats-bar">
                        <div class="stats-bar-label">${league}</div>
                        <div class="stats-bar-track"><div class="stats-bar-fill" style="width:${rate}%; background:${barColor};"></div></div>
                        <div class="stats-bar-val">${rate}% <span style="color:#666; font-size:0.6rem;">(${data.total})</span></div>
                    </div>`;
                });
                html += `</div>`;
            }

            // 2nd Half Goal performance by league
            const hgBets = resolved.filter(b => b.selection === '2nd Half Goal');
            if (hgBets.length > 0) {
                const hgWins = hgBets.filter(b => b.result).length;
                const hgRate = Math.round((hgWins / hgBets.length) * 100);
                const hgColor = hgRate >= 60 ? 'var(--green)' : (hgRate >= 45 ? 'var(--gold)' : 'var(--red)');
                html += `<div class="stats-card"><div style="font-size:0.85rem; font-weight:bold; color:var(--green); margin-bottom:12px;">‚öΩ 2nd Half Goal Predictions</div>`;
                html += `<div style="display:flex; gap:10px; margin-bottom:12px;">
                    <div style="flex:1; background:rgba(255,255,255,0.04); padding:8px; border-radius:8px; text-align:center;">
                        <div style="font-size:1.1rem; font-weight:bold; color:${hgColor};">${hgRate}%</div>
                        <div style="font-size:0.65rem; color:#888;">Hit Rate</div>
                    </div>
                    <div style="flex:1; background:rgba(255,255,255,0.04); padding:8px; border-radius:8px; text-align:center;">
                        <div style="font-size:1.1rem; font-weight:bold; color:var(--green);">${hgWins}</div>
                        <div style="font-size:0.65rem; color:#888;">Wins</div>
                    </div>
                    <div style="flex:1; background:rgba(255,255,255,0.04); padding:8px; border-radius:8px; text-align:center;">
                        <div style="font-size:1.1rem; font-weight:bold; color:var(--red);">${hgBets.length - hgWins}</div>
                        <div style="font-size:0.65rem; color:#888;">Losses</div>
                    </div>
                </div>`;
                const hgLeagueStats = {};
                hgBets.forEach(b => {
                    const key = b.league || 'Unknown';
                    if (!hgLeagueStats[key]) hgLeagueStats[key] = { wins: 0, total: 0 };
                    hgLeagueStats[key].total++;
                    if (b.result) hgLeagueStats[key].wins++;
                });
                const sortedHgL = Object.entries(hgLeagueStats).sort((a, b) => b[1].total - a[1].total);
                sortedHgL.forEach(([league, data]) => {
                    const rate = Math.round((data.wins / data.total) * 100);
                    const barColor = rate >= 60 ? 'var(--green)' : (rate >= 45 ? 'var(--gold)' : 'var(--red)');
                    html += `<div class="stats-bar">
                        <div class="stats-bar-label">${league}</div>
                        <div class="stats-bar-track"><div class="stats-bar-fill" style="width:${rate}%; background:${barColor};"></div></div>
                        <div class="stats-bar-val">${rate}% <span style="color:#666; font-size:0.6rem;">(${data.total})</span></div>
                    </div>`;
                });
                html += `</div>`;
            }

            // Recent results timeline
            const recentBets = resolved.sort((a, b) => b.placedAt - a.placedAt).slice(0, 20);
            if (recentBets.length > 0) {
                html += `<div class="stats-card"><div style="font-size:0.85rem; font-weight:bold; color:var(--blue); margin-bottom:12px;">Recent Form (Last ${recentBets.length})</div>`;
                html += `<div style="display:flex; gap:3px; flex-wrap:wrap;">`;
                recentBets.forEach(b => {
                    const color = b.result ? 'var(--green)' : 'var(--red)';
                    const letter = b.result ? 'W' : 'L';
                    html += `<div style="width:22px; height:22px; border-radius:4px; background:${color}; display:flex; align-items:center; justify-content:center; font-size:0.65rem; font-weight:bold; color:white;" title="${b.match}: ${b.selection}">${letter}</div>`;
                });
                html += `</div></div>`;
            }

            if (totalBets === 0) {
                html += `<div style="text-align:center; color:#666; padding:30px;">
                    <p style="font-size:1.5rem;">üìä</p>
                    <p>No betting data yet. Start placing bets to see your performance stats here.</p>
                </div>`;
            }

            html += `<button class="export-btn" onclick="exportCSV()" style="margin-top:10px;">üì• Export All History (CSV)</button>`;

            container.innerHTML = html;
        }

        function getMarketLabel(selection) {
            if (!selection) return 'Unknown';
            if (selection.startsWith('Over')) return selection.split(' ').slice(0, 2).join(' ');
            if (selection.startsWith('Next Goal:')) return 'Next Goal';
            if (selection.startsWith('Anytime Goalscorer:')) return 'Goalscorer';
            if (selection.startsWith('Anytime Booking:')) return 'Booking';
            if (selection === 'Both Teams to Score') return 'BTTS';
            if (selection === 'Home Win' || selection === 'Away Win') return selection;
            return selection;
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(err => console.log('SW registration failed:', err));
            });
        }
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');
        if (installBtn) {
            window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); deferredPrompt = e; installBtn.style.display = 'block'; });
            installBtn.addEventListener('click', async () => { if (deferredPrompt) { deferredPrompt.prompt(); deferredPrompt = null; installBtn.style.display = 'none'; } });
        }
    </script>
</body>
</html>
